{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Rendering/Core/Camera.js", "../../@kitware/vtk.js/Rendering/Core/Light.js", "../../@kitware/vtk.js/Rendering/Core/Viewport.js", "../../@kitware/vtk.js/Rendering/Core/Renderer.js"],
  "sourcesContent": ["import { mat4, vec4, vec3, quat } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport { r as radiansFromDegrees, k as add, j as cross } from '../../Common/Core/Math/index.js';\n\nconst {\n  vtkDebugMacro\n} = macro;\n\n/* eslint-disable new-cap */\n\n/*\n * Convenience function to access elements of a gl-matrix.  If it turns\n * out I have rows and columns swapped everywhere, then I'll just change\n * the order of 'row' and 'col' parameters in this function\n */\n// function getMatrixElement(matrix, row, col) {\n//   const idx = (row * 4) + col;\n//   return matrix[idx];\n// }\n\n// ----------------------------------------------------------------------------\n// vtkCamera methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCamera(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCamera');\n\n  // Set up private variables and methods\n  const origin = new Float64Array(3);\n  const dopbasis = new Float64Array([0.0, 0.0, -1.0]);\n  const upbasis = new Float64Array([0.0, 1.0, 0.0]);\n  const tmpMatrix = mat4.identity(new Float64Array(16));\n  const tmpMatrix2 = mat4.identity(new Float64Array(16));\n  const tmpvec1 = new Float64Array(3);\n  const tmpvec2 = new Float64Array(3);\n  const tmpvec3 = new Float64Array(3);\n  const rotateMatrix = mat4.identity(new Float64Array(16));\n  const trans = mat4.identity(new Float64Array(16));\n  const newPosition = new Float64Array(3);\n  const newFocalPoint = new Float64Array(3);\n\n  // Internal Functions that don't need to be public\n  function computeViewPlaneNormal() {\n    // VPN is -DOP\n    model.viewPlaneNormal[0] = -model.directionOfProjection[0];\n    model.viewPlaneNormal[1] = -model.directionOfProjection[1];\n    model.viewPlaneNormal[2] = -model.directionOfProjection[2];\n  }\n  publicAPI.orthogonalizeViewUp = () => {\n    const vt = publicAPI.getViewMatrix();\n    model.viewUp[0] = vt[4];\n    model.viewUp[1] = vt[5];\n    model.viewUp[2] = vt[6];\n    publicAPI.modified();\n  };\n  publicAPI.setPosition = (x, y, z) => {\n    if (x === model.position[0] && y === model.position[1] && z === model.position[2]) {\n      return;\n    }\n    model.position[0] = x;\n    model.position[1] = y;\n    model.position[2] = z;\n\n    // recompute the focal distance\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n  publicAPI.setFocalPoint = (x, y, z) => {\n    if (x === model.focalPoint[0] && y === model.focalPoint[1] && z === model.focalPoint[2]) {\n      return;\n    }\n    model.focalPoint[0] = x;\n    model.focalPoint[1] = y;\n    model.focalPoint[2] = z;\n\n    // recompute the focal distance\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n  publicAPI.setDistance = d => {\n    if (model.distance === d) {\n      return;\n    }\n    model.distance = d;\n    if (model.distance < 1e-20) {\n      model.distance = 1e-20;\n      vtkDebugMacro('Distance is set to minimum.');\n    }\n\n    // we want to keep the camera pointing in the same direction\n    const vec = model.directionOfProjection;\n\n    // recalculate FocalPoint\n    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  // This method must be called when the focal point or camera position changes\n  publicAPI.computeDistance = () => {\n    const dx = model.focalPoint[0] - model.position[0];\n    const dy = model.focalPoint[1] - model.position[1];\n    const dz = model.focalPoint[2] - model.position[2];\n    model.distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n    if (model.distance < 1e-20) {\n      model.distance = 1e-20;\n      vtkDebugMacro('Distance is set to minimum.');\n      const vec = model.directionOfProjection;\n\n      // recalculate FocalPoint\n      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    }\n    model.directionOfProjection[0] = dx / model.distance;\n    model.directionOfProjection[1] = dy / model.distance;\n    model.directionOfProjection[2] = dz / model.distance;\n    computeViewPlaneNormal();\n  };\n\n  //----------------------------------------------------------------------------\n  // Move the position of the camera along the view plane normal. Moving\n  // towards the focal point (e.g., > 1) is a dolly-in, moving away\n  // from the focal point (e.g., < 1) is a dolly-out.\n  publicAPI.dolly = amount => {\n    if (amount <= 0.0) {\n      return;\n    }\n\n    // dolly moves the camera towards the focus\n    const d = model.distance / amount;\n    publicAPI.setPosition(model.focalPoint[0] - d * model.directionOfProjection[0], model.focalPoint[1] - d * model.directionOfProjection[1], model.focalPoint[2] - d * model.directionOfProjection[2]);\n  };\n  publicAPI.roll = angle => {\n    const eye = model.position;\n    const at = model.focalPoint;\n    const up = model.viewUp;\n    const viewUpVec4 = new Float64Array([up[0], up[1], up[2], 0.0]);\n    mat4.identity(rotateMatrix);\n    const viewDir = new Float64Array([at[0] - eye[0], at[1] - eye[1], at[2] - eye[2]]);\n    mat4.rotate(rotateMatrix, rotateMatrix, radiansFromDegrees(angle), viewDir);\n    vec4.transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);\n    model.viewUp[0] = viewUpVec4[0];\n    model.viewUp[1] = viewUpVec4[1];\n    model.viewUp[2] = viewUpVec4[2];\n    publicAPI.modified();\n  };\n  publicAPI.azimuth = angle => {\n    const fp = model.focalPoint;\n    mat4.identity(trans);\n\n    // translate the focal point to the origin,\n    // rotate about view up,\n    // translate back again\n    mat4.translate(trans, trans, fp);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);\n    mat4.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newPosition, model.position, trans);\n    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);\n  };\n  publicAPI.yaw = angle => {\n    const position = model.position;\n    mat4.identity(trans);\n\n    // translate the camera to the origin,\n    // rotate about axis,\n    // translate back again\n    mat4.translate(trans, trans, position);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);\n    mat4.translate(trans, trans, [-position[0], -position[1], -position[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newFocalPoint, model.focalPoint, trans);\n    publicAPI.setFocalPoint(newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]);\n  };\n  publicAPI.elevation = angle => {\n    const fp = model.focalPoint;\n\n    // get the eye / camera position from the viewMatrix\n    const vt = publicAPI.getViewMatrix();\n    const axis = [-vt[0], -vt[1], -vt[2]];\n    mat4.identity(trans);\n\n    // translate the focal point to the origin,\n    // rotate about view up,\n    // translate back again\n    mat4.translate(trans, trans, fp);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), axis);\n    mat4.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);\n\n    // apply the transform to the position\n    vec3.transformMat4(newPosition, model.position, trans);\n    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);\n  };\n  publicAPI.pitch = angle => {\n    const position = model.position;\n    const vt = publicAPI.getViewMatrix();\n    const axis = [vt[0], vt[1], vt[2]];\n    mat4.identity(trans);\n\n    // translate the camera to the origin,\n    // rotate about axis,\n    // translate back again\n    mat4.translate(trans, trans, position);\n    mat4.rotate(trans, trans, radiansFromDegrees(angle), axis);\n    mat4.translate(trans, trans, [-position[0], -position[1], -position[2]]);\n\n    // apply the transform to the focal point\n    vec3.transformMat4(newFocalPoint, model.focalPoint, trans);\n    publicAPI.setFocalPoint(...newFocalPoint);\n  };\n  publicAPI.zoom = factor => {\n    if (factor <= 0) {\n      return;\n    }\n    if (model.parallelProjection) {\n      model.parallelScale /= factor;\n    } else {\n      model.viewAngle /= factor;\n    }\n    publicAPI.modified();\n  };\n  publicAPI.translate = (x, y, z) => {\n    const offset = [x, y, z];\n    add(model.position, offset, model.position);\n    add(model.focalPoint, offset, model.focalPoint);\n    publicAPI.computeDistance();\n    publicAPI.modified();\n  };\n  publicAPI.applyTransform = transformMat4 => {\n    const vuOld = [...model.viewUp, 1.0];\n    const posNew = [];\n    const fpNew = [];\n    const vuNew = [];\n    vuOld[0] += model.position[0];\n    vuOld[1] += model.position[1];\n    vuOld[2] += model.position[2];\n    vec4.transformMat4(posNew, [...model.position, 1.0], transformMat4);\n    vec4.transformMat4(fpNew, [...model.focalPoint, 1.0], transformMat4);\n    vec4.transformMat4(vuNew, vuOld, transformMat4);\n    vuNew[0] -= posNew[0];\n    vuNew[1] -= posNew[1];\n    vuNew[2] -= posNew[2];\n    publicAPI.setPosition(...posNew.slice(0, 3));\n    publicAPI.setFocalPoint(...fpNew.slice(0, 3));\n    publicAPI.setViewUp(...vuNew.slice(0, 3));\n  };\n  publicAPI.getThickness = () => model.clippingRange[1] - model.clippingRange[0];\n  publicAPI.setThickness = thickness => {\n    let t = thickness;\n    if (t < 1e-20) {\n      t = 1e-20;\n      vtkDebugMacro('Thickness is set to minimum.');\n    }\n    publicAPI.setClippingRange(model.clippingRange[0], model.clippingRange[0] + t);\n  };\n  publicAPI.setThicknessFromFocalPoint = thickness => {\n    let t = thickness;\n    if (t < 1e-20) {\n      t = 1e-20;\n      vtkDebugMacro('Thickness is set to minimum.');\n    }\n    publicAPI.setClippingRange(model.distance - t / 2, model.distance + t / 2);\n  };\n\n  // Unimplemented functions\n  publicAPI.setRoll = angle => {}; // dependency on GetOrientation() and a model.ViewTransform object, see https://github.com/Kitware/VTK/blob/master/Common/Transforms/vtkTransform.cxx and https://vtk.org/doc/nightly/html/classvtkTransform.html\n  publicAPI.getRoll = () => {};\n  publicAPI.setObliqueAngles = (alpha, beta) => {};\n  publicAPI.getOrientation = () => {};\n  publicAPI.getOrientationWXYZ = () => {};\n  publicAPI.getFrustumPlanes = aspect => {\n    // Return array of 24 params (4 params for each of 6 plane equations)\n  };\n  publicAPI.getCameraLightTransformMatrix = matrix => {\n    mat4.copy(matrix, model.cameraLightTransform);\n    return matrix;\n  };\n  publicAPI.computeCameraLightTransform = () => {\n    // not sure if this is the correct transformation, based on the same funciton in VTK\n    mat4.copy(tmpMatrix, publicAPI.getViewMatrix());\n    mat4.invert(tmpMatrix, tmpMatrix);\n    mat4.fromScaling(tmpMatrix2, [model.distance, model.distance, model.distance]);\n    mat4.multiply(tmpMatrix, tmpMatrix, tmpMatrix2);\n    mat4.identity(model.cameraLightTransform);\n    mat4.translate(model.cameraLightTransform, tmpMatrix, [0.0, 0.0, -1.0]);\n  };\n  publicAPI.deepCopy = sourceCamera => {};\n  publicAPI.physicalOrientationToWorldDirection = ori => {\n    // push the x axis through the orientation quat\n    const oriq = quat.fromValues(ori[0], ori[1], ori[2], ori[3]);\n    const coriq = quat.create();\n    const qdir = quat.fromValues(0.0, 0.0, 1.0, 0.0);\n    quat.conjugate(coriq, oriq);\n\n    // rotate the z axis by the quat\n    quat.multiply(qdir, oriq, qdir);\n    quat.multiply(qdir, qdir, coriq);\n\n    // return the z axis in world coords\n    return [qdir[0], qdir[1], qdir[2]];\n  };\n  publicAPI.getPhysicalToWorldMatrix = result => {\n    publicAPI.getWorldToPhysicalMatrix(result);\n    mat4.invert(result, result);\n  };\n  publicAPI.getWorldToPhysicalMatrix = result => {\n    mat4.identity(result);\n\n    // now the physical to vtk world rotation tform\n    const physVRight = [3];\n    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);\n    result[0] = physVRight[0];\n    result[1] = physVRight[1];\n    result[2] = physVRight[2];\n    result[4] = model.physicalViewUp[0];\n    result[5] = model.physicalViewUp[1];\n    result[6] = model.physicalViewUp[2];\n    result[8] = -model.physicalViewNorth[0];\n    result[9] = -model.physicalViewNorth[1];\n    result[10] = -model.physicalViewNorth[2];\n    mat4.transpose(result, result);\n    vec3.set(tmpvec1, 1 / model.physicalScale, 1 / model.physicalScale, 1 / model.physicalScale);\n    mat4.scale(result, result, tmpvec1);\n    mat4.translate(result, result, model.physicalTranslation);\n  };\n  publicAPI.computeViewParametersFromViewMatrix = vmat => {\n    // invert to get view to world\n    mat4.invert(tmpMatrix, vmat);\n\n    // note with glmatrix operations happen in\n    // the reverse order\n    // mat.scale\n    // mat.translate\n    // will result in the translation then the scale\n    // mat.mult(a,b)\n    // results in perform the B transformation then A\n\n    // then extract the params position, orientation\n    // push 0,0,0 through to get a translation\n    vec3.transformMat4(tmpvec1, origin, tmpMatrix);\n    publicAPI.computeDistance();\n    const oldDist = model.distance;\n    publicAPI.setPosition(tmpvec1[0], tmpvec1[1], tmpvec1[2]);\n\n    // push basis vectors to get orientation\n    vec3.transformMat4(tmpvec2, dopbasis, tmpMatrix);\n    vec3.subtract(tmpvec2, tmpvec2, tmpvec1);\n    vec3.normalize(tmpvec2, tmpvec2);\n    publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);\n    vec3.transformMat4(tmpvec3, upbasis, tmpMatrix);\n    vec3.subtract(tmpvec3, tmpvec3, tmpvec1);\n    vec3.normalize(tmpvec3, tmpvec3);\n    publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);\n    publicAPI.setDistance(oldDist);\n  };\n\n  // the provided matrix should include\n  // translation and orientation only\n  // mat is physical to view\n  publicAPI.computeViewParametersFromPhysicalMatrix = mat => {\n    // get the WorldToPhysicalMatrix\n    publicAPI.getWorldToPhysicalMatrix(tmpMatrix);\n\n    // first convert the physical -> view matrix to be\n    // world -> view\n    mat4.multiply(tmpMatrix, mat, tmpMatrix);\n    publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);\n  };\n  publicAPI.setViewMatrix = mat => {\n    model.viewMatrix = mat;\n    if (model.viewMatrix) {\n      mat4.copy(tmpMatrix, model.viewMatrix);\n      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);\n      mat4.transpose(model.viewMatrix, model.viewMatrix);\n    }\n  };\n  publicAPI.getViewMatrix = () => {\n    if (model.viewMatrix) {\n      return model.viewMatrix;\n    }\n    mat4.lookAt(tmpMatrix, model.position,\n    // eye\n    model.focalPoint,\n    // at\n    model.viewUp // up\n    );\n\n    mat4.transpose(tmpMatrix, tmpMatrix);\n    const result = new Float64Array(16);\n    mat4.copy(result, tmpMatrix);\n    return result;\n  };\n  publicAPI.setProjectionMatrix = mat => {\n    model.projectionMatrix = mat;\n  };\n  publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {\n    const result = new Float64Array(16);\n    mat4.identity(result);\n    if (model.projectionMatrix) {\n      const scale = 1 / model.physicalScale;\n      vec3.set(tmpvec1, scale, scale, scale);\n      mat4.copy(result, model.projectionMatrix);\n      mat4.scale(result, result, tmpvec1);\n      mat4.transpose(result, result);\n      return result;\n    }\n    mat4.identity(tmpMatrix);\n\n    // FIXME: Not sure what to do about adjust z buffer here\n    // adjust Z-buffer range\n    // this->ProjectionTransform->AdjustZBuffer( -1, +1, nearz, farz );\n    const cWidth = model.clippingRange[1] - model.clippingRange[0];\n    const cRange = [model.clippingRange[0] + (nearz + 1) * cWidth / 2.0, model.clippingRange[0] + (farz + 1) * cWidth / 2.0];\n    if (model.parallelProjection) {\n      // set up a rectangular parallelipiped\n      const width = model.parallelScale * aspect;\n      const height = model.parallelScale;\n      const xmin = (model.windowCenter[0] - 1.0) * width;\n      const xmax = (model.windowCenter[0] + 1.0) * width;\n      const ymin = (model.windowCenter[1] - 1.0) * height;\n      const ymax = (model.windowCenter[1] + 1.0) * height;\n      mat4.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);\n      mat4.transpose(tmpMatrix, tmpMatrix);\n    } else if (model.useOffAxisProjection) {\n      throw new Error('Off-Axis projection is not supported at this time');\n    } else {\n      const tmp = Math.tan(radiansFromDegrees(model.viewAngle) / 2.0);\n      let width;\n      let height;\n      if (model.useHorizontalViewAngle === true) {\n        width = model.clippingRange[0] * tmp;\n        height = model.clippingRange[0] * tmp / aspect;\n      } else {\n        width = model.clippingRange[0] * tmp * aspect;\n        height = model.clippingRange[0] * tmp;\n      }\n      const xmin = (model.windowCenter[0] - 1.0) * width;\n      const xmax = (model.windowCenter[0] + 1.0) * width;\n      const ymin = (model.windowCenter[1] - 1.0) * height;\n      const ymax = (model.windowCenter[1] + 1.0) * height;\n      const znear = cRange[0];\n      const zfar = cRange[1];\n      tmpMatrix[0] = 2.0 * znear / (xmax - xmin);\n      tmpMatrix[5] = 2.0 * znear / (ymax - ymin);\n      tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);\n      tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);\n      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);\n      tmpMatrix[14] = -1.0;\n      tmpMatrix[11] = -2.0 * znear * zfar / (zfar - znear);\n      tmpMatrix[15] = 0.0;\n    }\n    mat4.copy(result, tmpMatrix);\n    return result;\n  };\n  publicAPI.getCompositeProjectionMatrix = (aspect, nearz, farz) => {\n    const vMat = publicAPI.getViewMatrix();\n    const pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz);\n    // mats are transposed so the order is A then B\n    // we reuse pMat as it is a copy so we can do what we want with it\n    mat4.multiply(pMat, vMat, pMat);\n    return pMat;\n  };\n  publicAPI.setDirectionOfProjection = (x, y, z) => {\n    if (model.directionOfProjection[0] === x && model.directionOfProjection[1] === y && model.directionOfProjection[2] === z) {\n      return;\n    }\n    model.directionOfProjection[0] = x;\n    model.directionOfProjection[1] = y;\n    model.directionOfProjection[2] = z;\n    const vec = model.directionOfProjection;\n\n    // recalculate FocalPoint\n    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;\n    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;\n    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;\n    computeViewPlaneNormal();\n  };\n\n  // used to handle convert js device orientation angles\n  // when you use this method the camera will adjust to the\n  // device orientation such that the physicalViewUp you set\n  // in world coordinates looks up, and the physicalViewNorth\n  // you set in world coorindates will (maybe) point north\n  //\n  // NOTE WARNING - much of the documentation out there on how\n  // orientation works is seriously wrong. Even worse the Chrome\n  // device orientation simulator is completely wrong and should\n  // never be used. OMG it is so messed up.\n  //\n  // how it seems to work on iOS is that the device orientation\n  // is specified in extrinsic angles with a alpha, beta, gamma\n  // convention with axes of Z, X, Y (the code below substitutes\n  // the physical coordinate system for these axes to get the right\n  // modified coordinate system.\n  publicAPI.setDeviceAngles = (alpha, beta, gamma, screen) => {\n    const physVRight = [3];\n    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);\n\n    // phone to physical coordinates\n    const rotmat = mat4.identity(new Float64Array(16));\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(alpha), model.physicalViewUp);\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(beta), physVRight);\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(gamma), model.physicalViewNorth);\n    mat4.rotate(rotmat, rotmat, radiansFromDegrees(-screen), model.physicalViewUp);\n    const dop = new Float64Array([-model.physicalViewUp[0], -model.physicalViewUp[1], -model.physicalViewUp[2]]);\n    const vup = new Float64Array(model.physicalViewNorth);\n    vec3.transformMat4(dop, dop, rotmat);\n    vec3.transformMat4(vup, vup, rotmat);\n    publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);\n    publicAPI.setViewUp(vup[0], vup[1], vup[2]);\n    publicAPI.modified();\n  };\n  publicAPI.setOrientationWXYZ = (degrees, x, y, z) => {\n    const quatMat = mat4.identity(new Float64Array(16));\n    if (degrees !== 0.0 && (x !== 0.0 || y !== 0.0 || z !== 0.0)) {\n      // convert to radians\n      const angle = radiansFromDegrees(degrees);\n      const q = quat.create();\n      quat.setAxisAngle(q, [x, y, z], angle);\n      mat4.fromQuat(quatMat, q);\n    }\n    const newdop = new Float64Array(3);\n    vec3.transformMat4(newdop, [0.0, 0.0, -1.0], quatMat);\n    const newvup = new Float64Array(3);\n    vec3.transformMat4(newvup, [0.0, 1.0, 0.0], quatMat);\n    publicAPI.setDirectionOfProjection(...newdop);\n    publicAPI.setViewUp(...newvup);\n    publicAPI.modified();\n  };\n  publicAPI.computeClippingRange = bounds => {\n    let vn = null;\n    let position = null;\n    vn = model.viewPlaneNormal;\n    position = model.position;\n    const a = -vn[0];\n    const b = -vn[1];\n    const c = -vn[2];\n    const d = -(a * position[0] + b * position[1] + c * position[2]);\n\n    // Set the max near clipping plane and the min far clipping plane\n    const range = [a * bounds[0] + b * bounds[2] + c * bounds[4] + d, 1e-18];\n\n    // Find the closest / farthest bounding box vertex\n    for (let k = 0; k < 2; k++) {\n      for (let j = 0; j < 2; j++) {\n        for (let i = 0; i < 2; i++) {\n          const dist = a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;\n          range[0] = dist < range[0] ? dist : range[0];\n          range[1] = dist > range[1] ? dist : range[1];\n        }\n      }\n    }\n    return range;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  position: [0, 0, 1],\n  focalPoint: [0, 0, 0],\n  viewUp: [0, 1, 0],\n  directionOfProjection: [0, 0, -1],\n  parallelProjection: false,\n  useHorizontalViewAngle: false,\n  viewAngle: 30,\n  parallelScale: 1,\n  clippingRange: [0.01, 1000.01],\n  windowCenter: [0, 0],\n  viewPlaneNormal: [0, 0, 1],\n  useOffAxisProjection: false,\n  screenBottomLeft: [-0.5, -0.5, -0.5],\n  screenBottomRight: [0.5, -0.5, -0.5],\n  screenTopRight: [0.5, 0.5, -0.5],\n  freezeFocalPoint: false,\n  projectionMatrix: null,\n  viewMatrix: null,\n  cameraLightTransform: mat4.create(),\n  // used for world to physical transformations\n  physicalTranslation: [0, 0, 0],\n  physicalScale: 1.0,\n  physicalViewUp: [0, 1, 0],\n  physicalViewNorth: [0, 0, -1]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['distance']);\n  macro.setGet(publicAPI, model, ['parallelProjection', 'useHorizontalViewAngle', 'viewAngle', 'parallelScale', 'useOffAxisProjection', 'freezeFocalPoint', 'physicalScale']);\n  macro.getArray(publicAPI, model, ['directionOfProjection', 'viewPlaneNormal', 'position', 'focalPoint']);\n  macro.setGetArray(publicAPI, model, ['clippingRange', 'windowCenter'], 2);\n  macro.setGetArray(publicAPI, model, ['viewUp', 'screenBottomLeft', 'screenBottomRight', 'screenTopRight', 'physicalTranslation', 'physicalViewUp', 'physicalViewNorth'], 3);\n\n  // Object methods\n  vtkCamera(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCamera');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCamera$1 = {\n  newInstance,\n  extend\n};\n\nexport { DEFAULT_VALUES, vtkCamera$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport { l as normalize, r as radiansFromDegrees } from '../../Common/Core/Math/index.js';\nimport { vec3 } from 'gl-matrix';\n\n// ----------------------------------------------------------------------------\n\nconst LIGHT_TYPES = ['HeadLight', 'CameraLight', 'SceneLight'];\n\n// ----------------------------------------------------------------------------\n// vtkLight methods\n// ----------------------------------------------------------------------------\n\nfunction vtkLight(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkLight');\n  const tmpVec = new Float64Array(3);\n  publicAPI.getTransformedPosition = () => {\n    if (model.transformMatrix) {\n      vec3.transformMat4(tmpVec, model.position, model.transformMatrix);\n    } else {\n      vec3.set(tmpVec, model.position[0], model.position[1], model.position[2]);\n    }\n    return tmpVec;\n  };\n  publicAPI.getTransformedFocalPoint = () => {\n    if (model.transformMatrix) {\n      vec3.transformMat4(tmpVec, model.focalPoint, model.transformMatrix);\n    } else {\n      vec3.set(tmpVec, model.focalPoint[0], model.focalPoint[1], model.focalPoint[2]);\n    }\n    return tmpVec;\n  };\n  publicAPI.getDirection = () => {\n    if (model.directionMTime < model.mtime) {\n      vec3.sub(model.direction, model.focalPoint, model.position);\n      normalize(model.direction);\n      model.directionMTime = model.mtime;\n    }\n    return model.direction;\n  };\n\n  // Sets the direction from a vec3 instead of a focal point\n  publicAPI.setDirection = directionVector => {\n    const newFocalPoint = new Float64Array(3);\n    vec3.sub(newFocalPoint, model.position, directionVector);\n    model.focalPoint = newFocalPoint;\n  };\n  publicAPI.setDirectionAngle = (elevation, azimuth) => {\n    const elevationRadians = radiansFromDegrees(elevation);\n    const azimuthRadians = radiansFromDegrees(azimuth);\n    publicAPI.setPosition(Math.cos(elevationRadians) * Math.sin(azimuthRadians), Math.sin(elevationRadians), Math.cos(elevationRadians) * Math.cos(azimuthRadians));\n    publicAPI.setFocalPoint(0, 0, 0);\n    publicAPI.setPositional(0);\n  };\n  publicAPI.setLightTypeToHeadLight = () => {\n    publicAPI.setLightType('HeadLight');\n  };\n  publicAPI.setLightTypeToCameraLight = () => {\n    publicAPI.setLightType('CameraLight');\n  };\n  publicAPI.setLightTypeToSceneLight = () => {\n    publicAPI.setTransformMatrix(null);\n    publicAPI.setLightType('SceneLight');\n  };\n  publicAPI.lightTypeIsHeadLight = () => model.lightType === 'HeadLight';\n  publicAPI.lightTypeIsSceneLight = () => model.lightType === 'SceneLight';\n  publicAPI.lightTypeIsCameraLight = () => model.lightType === 'CameraLight';\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  switch: true,\n  intensity: 1,\n  color: [1, 1, 1],\n  position: [0, 0, 1],\n  focalPoint: [0, 0, 0],\n  positional: false,\n  exponent: 1,\n  coneAngle: 30,\n  coneFalloff: 5,\n  attenuationValues: [1, 0, 0],\n  transformMatrix: null,\n  lightType: 'SceneLight',\n  shadowAttenuation: 1,\n  direction: [0, 0, 0],\n  directionMTime: 0\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['intensity', 'switch', 'positional', 'exponent', 'coneAngle', 'coneFalloff', 'transformMatrix', 'lightType', 'shadowAttenuation', 'attenuationValues']);\n  macro.setGetArray(publicAPI, model, ['color', 'position', 'focalPoint', 'attenuationValues'], 3);\n\n  // Object methods\n  vtkLight(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkLight');\n\n// ----------------------------------------------------------------------------\n\nvar vtkLight$1 = {\n  newInstance,\n  extend,\n  LIGHT_TYPES\n};\n\nexport { LIGHT_TYPES, vtkLight$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nfunction notImplemented(method) {\n  return () => vtkErrorMacro(`vtkViewport::${method} - NOT IMPLEMENTED`);\n}\n\n// ----------------------------------------------------------------------------\n// vtkViewport methods\n// ----------------------------------------------------------------------------\n\nfunction vtkViewport(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkViewport');\n\n  // Public API methods\n  publicAPI.getViewProps = () => model.props;\n  publicAPI.hasViewProp = prop => model.props.includes(prop);\n  publicAPI.addViewProp = prop => {\n    if (prop && !publicAPI.hasViewProp(prop)) {\n      model.props.push(prop);\n    }\n  };\n  publicAPI.removeViewProp = prop => {\n    const newPropList = model.props.filter(item => item !== prop);\n    if (model.props.length !== newPropList.length) {\n      model.props = newPropList;\n    }\n  };\n  publicAPI.removeAllViewProps = () => {\n    model.props = [];\n  };\n\n  // this method get all the props including any nested props\n  function gatherProps(prop) {\n    let allProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    allProps.push(prop);\n    const children = prop.getNestedProps();\n    if (children && children.length) {\n      for (let i = 0; i < children.length; i++) {\n        gatherProps(children[i], allProps);\n      }\n    }\n    return allProps;\n  }\n  publicAPI.getViewPropsWithNestedProps = () => {\n    let allPropsArray = [];\n    // Handle actor2D instances separately so that they can be overlayed and layered\n    const actors2D = publicAPI.getActors2D();\n    // Sort the actor2D list using its layer number\n    actors2D.sort((a, b) => a.getLayerNumber() - b.getLayerNumber());\n    // Filter out all the actor2D instances\n    const newPropList = model.props.filter(item => !actors2D.includes(item));\n    for (let i = 0; i < newPropList.length; i++) {\n      gatherProps(newPropList[i], allPropsArray);\n    }\n    // Finally, add the actor2D props at the end of the list\n    // This works because, when traversing the render pass in vtkOpenGLRenderer, the children are\n    // traversed in the order that they are added to the list\n    allPropsArray = allPropsArray.concat(actors2D);\n    return allPropsArray;\n  };\n  publicAPI.addActor2D = publicAPI.addViewProp;\n  publicAPI.removeActor2D = prop => {\n    // VTK way: model.actors2D.RemoveItem(prop);\n    publicAPI.removeViewProp(prop);\n  };\n  publicAPI.getActors2D = () => {\n    model.actors2D = [];\n    model.props.forEach(prop => {\n      model.actors2D = model.actors2D.concat(prop.getActors2D());\n    });\n    return model.actors2D;\n  };\n  publicAPI.displayToView = () => vtkErrorMacro('call displayToView on your view instead');\n  publicAPI.viewToDisplay = () => vtkErrorMacro('callviewtodisplay on your view instead');\n  publicAPI.getSize = () => vtkErrorMacro('call getSize on your View instead');\n  publicAPI.normalizedDisplayToProjection = (x, y, z) => {\n    // first to normalized viewport\n    const nvp = publicAPI.normalizedDisplayToNormalizedViewport(x, y, z);\n\n    // then to view\n    return publicAPI.normalizedViewportToProjection(nvp[0], nvp[1], nvp[2]);\n  };\n  publicAPI.normalizedDisplayToNormalizedViewport = (x, y, z) => {\n    const scale = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];\n    return [(x - model.viewport[0]) / scale[0], (y - model.viewport[1]) / scale[1], z];\n  };\n  publicAPI.normalizedViewportToProjection = (x, y, z) => [x * 2.0 - 1.0, y * 2.0 - 1.0, z * 2.0 - 1.0];\n  publicAPI.projectionToNormalizedDisplay = (x, y, z) => {\n    // first to nvp\n    const nvp = publicAPI.projectionToNormalizedViewport(x, y, z);\n\n    // then to ndp\n    return publicAPI.normalizedViewportToNormalizedDisplay(nvp[0], nvp[1], nvp[2]);\n  };\n  publicAPI.normalizedViewportToNormalizedDisplay = (x, y, z) => {\n    const scale = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];\n    return [x * scale[0] + model.viewport[0], y * scale[1] + model.viewport[1], z];\n  };\n  publicAPI.projectionToNormalizedViewport = (x, y, z) => [(x + 1.0) * 0.5, (y + 1.0) * 0.5, (z + 1.0) * 0.5];\n  publicAPI.PickPropFrom = notImplemented('PickPropFrom');\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // _vtkWindow: null,\n  background: [0, 0, 0],\n  background2: [0.2, 0.2, 0.2],\n  gradientBackground: false,\n  viewport: [0, 0, 1, 1],\n  aspect: [1, 1],\n  pixelAspect: [1, 1],\n  props: [],\n  actors2D: []\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.event(publicAPI, model, 'event');\n  macro.setGetArray(publicAPI, model, ['viewport'], 4);\n  macro.setGetArray(publicAPI, model, ['background', 'background2'], 3);\n  vtkViewport(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkViewport');\n\n// ----------------------------------------------------------------------------\n\nvar vtkViewport$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkViewport$1 as default, extend, newInstance };\n", "import { mat4, vec3 } from 'gl-matrix';\nimport { n as newInstance$1, g as get, e as setGet, k as getArray, l as setGetArray, i as moveToProtected, c as macro } from '../../macros2.js';\nimport vtkCamera from './Camera.js';\nimport vtkLight from './Light.js';\nimport { U as areBoundsInitialized, u as uninitializeBounds, r as radiansFromDegrees, d as dot, H as createUninitializedBounds } from '../../Common/Core/Math/index.js';\nimport vtkViewport from './Viewport.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\n\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\nfunction notImplemented(method) {\n  return () => vtkErrorMacro(`vtkRenderer::${method} - NOT IMPLEMENTED`);\n}\n\n// ----------------------------------------------------------------------------\n// vtkRenderer methods\n// ----------------------------------------------------------------------------\n\nfunction vtkRenderer(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkRenderer');\n\n  // Events\n  const COMPUTE_VISIBLE_PROP_BOUNDS_EVENT = {\n    type: 'ComputeVisiblePropBoundsEvent',\n    renderer: publicAPI\n  };\n  const RESET_CAMERA_CLIPPING_RANGE_EVENT = {\n    type: 'ResetCameraClippingRangeEvent',\n    renderer: publicAPI\n  };\n  const RESET_CAMERA_EVENT = {\n    type: 'ResetCameraEvent',\n    renderer: publicAPI\n  };\n  publicAPI.updateCamera = () => {\n    if (!model.activeCamera) {\n      vtkDebugMacro('No cameras are on, creating one.');\n      // the get method will automagically create a camera\n      // and reset it since one hasn't been specified yet.\n      publicAPI.getActiveCameraAndResetIfCreated();\n    }\n\n    // update the viewing transformation\n    model.activeCamera.render(publicAPI);\n    return true;\n  };\n  publicAPI.updateLightsGeometryToFollowCamera = () => {\n    // only update the light's geometry if this Renderer is tracking\n    // this lights.  That allows one renderer to view the lights that\n    // another renderer is setting up.\n    const camera = publicAPI.getActiveCameraAndResetIfCreated();\n    model.lights.forEach(light => {\n      if (light.lightTypeIsSceneLight()) ; else if (light.lightTypeIsHeadLight()) {\n        // update position and orientation of light to match camera.\n        light.setPositionFrom(camera.getPositionByReference());\n        light.setFocalPointFrom(camera.getFocalPointByReference());\n        light.modified(camera.getMTime());\n      } else if (light.lightTypeIsCameraLight()) {\n        light.setTransformMatrix(camera.getCameraLightTransformMatrix(mat4.create()));\n      } else {\n        vtkErrorMacro('light has unknown light type', light.get());\n      }\n    });\n  };\n  publicAPI.updateLightGeometry = () => {\n    if (model.lightFollowCamera) {\n      // only update the light's geometry if this Renderer is tracking\n      // this lights.  That allows one renderer to view the lights that\n      // another renderer is setting up.\n      return publicAPI.updateLightsGeometryToFollowCamera();\n    }\n    return true;\n  };\n  publicAPI.allocateTime = notImplemented('allocateTime');\n  publicAPI.updateGeometry = notImplemented('updateGeometry');\n  publicAPI.getVTKWindow = () => model._renderWindow;\n  publicAPI.setLayer = layer => {\n    vtkDebugMacro(publicAPI.getClassName(), publicAPI, 'setting Layer to ', layer);\n    if (model.layer !== layer) {\n      model.layer = layer;\n      publicAPI.modified();\n    }\n    publicAPI.setPreserveColorBuffer(!!layer);\n  };\n  publicAPI.setActiveCamera = camera => {\n    if (model.activeCamera === camera) {\n      return false;\n    }\n    model.activeCamera = camera;\n    publicAPI.modified();\n    publicAPI.invokeEvent({\n      type: 'ActiveCameraEvent',\n      camera\n    });\n    return true;\n  };\n  publicAPI.makeCamera = () => {\n    const camera = vtkCamera.newInstance();\n    publicAPI.invokeEvent({\n      type: 'CreateCameraEvent',\n      camera\n    });\n    return camera;\n  };\n\n  // Replace the set/get macro method\n  publicAPI.getActiveCamera = () => {\n    if (!model.activeCamera) {\n      model.activeCamera = publicAPI.makeCamera();\n    }\n    return model.activeCamera;\n  };\n  publicAPI.getActiveCameraAndResetIfCreated = () => {\n    if (!model.activeCamera) {\n      publicAPI.getActiveCamera();\n      publicAPI.resetCamera();\n    }\n    return model.activeCamera;\n  };\n  publicAPI.getActors = () => {\n    model.actors = [];\n    model.props.forEach(prop => {\n      model.actors = model.actors.concat(prop.getActors());\n    });\n    return model.actors;\n  };\n  publicAPI.addActor = publicAPI.addViewProp;\n  publicAPI.removeActor = actor => {\n    model.actors = model.actors.filter(a => a !== actor);\n    publicAPI.removeViewProp(actor);\n    publicAPI.modified();\n  };\n  publicAPI.removeAllActors = () => {\n    const actors = publicAPI.getActors();\n    actors.forEach(actor => {\n      publicAPI.removeViewProp(actor);\n    });\n    model.actors = [];\n    publicAPI.modified();\n  };\n  publicAPI.getVolumes = () => {\n    model.volumes = [];\n    model.props.forEach(prop => {\n      model.volumes = model.volumes.concat(prop.getVolumes());\n    });\n    return model.volumes;\n  };\n  publicAPI.addVolume = publicAPI.addViewProp;\n  publicAPI.removeVolume = volume => {\n    model.volumes = model.volumes.filter(v => v !== volume);\n    publicAPI.removeViewProp(volume);\n    publicAPI.modified();\n  };\n  publicAPI.removeAllVolumes = () => {\n    const volumes = publicAPI.getVolumes();\n    volumes.forEach(volume => {\n      publicAPI.removeViewProp(volume);\n    });\n    model.volumes = [];\n    publicAPI.modified();\n  };\n  publicAPI.hasLight = light => model.lights.includes(light);\n  publicAPI.addLight = light => {\n    if (light && !publicAPI.hasLight(light)) {\n      model.lights.push(light);\n      publicAPI.modified();\n    }\n  };\n  publicAPI.removeLight = light => {\n    model.lights = model.lights.filter(l => l !== light);\n    publicAPI.modified();\n  };\n  publicAPI.removeAllLights = () => {\n    model.lights = [];\n    publicAPI.modified();\n  };\n  publicAPI.setLightCollection = lights => {\n    model.lights = lights;\n    publicAPI.modified();\n  };\n  publicAPI.makeLight = vtkLight.newInstance;\n  publicAPI.createLight = () => {\n    if (!model.automaticLightCreation) {\n      return;\n    }\n    if (model._createdLight) {\n      publicAPI.removeLight(model._createdLight);\n      model._createdLight.delete();\n      model._createdLight = null;\n    }\n    model._createdLight = publicAPI.makeLight();\n    publicAPI.addLight(model._createdLight);\n    model._createdLight.setLightTypeToHeadLight();\n\n    // set these values just to have a good default should LightFollowCamera\n    // be turned off.\n    model._createdLight.setPosition(publicAPI.getActiveCamera().getPosition());\n    model._createdLight.setFocalPoint(publicAPI.getActiveCamera().getFocalPoint());\n  };\n\n  // requires the aspect ratio of the viewport as X/Y\n  publicAPI.normalizedDisplayToWorld = (x, y, z, aspect) => {\n    let vpd = publicAPI.normalizedDisplayToProjection(x, y, z);\n    vpd = publicAPI.projectionToView(vpd[0], vpd[1], vpd[2], aspect);\n    return publicAPI.viewToWorld(vpd[0], vpd[1], vpd[2]);\n  };\n\n  // requires the aspect ratio of the viewport as X/Y\n  publicAPI.worldToNormalizedDisplay = (x, y, z, aspect) => {\n    let vpd = publicAPI.worldToView(x, y, z);\n    vpd = publicAPI.viewToProjection(vpd[0], vpd[1], vpd[2], aspect);\n    return publicAPI.projectionToNormalizedDisplay(vpd[0], vpd[1], vpd[2]);\n  };\n\n  // requires the aspect ratio of the viewport as X/Y\n  publicAPI.viewToWorld = (x, y, z) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0');\n      return [0, 0, 0];\n    }\n\n    // get the view matrix from the active camera\n    const matrix = model.activeCamera.getViewMatrix();\n    mat4.invert(matrix, matrix);\n    mat4.transpose(matrix, matrix);\n\n    // Transform point to world coordinates\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n  publicAPI.projectionToView = (x, y, z, aspect) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0');\n      return [0, 0, 0];\n    }\n\n    // get the projection transformation from the active camera\n    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);\n    mat4.invert(matrix, matrix);\n    mat4.transpose(matrix, matrix);\n\n    // Transform point to world coordinates\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n\n  // Convert world point coordinates to view coordinates.\n  publicAPI.worldToView = (x, y, z) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('WorldToView: no active camera, cannot compute view to world, returning 0,0,0');\n      return [0, 0, 0];\n    }\n\n    // get the view transformation from the active camera\n    const matrix = model.activeCamera.getViewMatrix();\n    mat4.transpose(matrix, matrix);\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n\n  // Convert world point coordinates to view coordinates.\n  // requires the aspect ratio of the viewport as X/Y\n  publicAPI.viewToProjection = (x, y, z, aspect) => {\n    if (model.activeCamera === null) {\n      vtkErrorMacro('ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0');\n      return [0, 0, 0];\n    }\n\n    // get the projeciton transformation from the active camera\n    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);\n    mat4.transpose(matrix, matrix);\n    const result = new Float64Array([x, y, z]);\n    vec3.transformMat4(result, result, matrix);\n    return result;\n  };\n  publicAPI.computeVisiblePropBounds = () => {\n    model.allBounds[0] = vtkBoundingBox.INIT_BOUNDS[0];\n    model.allBounds[1] = vtkBoundingBox.INIT_BOUNDS[1];\n    model.allBounds[2] = vtkBoundingBox.INIT_BOUNDS[2];\n    model.allBounds[3] = vtkBoundingBox.INIT_BOUNDS[3];\n    model.allBounds[4] = vtkBoundingBox.INIT_BOUNDS[4];\n    model.allBounds[5] = vtkBoundingBox.INIT_BOUNDS[5];\n    let nothingVisible = true;\n    publicAPI.invokeEvent(COMPUTE_VISIBLE_PROP_BOUNDS_EVENT);\n\n    // loop through all props\n    for (let index = 0; index < model.props.length; ++index) {\n      const prop = model.props[index];\n      if (prop.getVisibility() && prop.getUseBounds()) {\n        const bounds = prop.getBounds();\n        if (bounds && areBoundsInitialized(bounds)) {\n          nothingVisible = false;\n          if (bounds[0] < model.allBounds[0]) {\n            model.allBounds[0] = bounds[0];\n          }\n          if (bounds[1] > model.allBounds[1]) {\n            model.allBounds[1] = bounds[1];\n          }\n          if (bounds[2] < model.allBounds[2]) {\n            model.allBounds[2] = bounds[2];\n          }\n          if (bounds[3] > model.allBounds[3]) {\n            model.allBounds[3] = bounds[3];\n          }\n          if (bounds[4] < model.allBounds[4]) {\n            model.allBounds[4] = bounds[4];\n          }\n          if (bounds[5] > model.allBounds[5]) {\n            model.allBounds[5] = bounds[5];\n          }\n        }\n      }\n    }\n    if (nothingVisible) {\n      uninitializeBounds(model.allBounds);\n      vtkDebugMacro(\"Can't compute bounds, no 3D props are visible\");\n    }\n    return model.allBounds;\n  };\n  publicAPI.resetCamera = function () {\n    let bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();\n    const center = [0, 0, 0];\n    if (!areBoundsInitialized(boundsToUse)) {\n      vtkDebugMacro('Cannot reset camera!');\n      return false;\n    }\n    let vn = null;\n    if (publicAPI.getActiveCamera()) {\n      vn = model.activeCamera.getViewPlaneNormal();\n    } else {\n      vtkErrorMacro('Trying to reset non-existent camera');\n      return false;\n    }\n\n    // Reset the perspective zoom factors, otherwise subsequent zooms will cause\n    // the view angle to become very small and cause bad depth sorting.\n    model.activeCamera.setViewAngle(30.0);\n    center[0] = (boundsToUse[0] + boundsToUse[1]) / 2.0;\n    center[1] = (boundsToUse[2] + boundsToUse[3]) / 2.0;\n    center[2] = (boundsToUse[4] + boundsToUse[5]) / 2.0;\n    let w1 = boundsToUse[1] - boundsToUse[0];\n    let w2 = boundsToUse[3] - boundsToUse[2];\n    let w3 = boundsToUse[5] - boundsToUse[4];\n    w1 *= w1;\n    w2 *= w2;\n    w3 *= w3;\n    let radius = w1 + w2 + w3;\n\n    // If we have just a single point, pick a radius of 1.0\n    radius = radius === 0 ? 1.0 : radius;\n\n    // compute the radius of the enclosing sphere\n    radius = Math.sqrt(radius) * 0.5;\n\n    // default so that the bounding sphere fits within the view fustrum\n\n    // compute the distance from the intersection of the view frustum with the\n    // bounding sphere. Basically in 2D draw a circle representing the bounding\n    // sphere in 2D then draw a horizontal line going out from the center of\n    // the circle. That is the camera view. Then draw a line from the camera\n    // position to the point where it intersects the circle. (it will be tangent\n    // to the circle at this point, this is important, only go to the tangent\n    // point, do not draw all the way to the view plane). Then draw the radius\n    // from the tangent point to the center of the circle. You will note that\n    // this forms a right triangle with one side being the radius, another being\n    // the target distance for the camera, then just find the target dist using\n    // a sin.\n    const angle = radiansFromDegrees(model.activeCamera.getViewAngle());\n    const parallelScale = radius;\n    const distance = radius / Math.sin(angle * 0.5);\n\n    // check view-up vector against view plane normal\n    const vup = model.activeCamera.getViewUp();\n    if (Math.abs(dot(vup, vn)) > 0.999) {\n      vtkWarningMacro('Resetting view-up since view plane normal is parallel');\n      model.activeCamera.setViewUp(-vup[2], vup[0], vup[1]);\n    }\n\n    // update the camera\n    model.activeCamera.setFocalPoint(center[0], center[1], center[2]);\n    model.activeCamera.setPosition(center[0] + distance * vn[0], center[1] + distance * vn[1], center[2] + distance * vn[2]);\n    publicAPI.resetCameraClippingRange(boundsToUse);\n\n    // setup default parallel scale\n    model.activeCamera.setParallelScale(parallelScale);\n\n    // update reasonable world to physical values\n    model.activeCamera.setPhysicalScale(radius);\n    model.activeCamera.setPhysicalTranslation(-center[0], -center[1], -center[2]);\n\n    // Here to let parallel/distributed compositing intercept\n    // and do the right thing.\n    publicAPI.invokeEvent(RESET_CAMERA_EVENT);\n    return true;\n  };\n  publicAPI.resetCameraClippingRange = function () {\n    let bounds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();\n    if (!areBoundsInitialized(boundsToUse)) {\n      vtkDebugMacro('Cannot reset camera clipping range!');\n      return false;\n    }\n\n    // Make sure we have an active camera\n    publicAPI.getActiveCameraAndResetIfCreated();\n    if (!model.activeCamera) {\n      vtkErrorMacro('Trying to reset clipping range of non-existent camera');\n      return false;\n    }\n\n    // Get the exact range for the bounds\n    const range = model.activeCamera.computeClippingRange(boundsToUse);\n\n    // do not let far - near be less than 0.1 of the window height\n    // this is for cases such as 2D images which may have zero range\n    let minGap = 0.0;\n    if (model.activeCamera.getParallelProjection()) {\n      minGap = 0.2 * model.activeCamera.getParallelScale();\n    } else {\n      const angle = radiansFromDegrees(model.activeCamera.getViewAngle());\n      minGap = 0.2 * Math.tan(angle / 2.0) * range[1];\n    }\n    if (range[1] - range[0] < minGap) {\n      minGap = minGap - range[1] + range[0];\n      range[1] += minGap / 2.0;\n      range[0] -= minGap / 2.0;\n    }\n\n    // Do not let the range behind the camera throw off the calculation.\n    if (range[0] < 0.0) {\n      range[0] = 0.0;\n    }\n\n    // Give ourselves a little breathing room\n    range[0] = 0.99 * range[0] - (range[1] - range[0]) * model.clippingRangeExpansion;\n    range[1] = 1.01 * range[1] + (range[1] - range[0]) * model.clippingRangeExpansion;\n\n    // Make sure near is not bigger than far\n    range[0] = range[0] >= range[1] ? 0.01 * range[1] : range[0];\n\n    // Make sure near is at least some fraction of far - this prevents near\n    // from being behind the camera or too close in front. How close is too\n    // close depends on the resolution of the depth buffer\n    if (!model.nearClippingPlaneTolerance) {\n      model.nearClippingPlaneTolerance = 0.01;\n    }\n\n    // make sure the front clipping range is not too far from the far clippnig\n    // range, this is to make sure that the zbuffer resolution is effectively\n    // used\n    if (range[0] < model.nearClippingPlaneTolerance * range[1]) {\n      range[0] = model.nearClippingPlaneTolerance * range[1];\n    }\n    model.activeCamera.setClippingRange(range[0], range[1]);\n\n    // Here to let parallel/distributed compositing intercept\n    // and do the right thing.\n    publicAPI.invokeEvent(RESET_CAMERA_CLIPPING_RANGE_EVENT);\n    return false;\n  };\n  publicAPI.setRenderWindow = renderWindow => {\n    if (renderWindow !== model._renderWindow) {\n      model._vtkWindow = renderWindow;\n      model._renderWindow = renderWindow;\n    }\n  };\n  publicAPI.visibleActorCount = () => model.props.filter(prop => prop.getVisibility()).length;\n  publicAPI.visibleVolumeCount = publicAPI.visibleActorCount;\n  publicAPI.getMTime = () => {\n    let m1 = model.mtime;\n    const m2 = model.activeCamera ? model.activeCamera.getMTime() : 0;\n    if (m2 > m1) {\n      m1 = m2;\n    }\n    const m3 = model._createdLight ? model._createdLight.getMTime() : 0;\n    if (m3 > m1) {\n      m1 = m3;\n    }\n    return m1;\n  };\n  publicAPI.getTransparent = () => !!model.preserveColorBuffer;\n  publicAPI.isActiveCameraCreated = () => !!model.activeCamera;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  pickedProp: null,\n  activeCamera: null,\n  allBounds: [],\n  ambient: [1, 1, 1],\n  allocatedRenderTime: 100,\n  timeFactor: 1,\n  automaticLightCreation: true,\n  twoSidedLighting: true,\n  lastRenderTimeInSeconds: -1,\n  renderWindow: null,\n  lights: [],\n  actors: [],\n  volumes: [],\n  lightFollowCamera: true,\n  numberOfPropsRendered: 0,\n  propArray: null,\n  pathArray: null,\n  layer: 0,\n  preserveColorBuffer: false,\n  preserveDepthBuffer: false,\n  computeVisiblePropBounds: createUninitializedBounds(),\n  interactive: true,\n  nearClippingPlaneTolerance: 0,\n  clippingRangeExpansion: 0.05,\n  erase: true,\n  draw: true,\n  useShadows: false,\n  useDepthPeeling: false,\n  occlusionRatio: 0,\n  maximumNumberOfPeels: 4,\n  selector: null,\n  delegate: null,\n  texturedBackground: false,\n  backgroundTexture: null,\n  environmentTexture: null,\n  environmentTextureDiffuseStrength: 1,\n  environmentTextureSpecularStrength: 1,\n  useEnvironmentTextureAsBackground: false,\n  pass: 0\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewport.extend(publicAPI, model, initialValues);\n\n  // make sure background has 4 entries. Default to opaque black\n  if (!model.background) model.background = [0, 0, 0, 1];\n  while (model.background.length < 3) model.background.push(0);\n  if (model.background.length === 3) model.background.push(1);\n\n  // Build VTK API\n  get(publicAPI, model, ['_renderWindow', 'allocatedRenderTime', 'timeFactor', 'lastRenderTimeInSeconds', 'numberOfPropsRendered', 'lastRenderingUsedDepthPeeling', 'selector']);\n  setGet(publicAPI, model, ['twoSidedLighting', 'lightFollowCamera', 'automaticLightCreation', 'erase', 'draw', 'nearClippingPlaneTolerance', 'clippingRangeExpansion', 'backingStore', 'interactive', 'layer', 'preserveColorBuffer', 'preserveDepthBuffer', 'useDepthPeeling', 'occlusionRatio', 'maximumNumberOfPeels', 'delegate', 'backgroundTexture', 'texturedBackground', 'environmentTexture', 'environmentTextureDiffuseStrength', 'environmentTextureSpecularStrength', 'useEnvironmentTextureAsBackground', 'useShadows', 'pass']);\n  getArray(publicAPI, model, ['actors', 'volumes', 'lights']);\n  setGetArray(publicAPI, model, ['background'], 4, 1.0);\n  moveToProtected(publicAPI, model, ['renderWindow']);\n\n  // Object methods\n  vtkRenderer(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkRenderer');\n\n// ----------------------------------------------------------------------------\n\nvar vtkRenderer$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkRenderer$1 as default, extend, newInstance };\n"],
  "mappings": "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",
  "names": ["newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "vtkDebugMacro", "vtkErrorMacro", "notImplemented", "DEFAULT_VALUES", "extend", "newInstance"]
}

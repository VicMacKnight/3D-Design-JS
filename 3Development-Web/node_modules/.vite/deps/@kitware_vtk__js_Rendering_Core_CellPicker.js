import {
  CellType,
  vtkCell$1,
  vtkCellTypes$1,
  vtkLine$1,
  vtkPoints$1,
  vtkTriangle$1
} from "./chunk-4D44TFRT.js";
import {
  vtkBoundingBox
} from "./chunk-OR5FAYKF.js";
import "./chunk-MIWBGA5F.js";
import {
  vtkImplicitFunction$1
} from "./chunk-PPHUOPMK.js";
import {
  mat4_exports,
  vec3_exports,
  vec4_exports
} from "./chunk-OX3JD63S.js";
import {
  distance2BetweenPoints,
  dot,
  normalize,
  subtract
} from "./chunk-TIDT2POU.js";
import {
  macro
} from "./chunk-RF5CWC6R.js";

// node_modules/@kitware/vtk.js/Rendering/Core/AbstractPicker.js
function vtkAbstractPicker(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractPicker");
  publicAPI.initialize = () => {
    model.renderer = null;
    model.selectionPoint[0] = 0;
    model.selectionPoint[1] = 0;
    model.selectionPoint[2] = 0;
    model.pickPosition[0] = 0;
    model.pickPosition[1] = 0;
    model.pickPosition[2] = 0;
  };
  publicAPI.initializePickList = () => {
    model.pickList = [];
  };
  publicAPI.addPickList = (actor) => {
    model.pickList.push(actor);
  };
  publicAPI.deletePickList = (actor) => {
    const i = model.pickList.indexOf(actor);
    if (i !== -1) {
      model.pickList.splice(i, 1);
    }
  };
}
var DEFAULT_VALUES = {
  renderer: null,
  selectionPoint: [0, 0, 0],
  pickPosition: [0, 0, 0],
  pickFromList: false,
  pickList: []
};
function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["renderer"]);
  macro.getArray(publicAPI, model, ["selectionPoint", "pickPosition"]);
  macro.setGet(publicAPI, model, ["pickFromList", "pickList"]);
  vtkAbstractPicker(publicAPI, model);
}
var newInstance = macro.newInstance(extend, "vtkAbstractPicker");
var vtkAbstractPicker$1 = {
  newInstance,
  extend
};

// node_modules/@kitware/vtk.js/Rendering/Core/Picker.js
var {
  vtkErrorMacro
} = macro;
var {
  vtkWarningMacro
} = macro;
function vtkPicker(publicAPI, model) {
  model.classHierarchy.push("vtkPicker");
  const superClass = {
    ...publicAPI
  };
  function initialize() {
    superClass.initialize();
    model.actors = [];
    model.pickedPositions = [];
    model.mapperPosition[0] = 0;
    model.mapperPosition[1] = 0;
    model.mapperPosition[2] = 0;
    model.mapper = null;
    model.dataSet = null;
    model.globalTMin = Number.MAX_VALUE;
  }
  function computeTolerance(selectionZ, aspect, renderer) {
    let tolerance = 0;
    const view = renderer.getRenderWindow().getViews()[0];
    const viewport = renderer.getViewport();
    const winSize = view.getSize();
    let x = winSize[0] * viewport[0];
    let y = winSize[1] * viewport[1];
    const normalizedLeftDisplay = view.displayToNormalizedDisplay(x, y, selectionZ);
    const windowLowerLeft = renderer.normalizedDisplayToWorld(normalizedLeftDisplay[0], normalizedLeftDisplay[1], normalizedLeftDisplay[2], aspect);
    x = winSize[0] * viewport[2];
    y = winSize[1] * viewport[3];
    const normalizedRightDisplay = view.displayToNormalizedDisplay(x, y, selectionZ);
    const windowUpperRight = renderer.normalizedDisplayToWorld(normalizedRightDisplay[0], normalizedRightDisplay[1], normalizedRightDisplay[2], aspect);
    for (let i = 0; i < 3; i++) {
      tolerance += (windowUpperRight[i] - windowLowerLeft[i]) * (windowUpperRight[i] - windowLowerLeft[i]);
    }
    return Math.sqrt(tolerance);
  }
  function pick3DInternal(renderer, tolerance, p1World, p2World) {
    const p1Mapper = new Float64Array(4);
    const p2Mapper = new Float64Array(4);
    const ray = [];
    const hitPosition = [];
    const props = model.pickFromList ? model.pickList : renderer.getActors();
    const transformScale = new Float64Array(3);
    const pickedPosition = new Float64Array(3);
    props.forEach((prop) => {
      var _a, _b, _c;
      const mapper = prop.getMapper();
      const propIsFullyTranslucent = ((_c = (_a = prop.getProperty) == null ? void 0 : (_b = _a.call(prop)).getOpacity) == null ? void 0 : _c.call(_b)) === 0;
      const pickable = prop.getNestedPickable() && prop.getNestedVisibility() && !propIsFullyTranslucent;
      if (!pickable) {
        return;
      }
      model.transformMatrix = prop.getMatrix().slice(0);
      mat4_exports.transpose(model.transformMatrix, model.transformMatrix);
      mat4_exports.invert(model.transformMatrix, model.transformMatrix);
      vec4_exports.transformMat4(p1Mapper, p1World, model.transformMatrix);
      vec4_exports.transformMat4(p2Mapper, p2World, model.transformMatrix);
      vec3_exports.scale(p1Mapper, p1Mapper, 1 / p1Mapper[3]);
      vec3_exports.scale(p2Mapper, p2Mapper, 1 / p2Mapper[3]);
      subtract(p2Mapper, p1Mapper, ray);
      const bounds = mapper ? vtkBoundingBox.inflate(mapper.getBounds(), tolerance) : [...vtkBoundingBox.INIT_BOUNDS];
      if (vtkBoundingBox.intersectBox(bounds, p1Mapper, ray, hitPosition, [])) {
        mat4_exports.getScaling(transformScale, model.transformMatrix);
        const t = model.intersectWithLine(p1Mapper, p2Mapper, tolerance * 0.333 * (transformScale[0] + transformScale[1] + transformScale[2]), prop, mapper);
        if (t < Number.MAX_VALUE) {
          pickedPosition[0] = (1 - t) * p1World[0] + t * p2World[0];
          pickedPosition[1] = (1 - t) * p1World[1] + t * p2World[1];
          pickedPosition[2] = (1 - t) * p1World[2] + t * p2World[2];
          const actorIndex = model.actors.indexOf(prop);
          if (actorIndex !== -1) {
            const previousPickedPosition = model.pickedPositions[actorIndex];
            if (distance2BetweenPoints(p1World, pickedPosition) < distance2BetweenPoints(p1World, previousPickedPosition)) {
              model.pickedPositions[actorIndex] = pickedPosition.slice(0);
            }
          } else {
            model.actors.push(prop);
            model.pickedPositions.push(pickedPosition.slice(0));
          }
        }
      }
    });
    const tempArray = [];
    for (let i = 0; i < model.pickedPositions.length; i++) {
      tempArray.push({
        actor: model.actors[i],
        pickedPosition: model.pickedPositions[i],
        distance2: distance2BetweenPoints(p1World, model.pickedPositions[i])
      });
    }
    tempArray.sort((a, b) => {
      const keyA = a.distance2;
      const keyB = b.distance2;
      if (keyA < keyB) return -1;
      if (keyA > keyB) return 1;
      return 0;
    });
    model.pickedPositions = [];
    model.actors = [];
    tempArray.forEach((obj) => {
      model.pickedPositions.push(obj.pickedPosition);
      model.actors.push(obj.actor);
    });
  }
  model.intersectWithLine = (p1, p2, tolerance, prop, mapper) => {
    if (!mapper) {
      return Number.MAX_VALUE;
    }
    const center = mapper.getCenter();
    const ray = vec3_exports.subtract(new Float64Array(3), p2, p1);
    const rayFactor = dot(ray, ray);
    if (rayFactor === 0) {
      return 2;
    }
    const t = (ray[0] * (center[0] - p1[0]) + ray[1] * (center[1] - p1[1]) + ray[2] * (center[2] - p1[2])) / rayFactor;
    return t;
  };
  publicAPI.pick = (selection, renderer) => {
    if (selection.length !== 3) {
      vtkWarningMacro("vtkPicker.pick - selection needs three components");
    }
    if (!renderer) {
      vtkErrorMacro("vtkPicker.pick - renderer cannot be null");
      throw new Error("renderer cannot be null");
    }
    initialize();
    const selectionX = selection[0];
    const selectionY = selection[1];
    let selectionZ = selection[2];
    model.renderer = renderer;
    model.selectionPoint[0] = selectionX;
    model.selectionPoint[1] = selectionY;
    model.selectionPoint[2] = selectionZ;
    const p1World = new Float64Array(4);
    const p2World = new Float64Array(4);
    const camera = renderer.getActiveCamera();
    const cameraPos = camera.getPosition();
    const cameraFP = camera.getFocalPoint();
    const view = renderer.getRenderWindow().getViews()[0];
    const dims = view.getViewportSize(renderer);
    if (dims[1] === 0) {
      vtkWarningMacro("vtkPicker.pick - viewport area is 0");
      return;
    }
    const aspect = dims[0] / dims[1];
    let displayCoords = [];
    displayCoords = renderer.worldToNormalizedDisplay(cameraFP[0], cameraFP[1], cameraFP[2], aspect);
    displayCoords = view.normalizedDisplayToDisplay(displayCoords[0], displayCoords[1], displayCoords[2]);
    selectionZ = displayCoords[2];
    const normalizedDisplay = view.displayToNormalizedDisplay(selectionX, selectionY, selectionZ);
    const worldCoords = renderer.normalizedDisplayToWorld(normalizedDisplay[0], normalizedDisplay[1], normalizedDisplay[2], aspect);
    for (let i = 0; i < 3; i++) {
      model.pickPosition[i] = worldCoords[i];
    }
    const ray = [];
    for (let i = 0; i < 3; i++) {
      ray[i] = model.pickPosition[i] - cameraPos[i];
    }
    const cameraDOP = [];
    for (let i = 0; i < 3; i++) {
      cameraDOP[i] = cameraFP[i] - cameraPos[i];
    }
    normalize(cameraDOP);
    const rayLength = dot(cameraDOP, ray);
    if (rayLength === 0) {
      vtkWarningMacro("Picker::Pick Cannot process points");
      return;
    }
    const clipRange = camera.getClippingRange();
    let tF;
    let tB;
    if (camera.getParallelProjection()) {
      tF = clipRange[0] - rayLength;
      tB = clipRange[1] - rayLength;
      for (let i = 0; i < 3; i++) {
        p1World[i] = model.pickPosition[i] + tF * cameraDOP[i];
        p2World[i] = model.pickPosition[i] + tB * cameraDOP[i];
      }
    } else {
      tF = clipRange[0] / rayLength;
      tB = clipRange[1] / rayLength;
      for (let i = 0; i < 3; i++) {
        p1World[i] = cameraPos[i] + tF * ray[i];
        p2World[i] = cameraPos[i] + tB * ray[i];
      }
    }
    p1World[3] = 1;
    p2World[3] = 1;
    const tolerance = computeTolerance(selectionZ, aspect, renderer) * model.tolerance;
    pick3DInternal(model.renderer, tolerance, p1World, p2World);
  };
  publicAPI.pick3DPoint = (selectionPoint, focalPoint, renderer) => {
    if (!renderer) {
      throw new Error("renderer cannot be null");
    }
    initialize();
    model.renderer = renderer;
    vec3_exports.copy(model.selectionPoint, selectionPoint);
    const view = renderer.getRenderWindow().getViews()[0];
    const dims = view.getViewportSize(renderer);
    if (dims[1] === 0) {
      vtkWarningMacro("vtkPicker.pick3DPoint - viewport area is 0");
      return;
    }
    const aspect = dims[0] / dims[1];
    const tolerance = computeTolerance(model.selectionPoint[2], aspect, renderer) * model.tolerance;
    pick3DInternal(renderer, tolerance, selectionPoint, focalPoint);
  };
}
var DEFAULT_VALUES2 = {
  tolerance: 0.025,
  mapperPosition: [0, 0, 0],
  mapper: null,
  dataSet: null,
  actors: [],
  pickedPositions: [],
  transformMatrix: null,
  globalTMin: Number.MAX_VALUE
};
function extend2(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  vtkAbstractPicker$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["tolerance"]);
  macro.setGetArray(publicAPI, model, ["mapperPosition"], 3);
  macro.get(publicAPI, model, ["mapper", "dataSet", "actors", "pickedPositions"]);
  macro.event(publicAPI, model, "pickChange");
  vtkPicker(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend2, "vtkPicker");
var vtkPicker$1 = {
  newInstance: newInstance2,
  extend: extend2
};

// node_modules/@kitware/vtk.js/Common/DataModel/PolyLine.js
function vtkPolyLine(publicAPI, model) {
  model.classHierarchy.push("vtkPolyLine");
  const line = vtkLine$1.newInstance();
  line.getPoints().setNumberOfPoints(2);
  publicAPI.getCellDimension = () => 1;
  publicAPI.intersectWithLine = (t1, t2, p1, p2, tol, x, pcoords) => {
    const outObj = {
      intersect: 0,
      t: Number.MAX_VALUE,
      subId: 0,
      betweenPoints: null
    };
    const numLines = publicAPI.getNumberOfPoints() - 1;
    let pDistMin = Number.MAX_VALUE;
    for (let subId = 0; subId < numLines; subId++) {
      const pCoords = [0, 0, 0];
      line.getPoints().getData().set(model.points.getData().subarray(3 * subId, 3 * (subId + 2)));
      const lineIntersected = line.intersectWithLine(p1, p2, tol, x, pcoords);
      if (lineIntersected.intersect === 1 && lineIntersected.t <= outObj.t + tol && lineIntersected.t >= t1 && lineIntersected.t <= t2) {
        outObj.intersect = 1;
        const pDist = line.getParametricDistance(pCoords);
        if (pDist < pDistMin || pDist === pDistMin && lineIntersected.t < outObj.t) {
          outObj.subId = subId;
          outObj.t = lineIntersected.t;
          pDistMin = pDist;
          for (let k = 0; k < 3; k++) {
            x[k];
            pCoords[k];
          }
        }
      }
    }
    return outObj;
  };
  publicAPI.evaluateLocation = (subId, pcoords, x, weights) => {
    line.getPoints().getData().set(model.points.getData().subarray(3 * subId, 3 * (subId + 2)));
    return line.evaluateLocation(pcoords, x, weights);
  };
  publicAPI.evaluateOrientation = (subId, pcoords, q, weights) => {
    if (model.orientations) {
      line.setOrientations([model.orientations[subId], model.orientations[subId + 1]]);
    } else {
      line.setOrientations(null);
    }
    return line.evaluateOrientation(pcoords, q, weights);
  };
  publicAPI.getDistancesToFirstPoint = () => {
    const dTime = model.distancesTime.getMTime();
    if (dTime < model.points.getMTime() || dTime < publicAPI.getMTime()) {
      const numPoints = publicAPI.getNumberOfPoints();
      if (!model.distances) {
        model.distances = new Array(numPoints);
      } else {
        model.distances.length = numPoints;
      }
      if (numPoints > 0) {
        const previousPoint = new Array(3);
        const currentPoint = new Array(3);
        let totalDistance = 0;
        model.distances[0] = totalDistance;
        model.points.getPoint(0, previousPoint);
        for (let i = 1; i < numPoints; ++i) {
          model.points.getPoint(i, currentPoint);
          totalDistance += model.distanceFunction(previousPoint, currentPoint);
          model.distances[i] = totalDistance;
          vec3_exports.copy(previousPoint, currentPoint);
        }
      }
      model.distancesTime.modified();
    }
    return model.distances;
  };
  publicAPI.findPointIdAtDistanceFromFirstPoint = (distance) => {
    const distances = publicAPI.getDistancesToFirstPoint();
    if (distances.length < 2) {
      return -1;
    }
    let minId = 0;
    let maxId = distances.length - 1;
    if (distance < distances[minId] || distance > distances[maxId] || distances[maxId] === 0) {
      return -1;
    }
    while (maxId - minId > 1) {
      const midId = Math.floor((minId + maxId) / 2);
      if (distances[midId] <= distance) {
        minId = midId;
      } else {
        maxId = midId;
      }
    }
    return minId;
  };
}
var DEFAULT_VALUES3 = {
  orientations: null,
  // an array of quat or null
  distanceFunction: vec3_exports.dist
};
function extend3(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["orientations", "distanceFunction"]);
  model.distancesTime = {};
  macro.obj(model.distancesTime, {
    mtime: 0
  });
  vtkPolyLine(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend3, "vtkPolyLine");
var vtkPolyLine$1 = {
  newInstance: newInstance3,
  extend: extend3
};

// node_modules/@kitware/vtk.js/Common/DataModel/Quad.js
function intersectionStruct() {
  return {
    intersected: false,
    subId: -1,
    x: [0, 0, 0],
    pCoords: [0, 0, 0],
    t: -1
  };
}
function vtkQuad(publicAPI, model) {
  model.classHierarchy.push("vtkQuad");
  publicAPI.getCellDimension = () => 2;
  publicAPI.getCellType = () => CellType.VTK_QUAD;
  publicAPI.getNumberOfEdges = () => 4;
  publicAPI.getNumberOfFaces = () => 0;
  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
    let outObj = {
      subId: 0,
      t: Number.MAX_VALUE,
      intersect: 0,
      betweenPoints: false
    };
    let diagonalCase;
    const point0 = model.points.getPoint(0, []);
    const point1 = model.points.getPoint(1, []);
    const point2 = model.points.getPoint(2, []);
    const point3 = model.points.getPoint(3, []);
    const d1 = distance2BetweenPoints(point0, point2);
    const d2 = distance2BetweenPoints(point1, point3);
    if (d1 === d2) {
      let id;
      let maxId = 0;
      let maxIdx = 0;
      for (let i = 0; i < 4; i++) {
        id = model.pointsIds[i];
        if (id > maxId) {
          maxId = id;
          maxIdx = i;
        }
      }
      if (maxIdx === 0 || maxIdx === 2) {
        diagonalCase = 0;
      } else {
        diagonalCase = 1;
      }
    } else if (d1 < d2) {
      diagonalCase = 0;
    } else {
      diagonalCase = 1;
    }
    let points = null;
    if (!model.triangle) {
      model.triangle = vtkTriangle$1.newInstance();
      points = vtkPoints$1.newInstance();
      points.setNumberOfPoints(3);
      model.triangle.initialize(points);
    } else {
      points = model.triangle.getPoints();
    }
    let firstIntersect;
    const firstIntersectTmpObj = intersectionStruct();
    let secondIntersect;
    const secondIntersectTmpObj = intersectionStruct();
    let useFirstIntersection;
    let useSecondIntersection;
    switch (diagonalCase) {
      case 0:
        points.setPoint(0, ...point0);
        points.setPoint(1, ...point1);
        points.setPoint(2, ...point2);
        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);
        points.setPoint(0, ...point2);
        points.setPoint(1, ...point3);
        points.setPoint(2, ...point0);
        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);
        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;
        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;
        if (useFirstIntersection) {
          outObj = firstIntersect;
          x[0] = firstIntersectTmpObj.x[0];
          x[1] = firstIntersectTmpObj.x[1];
          x[2] = firstIntersectTmpObj.x[2];
          pcoords[0] = firstIntersectTmpObj.pCoords[0] + firstIntersectTmpObj.pCoords[1];
          pcoords[1] = firstIntersectTmpObj.pCoords[1];
          pcoords[2] = firstIntersectTmpObj.pCoords[2];
        } else if (useSecondIntersection) {
          outObj = secondIntersect;
          x[0] = secondIntersectTmpObj.x[0];
          x[1] = secondIntersectTmpObj.x[1];
          x[2] = secondIntersectTmpObj.x[2];
          pcoords[0] = 1 - (secondIntersectTmpObj.pCoords[0] + secondIntersectTmpObj.pCoords[1]);
          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];
          pcoords[2] = secondIntersectTmpObj.pCoords[2];
        }
        break;
      case 1:
        points.setPoint(0, ...point0);
        points.setPoint(1, ...point1);
        points.setPoint(2, ...point3);
        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);
        points.setPoint(0, ...point2);
        points.setPoint(1, ...point3);
        points.setPoint(2, ...point1);
        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);
        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;
        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;
        if (useFirstIntersection) {
          outObj = firstIntersect;
          x[0] = firstIntersectTmpObj.x[0];
          x[1] = firstIntersectTmpObj.x[1];
          x[2] = firstIntersectTmpObj.x[2];
          pcoords[0] = firstIntersectTmpObj.pCoords[0];
          pcoords[1] = firstIntersectTmpObj.pCoords[1];
          pcoords[2] = firstIntersectTmpObj.pCoords[2];
        } else if (useSecondIntersection) {
          outObj = secondIntersect;
          x[0] = secondIntersectTmpObj.x[0];
          x[1] = secondIntersectTmpObj.x[1];
          x[2] = secondIntersectTmpObj.x[2];
          pcoords[0] = 1 - secondIntersectTmpObj.pCoords[0];
          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];
          pcoords[2] = secondIntersectTmpObj.pCoords[2];
        }
        break;
    }
    return outObj;
  };
  publicAPI.interpolationFunctions = (pcoords, weights) => {
    const rm = 1 - pcoords[0];
    const sm = 1 - pcoords[1];
    weights[0] = rm * sm;
    weights[1] = pcoords[0] * sm;
    weights[2] = pcoords[0] * pcoords[1];
    weights[3] = rm * pcoords[1];
  };
  publicAPI.evaluateLocation = (pcoords, x, weights) => {
    const point = [];
    publicAPI.interpolationFunctions(pcoords, weights);
    x[0] = 0;
    x[1] = 0;
    x[2] = 0;
    for (let i = 0; i < 4; i++) {
      model.points.getPoint(i, point);
      for (let j = 0; j < 3; j++) {
        x[j] += point[j] * weights[i];
      }
    }
  };
}
var DEFAULT_VALUES4 = {};
function extend4(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES4, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  vtkQuad(publicAPI, model);
}
var newInstance4 = macro.newInstance(extend4, "vtkQuad");
var vtkQuad$1 = {
  newInstance: newInstance4,
  extend: extend4
};

// node_modules/@kitware/vtk.js/Common/DataModel/Box.js
function intersectWithLine(bounds, p1, p2) {
  let plane1 = -1;
  let plane2 = -1;
  let t1 = 0;
  let t2 = 1;
  for (let j = 0; j < 3; j++) {
    for (let k = 0; k < 2; k++) {
      const i = 2 * j + k;
      const d1 = (bounds[i] - p1[j]) * (1 - 2 * k);
      const d2 = (bounds[i] - p2[j]) * (1 - 2 * k);
      if (d1 > 0 && d2 > 0) {
        return;
      }
      if (d1 > 0 || d2 > 0) {
        let t = 0;
        if (d1 !== 0) {
          t = d1 / (d1 - d2);
        }
        if (d1 > 0) {
          if (t >= t1) {
            t1 = t;
            plane1 = i;
          }
        } else if (t <= t2) {
          t2 = t;
          plane2 = i;
        }
        if (t1 > t2) {
          if (plane1 < 0 || plane2 < 0) {
            return;
          }
        }
      }
    }
  }
  function getValues(plane, t) {
    const x = [0, 0, 0];
    for (let count = 0; count < 2; count++) {
      for (let i = 0; i < 3; i++) {
        if (plane === 2 * i || plane === 2 * i + 1) {
          x[i] = bounds[plane];
        } else {
          x[i] = p1[i] * (1 - t) + p2[i] * t;
          if (x[i] < bounds[2 * i]) {
            x[i] = bounds[2 * i];
          }
          if (x[i] > bounds[2 * i + 1]) {
            x[i] = bounds[2 * i + 1];
          }
        }
      }
    }
    return x;
  }
  const x1 = getValues(plane1, t1);
  const x2 = getValues(plane2, t2);
  const outObject = {
    t1,
    t2,
    x1,
    x2
  };
  return outObject;
}
var STATIC = {};
function vtkBox(publicAPI, model) {
  model.classHierarchy.push("vtkBox");
  publicAPI.setBounds = function() {
    let boundsArray = [];
    for (var _len = arguments.length, bounds = new Array(_len), _key = 0; _key < _len; _key++) {
      bounds[_key] = arguments[_key];
    }
    if (Array.isArray(bounds[0])) {
      boundsArray = bounds[0];
    } else {
      for (let i = 0; i < bounds.length; i++) {
        boundsArray.push(bounds[i]);
      }
    }
    if (boundsArray.length !== 6) {
      console.log("vtkBox.setBounds", boundsArray, bounds);
      return;
    }
    vtkBoundingBox.setBounds(model.bbox, boundsArray);
  };
  publicAPI.getBounds = () => model.bbox;
  publicAPI.evaluateFunction = (x, y, z) => {
    const point = Array.isArray(x) ? x : [x, y, z];
    let diff;
    let dist;
    let t;
    let minDistance = -Number.MAX_VALUE;
    let distance = 0;
    const minPoint = vtkBoundingBox.getMinPoint(model.bbox);
    const maxPoint = vtkBoundingBox.getMaxPoint(model.bbox);
    let inside = 1;
    for (let i = 0; i < 3; i++) {
      diff = vtkBoundingBox.getLength(model.bbox, i);
      if (diff !== 0) {
        t = (point[i] - minPoint[i]) / diff;
        if (t < 0) {
          inside = 0;
          dist = minPoint[i] - point[i];
        } else if (t > 1) {
          inside = 0;
          dist = point[i] - maxPoint[i];
        } else {
          if (t <= 0.5) {
            dist = minPoint[i] - point[i];
          } else {
            dist = point[i] - maxPoint[i];
          }
          if (dist > minDistance) {
            minDistance = dist;
          }
        }
      } else {
        dist = Math.abs(point[i] - minPoint[i]);
        if (dist > 0) {
          inside = 0;
        }
      }
      if (dist > 0) {
        distance += dist * dist;
      }
    }
    distance = Math.sqrt(distance);
    if (inside) {
      return minDistance;
    }
    return distance;
  };
  publicAPI.addBounds = function() {
    let boundsArray = [];
    if (Array.isArray(arguments.length <= 0 ? void 0 : arguments[0])) {
      boundsArray = arguments.length <= 0 ? void 0 : arguments[0];
    } else {
      for (let i = 0; i < arguments.length; i++) {
        boundsArray.push(i < 0 || arguments.length <= i ? void 0 : arguments[i]);
      }
    }
    if (boundsArray.length !== 6) {
      return;
    }
    vtkBoundingBox.addBounds(model.bbox, ...boundsArray);
    publicAPI.modified();
  };
  publicAPI.addBox = (other) => publicAPI.addBounds(other.getBounds());
  publicAPI.intersectWithLine = (p1, p2) => intersectWithLine(model.bbox, p1, p2);
}
var DEFAULT_VALUES5 = {
  bbox: [...vtkBoundingBox.INIT_BOUNDS]
};
function extend5(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES5, initialValues);
  vtkImplicitFunction$1.extend(publicAPI, model, initialValues);
  vtkBox(publicAPI, model);
}
var newInstance5 = macro.newInstance(extend5, "vtkBox");
var vtkBox$1 = {
  newInstance: newInstance5,
  extend: extend5,
  intersectWithLine,
  ...STATIC
};

// node_modules/@kitware/vtk.js/Rendering/Core/CellPicker.js
function createCellMap() {
  return {
    [CellType.VTK_LINE]: vtkLine$1.newInstance(),
    [CellType.VTK_POLY_LINE]: vtkPolyLine$1.newInstance(),
    [CellType.VTK_TRIANGLE]: vtkTriangle$1.newInstance(),
    [CellType.VTK_QUAD]: vtkQuad$1.newInstance()
  };
}
function clipLineWithPlane(mapper, matrix, p1, p2) {
  const outObj = {
    planeId: -1,
    t1: 0,
    t2: 1,
    intersect: 0
  };
  const nbClippingPlanes = mapper.getNumberOfClippingPlanes();
  const plane = [];
  for (let i = 0; i < nbClippingPlanes; i++) {
    mapper.getClippingPlaneInDataCoords(matrix, i, plane);
    const d1 = plane[0] * p1[0] + plane[1] * p1[1] + plane[2] * p1[2] + plane[3];
    const d2 = plane[0] * p2[0] + plane[1] * p2[1] + plane[2] * p2[2] + plane[3];
    if (d1 < 0 && d2 < 0) {
      return 0;
    }
    if (d1 < 0 || d2 < 0) {
      let t = 0;
      if (d1 !== 0) {
        t = d1 / (d1 - d2);
      }
      if (d1 < 0) {
        if (t >= outObj.t1) {
          outObj.t1 = t;
          outObj.planeId = i;
        }
      } else if (t <= outObj.t2) {
        outObj.t2 = t;
      }
      if (outObj.t1 > outObj.t2) {
        outObj.intersect = 0;
        return outObj;
      }
    }
  }
  outObj.intersect = 1;
  return outObj;
}
var STATIC2 = {
  clipLineWithPlane
};
function vtkCellPicker(publicAPI, model) {
  model.classHierarchy.push("vtkCellPicker");
  const superClass = {
    ...publicAPI
  };
  function resetCellPickerInfo() {
    model.cellId = -1;
    model.pCoords[0] = 0;
    model.pCoords[1] = 0;
    model.pCoords[2] = 0;
    model.cellIJK[0] = 0;
    model.cellIJK[1] = 0;
    model.cellIJK[2] = 0;
    model.mapperNormal[0] = 0;
    model.mapperNormal[1] = 0;
    model.mapperNormal[2] = 1;
    model.pickNormal[0] = 0;
    model.pickNormal[1] = 0;
    model.pickNormal[2] = 1;
  }
  function resetPickInfo() {
    model.dataSet = null;
    model.mapper = null;
    resetCellPickerInfo();
  }
  publicAPI.initialize = () => {
    resetPickInfo();
    superClass.initialize();
  };
  publicAPI.computeSurfaceNormal = (data, cell, weights, normal) => {
    const normals = data.getPointData().getNormals();
    if (normals) {
      normal[0] = 0;
      normal[1] = 0;
      normal[2] = 0;
      const pointNormal = [];
      for (let i = 0; i < 3; i++) {
        normals.getTuple(cell.getPointsIds()[i], pointNormal);
        normal[0] += pointNormal[0] * weights[i];
        normal[1] += pointNormal[1] * weights[i];
        normal[2] += pointNormal[2] * weights[i];
      }
      normalize(normal);
    } else {
      return 0;
    }
    return 1;
  };
  publicAPI.pick = (selection, renderer) => {
    publicAPI.initialize();
    const pickResult = superClass.pick(selection, renderer);
    if (pickResult) {
      const camera = renderer.getActiveCamera();
      const cameraPos = [];
      camera.getPosition(cameraPos);
      if (camera.getParallelProjection()) {
        const cameraFocus = [];
        camera.getFocalPoint(cameraFocus);
        model.pickNormal[0] = cameraPos[0] - cameraFocus[0];
        model.pickNormal[1] = cameraPos[1] - cameraFocus[1];
        model.pickNormal[2] = cameraPos[2] - cameraFocus[2];
      } else {
        model.pickNormal[0] = cameraPos[0] - model.pickPosition[0];
        model.pickNormal[1] = cameraPos[1] - model.pickPosition[1];
        model.pickNormal[2] = cameraPos[2] - model.pickPosition[2];
      }
      normalize(model.pickNormal);
    }
    return pickResult;
  };
  model.intersectWithLine = (p1, p2, tolerance, prop, mapper) => {
    let tMin = Number.MAX_VALUE;
    let t1 = 0;
    let t2 = 1;
    const vtkCellPickerPlaneTol = 1e-14;
    const clipLine = clipLineWithPlane(mapper, model.transformMatrix, p1, p2);
    if (mapper && !clipLine.intersect) {
      return Number.MAX_VALUE;
    }
    if (mapper.isA("vtkImageMapper") || mapper.isA("vtkImageArrayMapper")) {
      const pickData = mapper.intersectWithLineForCellPicking(p1, p2);
      if (pickData) {
        tMin = pickData.t;
        model.cellIJK = pickData.ijk;
        model.pCoords = pickData.pCoords;
      }
    } else if (mapper.isA("vtkVolumeMapper")) {
      const interceptionObject = vtkBox$1.intersectWithLine(mapper.getBounds(), p1, p2);
      t1 = (interceptionObject == null ? void 0 : interceptionObject.t1) > clipLine.t1 ? interceptionObject.t1 : clipLine.t1;
      t2 = (interceptionObject == null ? void 0 : interceptionObject.t2) < clipLine.t2 ? interceptionObject.t2 : clipLine.t2;
      tMin = model.intersectVolumeWithLine(p1, p2, t1, t2, tolerance, prop);
    } else if (mapper.isA("vtkMapper")) {
      tMin = model.intersectActorWithLine(p1, p2, t1, t2, tolerance, mapper);
    }
    if (tMin < model.globalTMin) {
      model.globalTMin = tMin;
      if (Math.abs(tMin - t1) < vtkCellPickerPlaneTol && clipLine.clippingPlaneId >= 0) {
        model.mapperPosition[0] = p1[0] * (1 - t1) + p2[0] * t1;
        model.mapperPosition[1] = p1[1] * (1 - t1) + p2[1] * t1;
        model.mapperPosition[2] = p1[2] * (1 - t1) + p2[2] * t1;
        const plane = [];
        mapper.getClippingPlaneInDataCoords(model.transformMatrix, clipLine.clippingPlaneId, plane);
        normalize(plane);
        model.mapperNormal[0] = -plane[0];
        model.mapperNormal[1] = -plane[1];
        model.mapperNormal[2] = -plane[2];
      }
      vec3_exports.transformMat4(model.pickPosition, model.mapperPosition, model.transformMatrix);
      const mat = model.transformMatrix;
      model.mapperNormal[0] = mat[0] * model.pickNormal[0] + mat[4] * model.pickNormal[1] + mat[8] * model.pickNormal[2];
      model.mapperNormal[1] = mat[1] * model.pickNormal[0] + mat[5] * model.pickNormal[1] + mat[9] * model.pickNormal[2];
      model.mapperNormal[2] = mat[2] * model.pickNormal[0] + mat[6] * model.pickNormal[1] + mat[10] * model.pickNormal[2];
    }
    return tMin;
  };
  model.intersectVolumeWithLine = (p1, p2, t1, t2, tolerance, volume) => {
    let tMin = Number.MAX_VALUE;
    const mapper = volume.getMapper();
    const imageData = mapper.getInputData();
    const dims = imageData.getDimensions();
    const scalars = imageData.getPointData().getScalars().getData();
    const extent = imageData.getExtent();
    const imageTransform = imageData.getWorldToIndex();
    const numIComps = 1;
    let oWidth = mapper.getOpacityTextureWidth();
    if (oWidth <= 0) {
      oWidth = 1024;
    }
    const tmpTable = new Float32Array(oWidth);
    const opacityArray = new Float32Array(oWidth);
    let ofun;
    let oRange;
    const sampleDist = volume.getMapper().getSampleDistance();
    for (let c = 0; c < numIComps; ++c) {
      ofun = volume.getProperty().getScalarOpacity(c);
      oRange = ofun.getRange();
      ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);
      const opacityFactor = sampleDist / volume.getProperty().getScalarOpacityUnitDistance(c);
      for (let i = 0; i < oWidth; ++i) {
        opacityArray[i] = 1 - (1 - tmpTable[i]) ** opacityFactor;
      }
    }
    const scale = oWidth / (oRange[1] - oRange[0] + 1);
    const q1 = [0, 0, 0, 1];
    const q2 = [0, 0, 0, 1];
    q1[0] = p1[0];
    q1[1] = p1[1];
    q1[2] = p1[2];
    q2[0] = p2[0];
    q2[1] = p2[1];
    q2[2] = p2[2];
    if (t1 !== 0 || t2 !== 1) {
      for (let j = 0; j < 3; j++) {
        q1[j] = p1[j] * (1 - t1) + p2[j] * t1;
        q2[j] = p1[j] * (1 - t2) + p2[j] * t2;
      }
    }
    const x1 = [0, 0, 0, 0];
    const x2 = [0, 0, 0, 0];
    vec4_exports.transformMat4(x1, q1, imageTransform);
    vec4_exports.transformMat4(x2, q2, imageTransform);
    const x = [0, 0, 0];
    const xi = [0, 0, 0];
    const sliceSize = dims[1] * dims[0];
    const rowSize = dims[0];
    const step = 1 / Math.sqrt(distance2BetweenPoints(x1, x2));
    let insideVolume;
    for (let t = 0; t < 1; t += step) {
      insideVolume = true;
      for (let j = 0; j < 3; j++) {
        x[j] = x1[j] * (1 - t) + x2[j] * t;
      }
      for (let j = 0; j < 3; j++) {
        if (x[j] < extent[2 * j]) {
          x[j] = extent[2 * j];
          insideVolume = false;
        } else if (x[j] > extent[2 * j + 1]) {
          x[j] = extent[2 * j + 1];
          insideVolume = false;
        }
        xi[j] = Math.round(x[j]);
      }
      if (insideVolume) {
        const index = xi[2] * sliceSize + xi[1] * rowSize + xi[0];
        let value = scalars[index];
        if (value < oRange[0]) {
          value = oRange[0];
        } else if (value > oRange[1]) {
          value = oRange[1];
        }
        value = Math.floor((value - oRange[0]) * scale);
        const opacity = tmpTable[value];
        if (opacity > model.opacityThreshold) {
          tMin = t1 * (1 - t) + t2 * t;
          break;
        }
      }
    }
    return tMin;
  };
  model.intersectActorWithLine = (p1, p2, t1, t2, tolerance, mapper) => {
    let tMin = Number.MAX_VALUE;
    const minXYZ = [0, 0, 0];
    let pDistMin = Number.MAX_VALUE;
    const minPCoords = [0, 0, 0];
    let minCellId = null;
    let minCell = null;
    let minCellType = null;
    let subId = null;
    const x = [];
    const data = mapper.getInputData();
    const q1 = [0, 0, 0];
    const q2 = [0, 0, 0];
    q1[0] = p1[0];
    q1[1] = p1[1];
    q1[2] = p1[2];
    q2[0] = p2[0];
    q2[1] = p2[1];
    q2[2] = p2[2];
    if (t1 !== 0 || t2 !== 1) {
      for (let j = 0; j < 3; j++) {
        q1[j] = p1[j] * (1 - t1) + p2[j] * t1;
        q2[j] = p1[j] * (1 - t2) + p2[j] * t2;
      }
    }
    if (data.getCells) {
      if (!data.getCells()) {
        data.buildLinks();
      }
      const tempCellMap = createCellMap();
      const minCellMap = createCellMap();
      const numberOfCells = data.getNumberOfCells();
      for (let cellId = 0; cellId < numberOfCells; cellId++) {
        const pCoords = [0, 0, 0];
        minCellType = data.getCellType(cellId);
        if (minCellType === CellType.VTK_EMPTY_CELL) {
          continue;
        }
        const cell = tempCellMap[minCellType];
        if (cell == null) {
          continue;
        }
        minCell = minCellMap[minCellType];
        data.getCell(cellId, cell);
        let cellPicked;
        {
          if (vtkCellTypes$1.hasSubCells(minCellType)) {
            cellPicked = cell.intersectWithLine(t1, t2, p1, p2, tolerance, x, pCoords);
          } else {
            cellPicked = cell.intersectWithLine(p1, p2, tolerance, x, pCoords);
          }
        }
        if (cellPicked.intersect === 1 && cellPicked.t <= tMin + model.tolerance && cellPicked.t >= t1 && cellPicked.t <= t2) {
          const pDist = cell.getParametricDistance(pCoords);
          if (pDist < pDistMin || pDist === pDistMin && cellPicked.t < tMin) {
            tMin = cellPicked.t;
            pDistMin = pDist;
            subId = cellPicked.subId;
            minCellId = cellId;
            cell.deepCopy(minCell);
            for (let k = 0; k < 3; k++) {
              minXYZ[k] = x[k];
              minPCoords[k] = pCoords[k];
            }
          }
        }
      }
    }
    if (minCellId >= 0 && tMin < model.globalTMin) {
      resetPickInfo();
      const nbPointsInCell = minCell.getNumberOfPoints();
      const weights = new Array(nbPointsInCell);
      for (let i = 0; i < nbPointsInCell; i++) {
        weights[i] = 0;
      }
      const point = [];
      if (vtkCellTypes$1.hasSubCells(minCellType)) {
        minCell.evaluateLocation(subId, minPCoords, point, weights);
      } else {
        minCell.evaluateLocation(minPCoords, point, weights);
      }
      model.dataSet = data;
      model.cellId = minCellId;
      model.pCoords[0] = minPCoords[0];
      model.pCoords[1] = minPCoords[1];
      model.pCoords[2] = minPCoords[2];
      let maxWeight = 0;
      let iMaxWeight = -1;
      for (let i = 0; i < nbPointsInCell; i++) {
        if (weights[i] > maxWeight) {
          iMaxWeight = i;
          maxWeight = weights[i];
        }
      }
      if (iMaxWeight !== -1) {
        model.pointId = minCell.getPointsIds()[iMaxWeight];
      }
      model.mapperPosition[0] = minXYZ[0];
      model.mapperPosition[1] = minXYZ[1];
      model.mapperPosition[2] = minXYZ[2];
      if (!publicAPI.computeSurfaceNormal(data, minCell, weights, model.mapperNormal)) {
        model.mapperNormal[0] = p1[0] - p2[0];
        model.mapperNormal[1] = p1[1] - p2[1];
        model.mapperNormal[2] = p1[2] - p2[2];
        normalize(model.mapperNormal);
      }
    }
    return tMin;
  };
}
var DEFAULT_VALUES6 = {
  cellId: -1,
  pCoords: [],
  cellIJK: [],
  pickNormal: [],
  mapperNormal: [],
  opacityThreshold: 0.2
};
function extend6(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES6, initialValues);
  vtkPicker$1.extend(publicAPI, model, initialValues);
  macro.getArray(publicAPI, model, ["pickNormal", "mapperNormal", "pCoords", "cellIJK"]);
  macro.setGet(publicAPI, model, ["opacityThreshold"]);
  macro.get(publicAPI, model, ["cellId"]);
  vtkCellPicker(publicAPI, model);
}
var newInstance6 = macro.newInstance(extend6, "vtkCellPicker");
var vtkCellPicker$1 = {
  newInstance: newInstance6,
  extend: extend6,
  ...STATIC2
};
export {
  STATIC2 as STATIC,
  vtkCellPicker$1 as default,
  extend6 as extend,
  newInstance6 as newInstance
};
//# sourceMappingURL=@kitware_vtk__js_Rendering_Core_CellPicker.js.map

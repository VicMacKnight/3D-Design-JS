import {
  CellType,
  vtkCell$1,
  vtkCellTypes$1,
  vtkLine$1,
  vtkPoints$1,
  vtkTriangle$1
} from "./chunk-4D44TFRT.js";
import {
  vtkDataSet$1
} from "./chunk-CEGBQTJE.js";
import {
  VtkDataTypes,
  vtkDataArray$1
} from "./chunk-MIWBGA5F.js";
import {
  macro,
  vtk
} from "./chunk-RF5CWC6R.js";

// node_modules/@kitware/vtk.js/Common/Core/CellArray.js
function extractCellSizes(cellArray) {
  let currentIdx = 0;
  return cellArray.filter((value, index) => {
    if (index === currentIdx) {
      currentIdx += value + 1;
      return true;
    }
    return false;
  });
}
function getNumberOfCells(cellArray) {
  let cellId = 0;
  for (let cellArrayIndex = 0; cellArrayIndex < cellArray.length; ) {
    cellArrayIndex += cellArray[cellArrayIndex] + 1;
    cellId++;
  }
  return cellId;
}
var STATIC = {
  extractCellSizes,
  getNumberOfCells
};
function vtkCellArray(publicAPI, model) {
  model.classHierarchy.push("vtkCellArray");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getNumberOfCells = (recompute) => {
    if (model.numberOfCells !== void 0 && !recompute) {
      return model.numberOfCells;
    }
    if (model.cellSizes) {
      model.numberOfCells = model.cellSizes.length;
    } else {
      model.numberOfCells = getNumberOfCells(publicAPI.getData());
    }
    return model.numberOfCells;
  };
  publicAPI.getCellSizes = (recompute) => {
    if (model.cellSizes !== void 0 && !recompute) {
      return model.cellSizes;
    }
    model.cellSizes = extractCellSizes(publicAPI.getData());
    return model.cellSizes;
  };
  publicAPI.resize = (requestedNumTuples) => {
    const oldNumTuples = publicAPI.getNumberOfTuples();
    superClass.resize(requestedNumTuples);
    const newNumTuples = publicAPI.getNumberOfTuples();
    if (newNumTuples < oldNumTuples) {
      if (newNumTuples === 0) {
        model.numberOfCells = 0;
        model.cellSizes = [];
      } else {
        model.numberOfCells = void 0;
        model.cellSizes = void 0;
      }
    }
  };
  publicAPI.setData = (typedArray) => {
    superClass.setData(typedArray, 1);
    model.numberOfCells = void 0;
    model.cellSizes = void 0;
  };
  publicAPI.getCell = (loc) => {
    let cellLoc = loc;
    const numberOfPoints = model.values[cellLoc++];
    return model.values.subarray(cellLoc, cellLoc + numberOfPoints);
  };
  publicAPI.insertNextCell = (cellPointIds) => {
    const cellId = publicAPI.getNumberOfCells();
    publicAPI.insertNextTuples([cellPointIds.length, ...cellPointIds]);
    ++model.numberOfCells;
    if (model.cellSizes != null) {
      model.cellSizes.push(cellPointIds.length);
    }
    return cellId;
  };
}
function defaultValues(initialValues) {
  return {
    empty: true,
    numberOfComponents: 1,
    dataType: VtkDataTypes.UNSIGNED_INT,
    ...initialValues
  };
}
function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkDataArray$1.extend(publicAPI, model, defaultValues(initialValues));
  vtkCellArray(publicAPI, model);
}
var newInstance = macro.newInstance(extend, "vtkCellArray");
var vtkCellArray$1 = {
  newInstance,
  extend,
  ...STATIC
};

// node_modules/@kitware/vtk.js/Common/DataModel/CellLinks.js
function resize(model, sz) {
  let newSize = sz;
  if (sz >= model.array.length) {
    newSize += model.array.length;
  }
  while (newSize > model.array.length) model.array.push({
    ncells: 0,
    cells: null
  });
  model.array.length = newSize;
}
function vtkCellLinks(publicAPI, model) {
  model.classHierarchy.push("vtkCellLinks");
  publicAPI.buildLinks = (data) => {
    const numPts = data.getPoints().getNumberOfPoints();
    const numCells = data.getNumberOfCells();
    const linkLoc = new Uint32Array(numPts);
    if (data.isA("vtkPolyData")) {
      for (let cellId = 0; cellId < numCells; ++cellId) {
        const {
          cellPointIds
        } = data.getCellPoints(cellId);
        cellPointIds.forEach((cellPointId) => {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;
      for (let cellId = 0; cellId < numCells; ++cellId) {
        const {
          cellPointIds
        } = data.getCellPoints(cellId);
        cellPointIds.forEach((cellPointId) => {
          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);
        });
      }
    } else {
      for (let cellId = 0; cellId < numCells; cellId++) {
        const cell = vtkCell$1.newInstance();
        cell.getPointsIds().forEach((cellPointId) => {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;
      for (let cellId = 0; cellId < numCells; ++cellId) {
        const cell = vtkCell$1.newInstance();
        cell.getPointsIds().forEach((cellPointId) => {
          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);
        });
      }
    }
  };
  publicAPI.allocate = function(numLinks) {
    let ext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
    model.array = Array(numLinks).fill().map(() => ({
      ncells: 0,
      cells: null
    }));
    model.extend = ext;
    model.maxId = -1;
  };
  publicAPI.initialize = () => {
    model.array = null;
  };
  publicAPI.getLink = (ptId) => model.array[ptId];
  publicAPI.getNcells = (ptId) => model.array[ptId].ncells;
  publicAPI.getCells = (ptId) => model.array[ptId].cells;
  publicAPI.insertNextPoint = (numLinks) => {
    model.array.push({
      ncells: numLinks,
      cells: Array(numLinks)
    });
    ++model.maxId;
  };
  publicAPI.insertNextCellReference = (ptId, cellId) => {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };
  publicAPI.deletePoint = (ptId) => {
    model.array[ptId].ncells = 0;
    model.array[ptId].cells = null;
  };
  publicAPI.removeCellReference = (cellId, ptId) => {
    model.array[ptId].cells = model.array[ptId].cells.filter((cell) => cell !== cellId);
    model.array[ptId].ncells = model.array[ptId].cells.length;
  };
  publicAPI.addCellReference = (cellId, ptId) => {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };
  publicAPI.resizeCellList = (ptId, size) => {
    model.array[ptId].cells.length = size;
  };
  publicAPI.squeeze = () => {
    resize(model, model.maxId + 1);
  };
  publicAPI.reset = () => {
    model.maxId = -1;
  };
  publicAPI.deepCopy = (src) => {
    model.array = [...src.array];
    model.extend = src.extend;
    model.maxId = src.maxId;
  };
  publicAPI.incrementLinkCount = (ptId) => {
    ++model.array[ptId].ncells;
  };
  publicAPI.allocateLinks = (n) => {
    for (let i = 0; i < n; ++i) {
      model.array[i].cells = new Array(model.array[i].ncells);
    }
  };
  publicAPI.insertCellReference = (ptId, pos, cellId) => {
    model.array[ptId].cells[pos] = cellId;
  };
}
var DEFAULT_VALUES = {
  array: null,
  // pointer to data
  maxId: 0,
  // maximum index inserted thus far
  extend: 0
  // grow array by this point
};
function extend2(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  vtkCellLinks(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend2, "vtkCellLinks");
var vtkCellLinks$1 = {
  newInstance: newInstance2,
  extend: extend2
};

// node_modules/@kitware/vtk.js/Common/DataModel/PointSet.js
function vtkPointSet(publicAPI, model) {
  model.classHierarchy.push("vtkPointSet");
  if (!model.points) {
    model.points = vtkPoints$1.newInstance();
  } else {
    model.points = vtk(model.points);
  }
  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();
  publicAPI.getBounds = () => model.points.getBounds();
  publicAPI.computeBounds = () => {
    publicAPI.getBounds();
  };
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    let debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    superShallowCopy(other, debug);
    model.points = vtkPoints$1.newInstance();
    model.points.shallowCopy(other.getPoints());
  };
}
var DEFAULT_VALUES2 = {
  // points: null,
};
function extend3(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  vtkDataSet$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["points"]);
  vtkPointSet(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend3, "vtkPointSet");
var vtkPointSet$1 = {
  newInstance: newInstance3,
  extend: extend3
};

// node_modules/@kitware/vtk.js/Common/DataModel/PolyData/Constants.js
var POLYDATA_FIELDS = ["verts", "lines", "polys", "strips"];

// node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js
var {
  vtkWarningMacro
} = macro;
var CELL_FACTORY = {
  [CellType.VTK_LINE]: vtkLine$1,
  [CellType.VTK_POLY_LINE]: vtkLine$1,
  [CellType.VTK_TRIANGLE]: vtkTriangle$1
};
function vtkPolyData(publicAPI, model) {
  model.classHierarchy.push("vtkPolyData");
  function camelize(str) {
    return str.replace(/(?:^\w|[A-Z]|\b\w)/g, (letter) => letter.toUpperCase()).replace(/\s+/g, "");
  }
  POLYDATA_FIELDS.forEach((type) => {
    publicAPI[`getNumberOf${camelize(type)}`] = () => model[type].getNumberOfCells();
    if (!model[type]) {
      model[type] = vtkCellArray$1.newInstance();
    } else {
      model[type] = vtk(model[type]);
    }
  });
  publicAPI.getNumberOfCells = () => POLYDATA_FIELDS.reduce((num, cellType) => num + model[cellType].getNumberOfCells(), 0);
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    let debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    superShallowCopy(other, debug);
    POLYDATA_FIELDS.forEach((type) => {
      model[type] = vtkCellArray$1.newInstance();
      model[type].shallowCopy(other.getReferenceByName(type));
    });
  };
  publicAPI.buildCells = () => {
    const nVerts = publicAPI.getNumberOfVerts();
    const nLines = publicAPI.getNumberOfLines();
    const nPolys = publicAPI.getNumberOfPolys();
    const nStrips = publicAPI.getNumberOfStrips();
    const nCells = nVerts + nLines + nPolys + nStrips;
    const types = new Uint8Array(nCells);
    let pTypes = types;
    const locs = new Uint32Array(nCells);
    let pLocs = locs;
    if (nVerts) {
      let nextCellPts = 0;
      model.verts.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        pTypes[index] = numCellPts > 1 ? CellType.VTK_POLY_VERTEX : CellType.VTK_VERTEX;
        nextCellPts += numCellPts + 1;
      });
      pLocs = pLocs.subarray(nVerts);
      pTypes = pTypes.subarray(nVerts);
    }
    if (nLines) {
      let nextCellPts = 0;
      model.lines.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        pTypes[index] = numCellPts > 2 ? CellType.VTK_POLY_LINE : CellType.VTK_LINE;
        if (numCellPts === 1) {
          vtkWarningMacro("Building VTK_LINE ", index, " with only one point, but VTK_LINE needs at least two points. Check the input.");
        }
        nextCellPts += numCellPts + 1;
      });
      pLocs = pLocs.subarray(nLines);
      pTypes = pTypes.subarray(nLines);
    }
    if (nPolys) {
      let nextCellPts = 0;
      model.polys.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        switch (numCellPts) {
          case 3:
            pTypes[index] = CellType.VTK_TRIANGLE;
            break;
          case 4:
            pTypes[index] = CellType.VTK_QUAD;
            break;
          default:
            pTypes[index] = CellType.VTK_POLYGON;
            break;
        }
        if (numCellPts < 3) {
          vtkWarningMacro("Building VTK_TRIANGLE ", index, " with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.");
        }
        nextCellPts += numCellPts + 1;
      });
      pLocs += pLocs.subarray(nPolys);
      pTypes += pTypes.subarray(nPolys);
    }
    if (nStrips) {
      let nextCellPts = 0;
      pTypes.fill(CellType.VTK_TRIANGLE_STRIP, 0, nStrips);
      model.strips.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        nextCellPts += numCellPts + 1;
      });
    }
    model.cells = vtkCellTypes$1.newInstance();
    model.cells.setCellTypes(nCells, types, locs);
  };
  publicAPI.buildLinks = function() {
    let initialSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (model.cells === void 0) {
      publicAPI.buildCells();
    }
    model.links = vtkCellLinks$1.newInstance();
    if (initialSize > 0) {
      model.links.allocate(initialSize);
    } else {
      model.links.allocate(publicAPI.getPoints().getNumberOfPoints());
    }
    model.links.buildLinks(publicAPI);
  };
  publicAPI.getCellType = (cellId) => model.cells.getCellType(cellId);
  publicAPI.getCellPoints = (cellId) => {
    const cellType = publicAPI.getCellType(cellId);
    let cells = null;
    switch (cellType) {
      case CellType.VTK_VERTEX:
      case CellType.VTK_POLY_VERTEX:
        cells = model.verts;
        break;
      case CellType.VTK_LINE:
      case CellType.VTK_POLY_LINE:
        cells = model.lines;
        break;
      case CellType.VTK_TRIANGLE:
      case CellType.VTK_QUAD:
      case CellType.VTK_POLYGON:
        cells = model.polys;
        break;
      case CellType.VTK_TRIANGLE_STRIP:
        cells = model.strips;
        break;
      default:
        cells = null;
        return {
          type: 0,
          cellPointIds: null
        };
    }
    const loc = model.cells.getCellLocation(cellId);
    const cellPointIds = cells.getCell(loc);
    return {
      cellType,
      cellPointIds
    };
  };
  publicAPI.getPointCells = (ptId) => model.links.getCells(ptId);
  publicAPI.getCellEdgeNeighbors = (cellId, point1, point2) => {
    const link1 = model.links.getLink(point1);
    const link2 = model.links.getLink(point2);
    return link1.cells.filter((cell) => cell !== cellId && link2.cells.indexOf(cell) !== -1);
  };
  publicAPI.getCell = function(cellId) {
    let cellHint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const cellInfo = publicAPI.getCellPoints(cellId);
    const cell = cellHint || CELL_FACTORY[cellInfo.cellType].newInstance();
    cell.initialize(publicAPI.getPoints(), cellInfo.cellPointIds);
    return cell;
  };
}
var DEFAULT_VALUES3 = {
  // verts: null,
  // lines: null,
  // polys: null,
  // strips: null,
  // cells: null,
  // links: null,
};
function extend4(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  vtkPointSet$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["cells", "links"]);
  macro.setGet(publicAPI, model, ["verts", "lines", "polys", "strips"]);
  vtkPolyData(publicAPI, model);
}
var newInstance4 = macro.newInstance(extend4, "vtkPolyData");
var vtkPolyData$1 = {
  newInstance: newInstance4,
  extend: extend4
};

export {
  vtkPolyData$1
};
//# sourceMappingURL=chunk-ASK2H7AW.js.map

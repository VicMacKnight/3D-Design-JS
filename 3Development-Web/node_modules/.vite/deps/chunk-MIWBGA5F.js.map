{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Common/Core/DataArray/Constants.js", "../../@kitware/vtk.js/Common/Core/DataArray.js"],
  "sourcesContent": ["const DataTypeByteSize = {\n  Int8Array: 1,\n  Uint8Array: 1,\n  Uint8ClampedArray: 1,\n  Int16Array: 2,\n  Uint16Array: 2,\n  Int32Array: 4,\n  Uint32Array: 4,\n  Float32Array: 4,\n  Float64Array: 8\n};\nconst VtkDataTypes = {\n  VOID: '',\n  // not sure to know what that should be\n  CHAR: 'Int8Array',\n  SIGNED_CHAR: 'Int8Array',\n  UNSIGNED_CHAR: 'Uint8Array',\n  UNSIGNED_CHAR_CLAMPED: 'Uint8ClampedArray',\n  // should be used for VTK.js internal purpose only\n  SHORT: 'Int16Array',\n  UNSIGNED_SHORT: 'Uint16Array',\n  INT: 'Int32Array',\n  UNSIGNED_INT: 'Uint32Array',\n  FLOAT: 'Float32Array',\n  DOUBLE: 'Float64Array'\n};\nconst DefaultDataType = VtkDataTypes.FLOAT;\nvar Constants = {\n  DefaultDataType,\n  DataTypeByteSize,\n  VtkDataTypes\n};\n\nexport { DataTypeByteSize, DefaultDataType, VtkDataTypes, Constants as default };\n", "import Constants from './DataArray/Constants.js';\nimport { n as newInstance$1, a as newTypedArray, b as newTypedArrayFrom, o as obj, s as set, c as macro } from '../../macros2.js';\nimport { n as norm } from './Math/index.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nconst {\n  DefaultDataType\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\nconst EPSILON = 1e-6;\n\n// Original source from https://www.npmjs.com/package/compute-range\n// Modified to accept type arrays\nfunction fastComputeRange(arr, offset, numberOfComponents) {\n  const len = arr.length;\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let x;\n  let i;\n\n  // find first non-NaN value\n  for (i = offset; i < len; i += numberOfComponents) {\n    if (!Number.isNaN(arr[i])) {\n      min = arr[i];\n      max = min;\n      break;\n    }\n  }\n  for (; i < len; i += numberOfComponents) {\n    x = arr[i];\n    if (x < min) {\n      min = x;\n    } else if (x > max) {\n      max = x;\n    }\n  }\n  return {\n    min,\n    max\n  };\n}\n\n/**\n * @deprecated please use fastComputeRange instead\n */\nfunction createRangeHelper() {\n  let min = Number.MAX_VALUE;\n  let max = -Number.MAX_VALUE;\n  let count = 0;\n  let sum = 0;\n  return {\n    add(value) {\n      if (min > value) {\n        min = value;\n      }\n      if (max < value) {\n        max = value;\n      }\n      count++;\n      sum += value;\n    },\n    get() {\n      return {\n        min,\n        max,\n        count,\n        sum,\n        mean: sum / count\n      };\n    },\n    getRange() {\n      return {\n        min,\n        max\n      };\n    }\n  };\n}\nfunction computeRange(values) {\n  let component = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let numberOfComponents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (component < 0 && numberOfComponents > 1) {\n    // Compute magnitude\n    const size = values.length;\n    const numberOfValues = size / numberOfComponents;\n    const data = new Float64Array(numberOfValues);\n    for (let i = 0, j = 0; i < numberOfValues; ++i) {\n      for (let nextJ = j + numberOfComponents; j < nextJ; ++j) {\n        data[i] += values[j] * values[j];\n      }\n      data[i] **= 0.5;\n    }\n    return fastComputeRange(data, 0, 1);\n  }\n  return fastComputeRange(values, component < 0 ? 0 : component, numberOfComponents);\n}\nfunction ensureRangeSize(rangeArray) {\n  let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  const ranges = rangeArray || [];\n  // Pad ranges with null value to get the\n  while (ranges.length <= size) {\n    ranges.push(null);\n  }\n  return ranges;\n}\nfunction getDataType(typedArray) {\n  // Expects toString() to return \"[object ...Array]\"\n  return Object.prototype.toString.call(typedArray).slice(8, -1);\n}\nfunction getMaxNorm(normArray) {\n  const numComps = normArray.getNumberOfComponents();\n  let maxNorm = 0.0;\n  const tuple = new Array(numComps);\n  for (let i = 0; i < normArray.getNumberOfTuples(); ++i) {\n    normArray.getTuple(i, tuple);\n    const norm$1 = norm(tuple, numComps);\n    if (norm$1 > maxNorm) {\n      maxNorm = norm$1;\n    }\n  }\n  return maxNorm;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  computeRange,\n  createRangeHelper,\n  fastComputeRange,\n  getDataType,\n  getMaxNorm\n};\n\n// ----------------------------------------------------------------------------\n// vtkDataArray methods\n// ----------------------------------------------------------------------------\n\nfunction vtkDataArray(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkDataArray');\n\n  /**\n   * Resize model.values and copy the old values to the new array.\n   * @param {Number} requestedNumTuples Final expected number of tuples; must be >= 0\n   * @returns {Boolean} True if a resize occured, false otherwise\n   */\n  function resize(requestedNumTuples) {\n    if (requestedNumTuples < 0) {\n      return false;\n    }\n    const numComps = publicAPI.getNumberOfComponents();\n    const curNumTuples = model.values.length / (numComps > 0 ? numComps : 1);\n    if (requestedNumTuples === curNumTuples) {\n      return true;\n    }\n    if (requestedNumTuples > curNumTuples) {\n      // Requested size is bigger than current size.  Allocate enough\n      // memory to fit the requested size and be more than double the\n      // currently allocated memory.\n      const oldValues = model.values;\n      model.values = newTypedArray(model.dataType, (requestedNumTuples + curNumTuples) * numComps);\n      model.values.set(oldValues);\n      return true;\n    }\n\n    // Requested size is smaller than currently allocated size\n    if (model.size > requestedNumTuples * numComps) {\n      model.size = requestedNumTuples * numComps;\n      publicAPI.dataChange();\n    }\n    return true;\n  }\n  publicAPI.dataChange = () => {\n    model.ranges = null;\n    publicAPI.modified();\n  };\n  publicAPI.resize = requestedNumTuples => {\n    resize(requestedNumTuples);\n    const newSize = requestedNumTuples * publicAPI.getNumberOfComponents();\n    if (model.size !== newSize) {\n      model.size = newSize;\n      publicAPI.dataChange();\n      return true;\n    }\n    return false;\n  };\n\n  // FIXME, to rename into \"clear()\" or \"reset()\"\n  publicAPI.initialize = () => {\n    publicAPI.resize(0);\n  };\n  publicAPI.getElementComponentSize = () => model.values.BYTES_PER_ELEMENT;\n\n  // Description:\n  // Return the data component at the location specified by tupleIdx and\n  // compIdx.\n  publicAPI.getComponent = function (tupleIdx) {\n    let compIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return model.values[tupleIdx * model.numberOfComponents + compIdx];\n  };\n\n  // Description:\n  // Set the data component at the location specified by tupleIdx and compIdx\n  // to value.\n  // Note that i is less than NumberOfTuples and j is less than\n  //  NumberOfComponents. Make sure enough memory has been allocated\n  // (use SetNumberOfTuples() and SetNumberOfComponents()).\n  publicAPI.setComponent = (tupleIdx, compIdx, value) => {\n    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {\n      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;\n      publicAPI.dataChange();\n    }\n  };\n  publicAPI.getValue = valueIdx => {\n    const idx = valueIdx / model.numberOfComponents;\n    const comp = valueIdx % model.numberOfComponents;\n    return publicAPI.getComponent(idx, comp);\n  };\n  publicAPI.setValue = (valueIdx, value) => {\n    const idx = valueIdx / model.numberOfComponents;\n    const comp = valueIdx % model.numberOfComponents;\n    publicAPI.setComponent(idx, comp, value);\n  };\n  publicAPI.getData = () => model.size === model.values.length ? model.values : model.values.subarray(0, model.size);\n  publicAPI.getRange = function () {\n    let componentIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n    let rangeIdx = componentIndex;\n    if (rangeIdx < 0) {\n      // If scalar data, then store in slot 0 (same as componentIndex = 0).\n      // If vector data, then store in last slot.\n      rangeIdx = model.numberOfComponents === 1 ? 0 : model.numberOfComponents;\n    }\n    let range = null;\n    if (!model.ranges) {\n      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);\n    }\n    range = model.ranges[rangeIdx];\n    if (range) {\n      model.rangeTuple[0] = range.min;\n      model.rangeTuple[1] = range.max;\n      return model.rangeTuple;\n    }\n\n    // Need to compute ranges...\n    range = computeRange(publicAPI.getData(), componentIndex, model.numberOfComponents);\n    model.ranges[rangeIdx] = range;\n    model.rangeTuple[0] = range.min;\n    model.rangeTuple[1] = range.max;\n    return model.rangeTuple;\n  };\n  publicAPI.setRange = (rangeValue, componentIndex) => {\n    if (!model.ranges) {\n      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);\n    }\n    const range = {\n      min: rangeValue.min,\n      max: rangeValue.max\n    };\n    model.ranges[componentIndex] = range;\n    model.rangeTuple[0] = range.min;\n    model.rangeTuple[1] = range.max;\n    return model.rangeTuple;\n  };\n  publicAPI.getRanges = function () {\n    let computeRanges = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (!computeRanges) {\n      return structuredClone(model.ranges);\n    }\n    /** @type {import('../../../interfaces').vtkRange[]} */\n    const ranges = [];\n    for (let i = 0; i < model.numberOfComponents; i++) {\n      const [min, max] = publicAPI.getRange(i);\n      /** @type {import('../../../interfaces').vtkRange} */\n      const range = {\n        min,\n        max\n      };\n      ranges.push(range);\n    }\n    // where the number of components is greater than 1, the last element in\n    // the range array is the min,max magnitude of the entire dataset.\n    if (model.numberOfComponents > 1) {\n      const [min, max] = publicAPI.getRange(-1);\n      /** @type {import('../../../interfaces').vtkRange} */\n      const range = {\n        min,\n        max\n      };\n      ranges.push(range);\n    }\n    return ranges;\n  };\n  publicAPI.setTuple = (idx, tuple) => {\n    const offset = idx * model.numberOfComponents;\n    for (let i = 0; i < model.numberOfComponents; i++) {\n      model.values[offset + i] = tuple[i];\n    }\n  };\n  publicAPI.setTuples = (idx, tuples) => {\n    let i = idx * model.numberOfComponents;\n    const last = Math.min(tuples.length, model.size - i);\n    for (let j = 0; j < last;) {\n      model.values[i++] = tuples[j++];\n    }\n  };\n  publicAPI.insertTuple = (idx, tuple) => {\n    if (model.size <= idx * model.numberOfComponents) {\n      model.size = (idx + 1) * model.numberOfComponents;\n      resize(idx + 1);\n    }\n    publicAPI.setTuple(idx, tuple);\n    return idx;\n  };\n  publicAPI.insertTuples = (idx, tuples) => {\n    const end = idx + tuples.length / model.numberOfComponents;\n    if (model.size < end * model.numberOfComponents) {\n      model.size = end * model.numberOfComponents;\n      resize(end);\n    }\n    publicAPI.setTuples(idx, tuples);\n    return end;\n  };\n  publicAPI.insertNextTuple = tuple => {\n    const idx = model.size / model.numberOfComponents;\n    return publicAPI.insertTuple(idx, tuple);\n  };\n  publicAPI.insertNextTuples = tuples => {\n    const idx = model.size / model.numberOfComponents;\n    return publicAPI.insertTuples(idx, tuples);\n  };\n  publicAPI.findTuple = function (tuple) {\n    let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSILON;\n    for (let i = 0; i < model.size; i += model.numberOfComponents) {\n      if (Math.abs(tuple[0] - model.values[i]) <= precision) {\n        let match = true;\n        for (let j = 1; j < model.numberOfComponents; ++j) {\n          if (Math.abs(tuple[j] - model.values[i + j]) > precision) {\n            match = false;\n            break;\n          }\n        }\n        if (match) {\n          return i / model.numberOfComponents;\n        }\n      }\n    }\n    return -1;\n  };\n  publicAPI.getTuple = function (idx) {\n    let tupleToFill = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    const numberOfComponents = model.numberOfComponents || 1;\n    const offset = idx * numberOfComponents;\n    // Check most common component sizes first\n    // to avoid doing a for loop if possible\n    switch (numberOfComponents) {\n      case 4:\n        tupleToFill[3] = model.values[offset + 3];\n      // eslint-disable-next-line no-fallthrough\n      case 3:\n        tupleToFill[2] = model.values[offset + 2];\n      // eslint-disable-next-line no-fallthrough\n      case 2:\n        tupleToFill[1] = model.values[offset + 1];\n      // eslint-disable-next-line no-fallthrough\n      case 1:\n        tupleToFill[0] = model.values[offset];\n        break;\n      default:\n        for (let i = numberOfComponents - 1; i >= 0; --i) {\n          tupleToFill[i] = model.values[offset + i];\n        }\n    }\n    return tupleToFill;\n  };\n  publicAPI.getTuples = (fromId, toId) => {\n    const from = (fromId ?? 0) * model.numberOfComponents;\n    const to = (toId ?? publicAPI.getNumberOfTuples()) * model.numberOfComponents;\n    const arr = publicAPI.getData().subarray(from, to);\n    return arr.length > 0 ? arr : null;\n  };\n  publicAPI.getTupleLocation = function () {\n    let idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return idx * model.numberOfComponents;\n  };\n  publicAPI.getNumberOfComponents = () => model.numberOfComponents;\n  publicAPI.getNumberOfValues = () => model.size;\n  publicAPI.getNumberOfTuples = () => model.size / model.numberOfComponents;\n  publicAPI.getDataType = () => model.dataType;\n  /* eslint-disable no-use-before-define */\n  publicAPI.newClone = () => newInstance({\n    empty: true,\n    name: model.name,\n    dataType: model.dataType,\n    numberOfComponents: model.numberOfComponents\n  });\n  /* eslint-enable no-use-before-define */\n\n  publicAPI.getName = () => {\n    if (!model.name) {\n      publicAPI.modified();\n      model.name = `vtkDataArray${publicAPI.getMTime()}`;\n    }\n    return model.name;\n  };\n  publicAPI.setData = (typedArray, numberOfComponents) => {\n    model.values = typedArray;\n    model.size = typedArray.length;\n    model.dataType = getDataType(typedArray);\n    if (numberOfComponents) {\n      model.numberOfComponents = numberOfComponents;\n    }\n    if (model.size % model.numberOfComponents !== 0) {\n      model.numberOfComponents = 1;\n    }\n    publicAPI.dataChange();\n  };\n\n  // Override serialization support\n  publicAPI.getState = () => {\n    if (model.deleted) {\n      return null;\n    }\n    const jsonArchive = {\n      ...model,\n      vtkClass: publicAPI.getClassName()\n    };\n\n    // Convert typed array to regular array\n    jsonArchive.values = Array.from(jsonArchive.values);\n    delete jsonArchive.buffer;\n\n    // Clean any empty data\n    Object.keys(jsonArchive).forEach(keyName => {\n      if (!jsonArchive[keyName]) {\n        delete jsonArchive[keyName];\n      }\n    });\n\n    // Sort resulting object by key name\n    const sortedObj = {};\n    Object.keys(jsonArchive).sort().forEach(name => {\n      sortedObj[name] = jsonArchive[name];\n    });\n\n    // Remove mtime\n    if (sortedObj.mtime) {\n      delete sortedObj.mtime;\n    }\n    return sortedObj;\n  };\n\n  /**\n   * @param {import(\"./index\").vtkDataArray} other\n   */\n  publicAPI.deepCopy = other => {\n    // Retain current dataType and array reference before shallowCopy call.\n    const currentType = publicAPI.getDataType();\n    const currentArray = model.values;\n    publicAPI.shallowCopy(other);\n\n    // set the ranges\n    model.ranges = structuredClone(other.getRanges());\n\n    // Avoid array reallocation if size already sufficient\n    // and dataTypes match.\n    if (currentArray?.length >= other.getNumberOfValues() && currentType === other.getDataType()) {\n      currentArray.set(other.getData());\n      model.values = currentArray;\n      publicAPI.dataChange();\n    } else {\n      publicAPI.setData(other.getData().slice());\n    }\n  };\n  publicAPI.interpolateTuple = (idx, source1, source1Idx, source2, source2Idx, t) => {\n    const numberOfComponents = model.numberOfComponents || 1;\n    if (numberOfComponents !== source1.getNumberOfComponents() || numberOfComponents !== source2.getNumberOfComponents()) {\n      vtkErrorMacro('numberOfComponents must match');\n    }\n    const tuple1 = source1.getTuple(source1Idx);\n    const tuple2 = source2.getTuple(source2Idx);\n    const out = [];\n    out.length = numberOfComponents;\n\n    // Check most common component sizes first\n    // to avoid doing a for loop if possible\n    switch (numberOfComponents) {\n      case 4:\n        out[3] = tuple1[3] + (tuple2[3] - tuple1[3]) * t;\n      // eslint-disable-next-line no-fallthrough\n      case 3:\n        out[2] = tuple1[2] + (tuple2[2] - tuple1[2]) * t;\n      // eslint-disable-next-line no-fallthrough\n      case 2:\n        out[1] = tuple1[1] + (tuple2[1] - tuple1[1]) * t;\n      // eslint-disable-next-line no-fallthrough\n      case 1:\n        out[0] = tuple1[0] + (tuple2[0] - tuple1[0]) * t;\n        break;\n      default:\n        for (let i = 0; i < numberOfComponents; i++) {\n          out[i] = tuple1[i] + (tuple2[i] - tuple1[i]) * t;\n        }\n    }\n    return publicAPI.insertTuple(idx, out);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\n// size: The current size of the dataArray.\n// NOTE: The underlying typed array may be larger than 'size'.\nconst DEFAULT_VALUES = {\n  name: '',\n  numberOfComponents: 1,\n  dataType: DefaultDataType,\n  rangeTuple: [0, 0]\n  // size: undefined,\n  // values: null,\n  // ranges: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  if (Array.isArray(initialValues.values) && initialValues.dataType === undefined) {\n    console.warn('vtkDataArray.newInstance: no dataType provided, converting to Float32Array');\n  }\n  if (!model.empty && !model.values && !model.size) {\n    throw new TypeError('Cannot create vtkDataArray object without: size > 0, values');\n  }\n  if (!model.values) {\n    model.values = newTypedArray(model.dataType, model.size);\n  } else if (Array.isArray(model.values)) {\n    model.values = newTypedArrayFrom(model.dataType, model.values);\n  }\n  if (model.values) {\n    // Takes the size if provided (can be lower than `model.values`) otherwise the actual length of `values`.\n    model.size = model.size ?? model.values.length;\n    model.dataType = getDataType(model.values);\n  }\n\n  // Object methods\n  obj(publicAPI, model);\n  set(publicAPI, model, ['name', 'numberOfComponents']);\n  if (model.size % model.numberOfComponents !== 0) {\n    throw new RangeError('model.size is not a multiple of model.numberOfComponents');\n  }\n\n  // Object specific methods\n  vtkDataArray(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkDataArray');\n\n// ----------------------------------------------------------------------------\n\nvar vtkDataArray$1 = {\n  newInstance,\n  extend,\n  ...STATIC,\n  ...Constants\n};\n\nexport { STATIC, vtkDataArray$1 as default, extend, newInstance };\n"],
  "mappings": "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",
  "names": ["DefaultDataType", "newInstance"]
}

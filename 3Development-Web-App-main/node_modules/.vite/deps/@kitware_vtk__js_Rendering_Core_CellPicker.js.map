{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Rendering/Core/AbstractPicker.js", "../../@kitware/vtk.js/Rendering/Core/Picker.js", "../../@kitware/vtk.js/Common/DataModel/PolyLine.js", "../../@kitware/vtk.js/Common/DataModel/Quad.js", "../../@kitware/vtk.js/Common/DataModel/Box.js", "../../@kitware/vtk.js/Rendering/Core/CellPicker.js"],
  "sourcesContent": ["import { m as macro } from '../../macros2.js';\n\n// ----------------------------------------------------------------------------\n// vtkAbstractPicker methods\n// ----------------------------------------------------------------------------\n\nfunction vtkAbstractPicker(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkAbstractPicker');\n  publicAPI.initialize = () => {\n    model.renderer = null;\n    model.selectionPoint[0] = 0.0;\n    model.selectionPoint[1] = 0.0;\n    model.selectionPoint[2] = 0.0;\n    model.pickPosition[0] = 0.0;\n    model.pickPosition[1] = 0.0;\n    model.pickPosition[2] = 0.0;\n  };\n  publicAPI.initializePickList = () => {\n    model.pickList = [];\n  };\n  publicAPI.addPickList = actor => {\n    model.pickList.push(actor);\n  };\n  publicAPI.deletePickList = actor => {\n    const i = model.pickList.indexOf(actor);\n    if (i !== -1) {\n      model.pickList.splice(i, 1);\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  renderer: null,\n  selectionPoint: [0.0, 0.0, 0.0],\n  pickPosition: [0.0, 0.0, 0.0],\n  pickFromList: false,\n  pickList: []\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['renderer']);\n  macro.getArray(publicAPI, model, ['selectionPoint', 'pickPosition']);\n  macro.setGet(publicAPI, model, ['pickFromList', 'pickList']);\n  vtkAbstractPicker(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkAbstractPicker');\n\n// ----------------------------------------------------------------------------\n\nvar vtkAbstractPicker$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkAbstractPicker$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkAbstractPicker from './AbstractPicker.js';\nimport vtkBoundingBox from '../../Common/DataModel/BoundingBox.js';\nimport { d as dot, l as normalize, s as subtract, e as distance2BetweenPoints } from '../../Common/Core/Math/index.js';\nimport { vec3, mat4, vec4 } from 'gl-matrix';\n\nconst {\n  vtkErrorMacro\n} = macro;\nconst {\n  vtkWarningMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkPicker methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPicker(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPicker');\n  const superClass = {\n    ...publicAPI\n  };\n  function initialize() {\n    superClass.initialize();\n    model.actors = [];\n    model.pickedPositions = [];\n    model.mapperPosition[0] = 0.0;\n    model.mapperPosition[1] = 0.0;\n    model.mapperPosition[2] = 0.0;\n    model.mapper = null;\n    model.dataSet = null;\n    model.globalTMin = Number.MAX_VALUE;\n  }\n\n  /**\n   * Compute the tolerance in world coordinates.\n   * Do this by determining the world coordinates of the diagonal points of the\n   * window, computing the width of the window in world coordinates, and\n   * multiplying by the tolerance.\n   * @param {Number} selectionZ\n   * @param {Number} aspect\n   * @param {vtkRenderer} renderer\n   * @returns {Number} the computed tolerance\n   */\n  function computeTolerance(selectionZ, aspect, renderer) {\n    let tolerance = 0.0;\n    const view = renderer.getRenderWindow().getViews()[0];\n    const viewport = renderer.getViewport();\n    const winSize = view.getSize();\n    let x = winSize[0] * viewport[0];\n    let y = winSize[1] * viewport[1];\n    const normalizedLeftDisplay = view.displayToNormalizedDisplay(x, y, selectionZ);\n    const windowLowerLeft = renderer.normalizedDisplayToWorld(normalizedLeftDisplay[0], normalizedLeftDisplay[1], normalizedLeftDisplay[2], aspect);\n    x = winSize[0] * viewport[2];\n    y = winSize[1] * viewport[3];\n    const normalizedRightDisplay = view.displayToNormalizedDisplay(x, y, selectionZ);\n    const windowUpperRight = renderer.normalizedDisplayToWorld(normalizedRightDisplay[0], normalizedRightDisplay[1], normalizedRightDisplay[2], aspect);\n    for (let i = 0; i < 3; i++) {\n      tolerance += (windowUpperRight[i] - windowLowerLeft[i]) * (windowUpperRight[i] - windowLowerLeft[i]);\n    }\n    return Math.sqrt(tolerance);\n  }\n\n  /**\n   * Perform picking on the given renderer, given a ray defined in world coordinates.\n   * @param {*} renderer\n   * @param {*} tolerance\n   * @param {*} p1World\n   * @param {*} p2World\n   * @returns true if we picked something else false\n   */\n  function pick3DInternal(renderer, tolerance, p1World, p2World) {\n    const p1Mapper = new Float64Array(4);\n    const p2Mapper = new Float64Array(4);\n    const ray = [];\n    const hitPosition = [];\n    const props = model.pickFromList ? model.pickList : renderer.getActors();\n\n    // pre-allocate some arrays.\n    const transformScale = new Float64Array(3);\n    const pickedPosition = new Float64Array(3);\n\n    // Loop over props.\n    // Transform ray (defined from position of camera to selection point) into coordinates of mapper (not\n    // transformed to actors coordinates!  Reduces overall computation!!!).\n    // Note that only vtkProp3D's can be picked by vtkPicker.\n    props.forEach(prop => {\n      const mapper = prop.getMapper();\n      const propIsFullyTranslucent = prop.getProperty?.().getOpacity?.() === 0.0;\n      const pickable = prop.getNestedPickable() && prop.getNestedVisibility() && !propIsFullyTranslucent;\n      if (!pickable) {\n        // prop cannot be picked\n        return;\n      }\n\n      // The prop is candidate for picking:\n      // - get its composite matrix and invert it\n      // - use the inverted matrix to transform the ray points into mapper coordinates\n      model.transformMatrix = prop.getMatrix().slice(0);\n      mat4.transpose(model.transformMatrix, model.transformMatrix);\n      mat4.invert(model.transformMatrix, model.transformMatrix);\n      vec4.transformMat4(p1Mapper, p1World, model.transformMatrix);\n      vec4.transformMat4(p2Mapper, p2World, model.transformMatrix);\n      vec3.scale(p1Mapper, p1Mapper, 1 / p1Mapper[3]);\n      vec3.scale(p2Mapper, p2Mapper, 1 / p2Mapper[3]);\n      subtract(p2Mapper, p1Mapper, ray);\n\n      // We now have the ray endpoints in mapper coordinates.\n      // Compare it with the mapper bounds to check if intersection is possible.\n\n      // Get the bounding box of the mapper.\n      // Note that the tolerance is added to the bounding box to make sure things on the edge of the\n      // bounding box are picked correctly.\n      const bounds = mapper ? vtkBoundingBox.inflate(mapper.getBounds(), tolerance) : [...vtkBoundingBox.INIT_BOUNDS];\n      if (vtkBoundingBox.intersectBox(bounds, p1Mapper, ray, hitPosition, [])) {\n        mat4.getScaling(transformScale, model.transformMatrix);\n        const t = model.intersectWithLine(p1Mapper, p2Mapper, tolerance * 0.333 * (transformScale[0] + transformScale[1] + transformScale[2]), prop, mapper);\n        if (t < Number.MAX_VALUE) {\n          pickedPosition[0] = (1.0 - t) * p1World[0] + t * p2World[0];\n          pickedPosition[1] = (1.0 - t) * p1World[1] + t * p2World[1];\n          pickedPosition[2] = (1.0 - t) * p1World[2] + t * p2World[2];\n          const actorIndex = model.actors.indexOf(prop);\n          if (actorIndex !== -1) {\n            // If already in list, compare the previous picked position with the new one.\n            // Store the new one if it is closer from the ray endpoint.\n            const previousPickedPosition = model.pickedPositions[actorIndex];\n            if (distance2BetweenPoints(p1World, pickedPosition) < distance2BetweenPoints(p1World, previousPickedPosition)) {\n              model.pickedPositions[actorIndex] = pickedPosition.slice(0);\n            }\n          } else {\n            model.actors.push(prop);\n            model.pickedPositions.push(pickedPosition.slice(0));\n          }\n        }\n      }\n    });\n\n    // sort array by distance\n    const tempArray = [];\n    for (let i = 0; i < model.pickedPositions.length; i++) {\n      tempArray.push({\n        actor: model.actors[i],\n        pickedPosition: model.pickedPositions[i],\n        distance2: distance2BetweenPoints(p1World, model.pickedPositions[i])\n      });\n    }\n    tempArray.sort((a, b) => {\n      const keyA = a.distance2;\n      const keyB = b.distance2;\n      // order the actors based on the distance2 attribute, so the near actors comes\n      // first in the list\n      if (keyA < keyB) return -1;\n      if (keyA > keyB) return 1;\n      return 0;\n    });\n    model.pickedPositions = [];\n    model.actors = [];\n    tempArray.forEach(obj => {\n      model.pickedPositions.push(obj.pickedPosition);\n      model.actors.push(obj.actor);\n    });\n  }\n\n  // Intersect data with specified ray.\n  // Project the center point of the mapper onto the ray and determine its parametric value\n  model.intersectWithLine = (p1, p2, tolerance, prop, mapper) => {\n    if (!mapper) {\n      return Number.MAX_VALUE;\n    }\n    const center = mapper.getCenter();\n    const ray = vec3.subtract(new Float64Array(3), p2, p1);\n    const rayFactor = dot(ray, ray);\n    if (rayFactor === 0.0) {\n      return 2.0;\n    }\n\n    // Project the center point onto the ray and determine its parametric value\n    const t = (ray[0] * (center[0] - p1[0]) + ray[1] * (center[1] - p1[1]) + ray[2] * (center[2] - p1[2])) / rayFactor;\n    return t;\n  };\n\n  // To be overridden in subclasses\n  publicAPI.pick = (selection, renderer) => {\n    if (selection.length !== 3) {\n      vtkWarningMacro('vtkPicker.pick - selection needs three components');\n    }\n    if (!renderer) {\n      vtkErrorMacro('vtkPicker.pick - renderer cannot be null');\n      throw new Error('renderer cannot be null');\n    }\n    initialize();\n    const selectionX = selection[0];\n    const selectionY = selection[1];\n    let selectionZ = selection[2];\n    model.renderer = renderer;\n    model.selectionPoint[0] = selectionX;\n    model.selectionPoint[1] = selectionY;\n    model.selectionPoint[2] = selectionZ;\n    const p1World = new Float64Array(4);\n    const p2World = new Float64Array(4);\n\n    // Get camera focal point and position. Convert to display (screen)\n    // coordinates. We need a depth value for z-buffer.\n    const camera = renderer.getActiveCamera();\n    const cameraPos = camera.getPosition();\n    const cameraFP = camera.getFocalPoint();\n    const view = renderer.getRenderWindow().getViews()[0];\n    const dims = view.getViewportSize(renderer);\n    if (dims[1] === 0) {\n      vtkWarningMacro('vtkPicker.pick - viewport area is 0');\n      return;\n    }\n    const aspect = dims[0] / dims[1];\n    let displayCoords = [];\n    displayCoords = renderer.worldToNormalizedDisplay(cameraFP[0], cameraFP[1], cameraFP[2], aspect);\n    displayCoords = view.normalizedDisplayToDisplay(displayCoords[0], displayCoords[1], displayCoords[2]);\n    selectionZ = displayCoords[2];\n\n    // Convert the selection point into world coordinates.\n    const normalizedDisplay = view.displayToNormalizedDisplay(selectionX, selectionY, selectionZ);\n    const worldCoords = renderer.normalizedDisplayToWorld(normalizedDisplay[0], normalizedDisplay[1], normalizedDisplay[2], aspect);\n    for (let i = 0; i < 3; i++) {\n      model.pickPosition[i] = worldCoords[i];\n    }\n\n    //  Compute the ray endpoints. The ray is along the line running from\n    //  the camera position to the selection point, starting where this line\n    //  intersects the front clipping plane, and terminating where this\n    //  line intersects the back clipping plane.\n    const ray = [];\n    for (let i = 0; i < 3; i++) {\n      ray[i] = model.pickPosition[i] - cameraPos[i];\n    }\n    const cameraDOP = [];\n    for (let i = 0; i < 3; i++) {\n      cameraDOP[i] = cameraFP[i] - cameraPos[i];\n    }\n    normalize(cameraDOP);\n    const rayLength = dot(cameraDOP, ray);\n    if (rayLength === 0.0) {\n      vtkWarningMacro('Picker::Pick Cannot process points');\n      return;\n    }\n    const clipRange = camera.getClippingRange();\n    let tF;\n    let tB;\n    if (camera.getParallelProjection()) {\n      tF = clipRange[0] - rayLength;\n      tB = clipRange[1] - rayLength;\n      for (let i = 0; i < 3; i++) {\n        p1World[i] = model.pickPosition[i] + tF * cameraDOP[i];\n        p2World[i] = model.pickPosition[i] + tB * cameraDOP[i];\n      }\n    } else {\n      tF = clipRange[0] / rayLength;\n      tB = clipRange[1] / rayLength;\n      for (let i = 0; i < 3; i++) {\n        p1World[i] = cameraPos[i] + tF * ray[i];\n        p2World[i] = cameraPos[i] + tB * ray[i];\n      }\n    }\n    p1World[3] = 1.0;\n    p2World[3] = 1.0;\n    const tolerance = computeTolerance(selectionZ, aspect, renderer) * model.tolerance;\n    pick3DInternal(model.renderer, tolerance, p1World, p2World);\n  };\n  publicAPI.pick3DPoint = (selectionPoint, focalPoint, renderer) => {\n    if (!renderer) {\n      throw new Error('renderer cannot be null');\n    }\n    initialize();\n    model.renderer = renderer;\n    vec3.copy(model.selectionPoint, selectionPoint);\n    const view = renderer.getRenderWindow().getViews()[0];\n    const dims = view.getViewportSize(renderer);\n    if (dims[1] === 0) {\n      vtkWarningMacro('vtkPicker.pick3DPoint - viewport area is 0');\n      return;\n    }\n    const aspect = dims[0] / dims[1];\n    const tolerance = computeTolerance(model.selectionPoint[2], aspect, renderer) * model.tolerance;\n    pick3DInternal(renderer, tolerance, selectionPoint, focalPoint);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  tolerance: 0.025,\n  mapperPosition: [0.0, 0.0, 0.0],\n  mapper: null,\n  dataSet: null,\n  actors: [],\n  pickedPositions: [],\n  transformMatrix: null,\n  globalTMin: Number.MAX_VALUE\n};\n\n// ----------------------------------------------------------------------------\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkAbstractPicker.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['tolerance']);\n  macro.setGetArray(publicAPI, model, ['mapperPosition'], 3);\n  macro.get(publicAPI, model, ['mapper', 'dataSet', 'actors', 'pickedPositions']);\n  macro.event(publicAPI, model, 'pickChange');\n  vtkPicker(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPicker');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPicker$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkPicker$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkCell from './Cell.js';\nimport vtkLine from './Line.js';\nimport { vec3 } from 'gl-matrix';\n\nfunction vtkPolyLine(publicAPI, model) {\n  model.classHierarchy.push('vtkPolyLine');\n  const line = vtkLine.newInstance();\n  line.getPoints().setNumberOfPoints(2);\n  publicAPI.getCellDimension = () => 1;\n  publicAPI.intersectWithLine = (t1, t2, p1, p2, tol, x, pcoords) => {\n    const outObj = {\n      intersect: 0,\n      t: Number.MAX_VALUE,\n      subId: 0,\n      betweenPoints: null\n    };\n    const numLines = publicAPI.getNumberOfPoints() - 1;\n    let pDistMin = Number.MAX_VALUE;\n    for (let subId = 0; subId < numLines; subId++) {\n      const pCoords = [0, 0, 0];\n      line.getPoints().getData().set(model.points.getData().subarray(3 * subId, 3 * (subId + 2)));\n      const lineIntersected = line.intersectWithLine(p1, p2, tol, x, pcoords);\n      if (lineIntersected.intersect === 1 && lineIntersected.t <= outObj.t + tol && lineIntersected.t >= t1 && lineIntersected.t <= t2) {\n        outObj.intersect = 1;\n        const pDist = line.getParametricDistance(pCoords);\n        if (pDist < pDistMin || pDist === pDistMin && lineIntersected.t < outObj.t) {\n          outObj.subId = subId;\n          outObj.t = lineIntersected.t;\n          pDistMin = pDist;\n          for (let k = 0; k < 3; k++) {\n            x[k];\n            pCoords[k];\n          }\n        }\n      }\n    }\n    return outObj;\n  };\n  publicAPI.evaluateLocation = (subId, pcoords, x, weights) => {\n    line.getPoints().getData().set(model.points.getData().subarray(3 * subId, 3 * (subId + 2)));\n    return line.evaluateLocation(pcoords, x, weights);\n  };\n  publicAPI.evaluateOrientation = (subId, pcoords, q, weights) => {\n    if (model.orientations) {\n      line.setOrientations([model.orientations[subId], model.orientations[subId + 1]]);\n    } else {\n      line.setOrientations(null);\n    }\n    return line.evaluateOrientation(pcoords, q, weights);\n  };\n  publicAPI.getDistancesToFirstPoint = () => {\n    const dTime = model.distancesTime.getMTime();\n    if (dTime < model.points.getMTime() || dTime < publicAPI.getMTime()) {\n      const numPoints = publicAPI.getNumberOfPoints();\n      if (!model.distances) {\n        model.distances = new Array(numPoints);\n      } else {\n        model.distances.length = numPoints;\n      }\n      if (numPoints > 0) {\n        const previousPoint = new Array(3);\n        const currentPoint = new Array(3);\n        let totalDistance = 0;\n        model.distances[0] = totalDistance;\n        model.points.getPoint(0, previousPoint);\n        for (let i = 1; i < numPoints; ++i) {\n          model.points.getPoint(i, currentPoint);\n          totalDistance += model.distanceFunction(previousPoint, currentPoint);\n          model.distances[i] = totalDistance;\n          vec3.copy(previousPoint, currentPoint);\n        }\n      }\n      model.distancesTime.modified();\n    }\n    return model.distances;\n  };\n  publicAPI.findPointIdAtDistanceFromFirstPoint = distance => {\n    const distances = publicAPI.getDistancesToFirstPoint();\n    // At least two points to return an ID\n    if (distances.length < 2) {\n      return -1;\n    }\n    // Binary search in the distance array\n    let minId = 0;\n    let maxId = distances.length - 1;\n    if (distance < distances[minId] || distance > distances[maxId] || distances[maxId] === 0) {\n      return -1;\n    }\n    while (maxId - minId > 1) {\n      const midId = Math.floor((minId + maxId) / 2);\n      if (distances[midId] <= distance) {\n        minId = midId;\n      } else {\n        maxId = midId;\n      }\n    }\n    return minId;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  orientations: null,\n  // an array of quat or null\n  distanceFunction: vec3.dist\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['orientations', 'distanceFunction']);\n  model.distancesTime = {};\n  macro.obj(model.distancesTime, {\n    mtime: 0\n  });\n  vtkPolyLine(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPolyLine');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPolyLine$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkPolyLine$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkCell from './Cell.js';\nimport { e as distance2BetweenPoints } from '../Core/Math/index.js';\nimport { CellType } from './CellTypes/Constants.js';\nimport vtkTriangle from './Triangle.js';\nimport vtkPoints from '../Core/Points.js';\n\nfunction intersectionStruct() {\n  return {\n    intersected: false,\n    subId: -1,\n    x: [0.0, 0.0, 0.0],\n    pCoords: [0.0, 0.0, 0.0],\n    t: -1\n  };\n}\nfunction vtkQuad(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkQuad');\n  publicAPI.getCellDimension = () => 2;\n  publicAPI.getCellType = () => CellType.VTK_QUAD;\n  publicAPI.getNumberOfEdges = () => 4;\n  publicAPI.getNumberOfFaces = () => 0;\n  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {\n    let outObj = {\n      subId: 0,\n      t: Number.MAX_VALUE,\n      intersect: 0,\n      betweenPoints: false\n    };\n    let diagonalCase;\n    const point0 = model.points.getPoint(0, []);\n    const point1 = model.points.getPoint(1, []);\n    const point2 = model.points.getPoint(2, []);\n    const point3 = model.points.getPoint(3, []);\n    const d1 = distance2BetweenPoints(point0, point2);\n    const d2 = distance2BetweenPoints(point1, point3);\n\n    /* Figure out how to uniquely tessellate the quad. Watch out for\n     * equivalent triangulations (i.e., the triangulation is equivalent\n     * no matter where the diagonal). In this case use the point ids as\n     * a tie breaker to ensure unique triangulation across the quad.\n     */\n\n    // rare case; discriminate based on point id\n    if (d1 === d2) {\n      // find the maximum id\n      let id;\n      let maxId = 0;\n      let maxIdx = 0;\n      for (let i = 0; i < 4; i++) {\n        id = model.pointsIds[i];\n        if (id > maxId) {\n          maxId = id;\n          maxIdx = i;\n        }\n      }\n      if (maxIdx === 0 || maxIdx === 2) {\n        diagonalCase = 0;\n      } else {\n        diagonalCase = 1;\n      }\n    } else if (d1 < d2) {\n      diagonalCase = 0;\n    } else {\n      diagonalCase = 1;\n    }\n    let points = null;\n    if (!model.triangle) {\n      model.triangle = vtkTriangle.newInstance();\n      points = vtkPoints.newInstance();\n      points.setNumberOfPoints(3);\n      model.triangle.initialize(points);\n    } else {\n      points = model.triangle.getPoints();\n    }\n    let firstIntersect;\n    const firstIntersectTmpObj = intersectionStruct();\n    let secondIntersect;\n    const secondIntersectTmpObj = intersectionStruct();\n    let useFirstIntersection;\n    let useSecondIntersection;\n    switch (diagonalCase) {\n      case 0:\n        points.setPoint(0, ...point0);\n        points.setPoint(1, ...point1);\n        points.setPoint(2, ...point2);\n        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);\n        points.setPoint(0, ...point2);\n        points.setPoint(1, ...point3);\n        points.setPoint(2, ...point0);\n        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);\n        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;\n        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;\n        if (useFirstIntersection) {\n          outObj = firstIntersect;\n          x[0] = firstIntersectTmpObj.x[0];\n          x[1] = firstIntersectTmpObj.x[1];\n          x[2] = firstIntersectTmpObj.x[2];\n          pcoords[0] = firstIntersectTmpObj.pCoords[0] + firstIntersectTmpObj.pCoords[1];\n          pcoords[1] = firstIntersectTmpObj.pCoords[1];\n          pcoords[2] = firstIntersectTmpObj.pCoords[2];\n        } else if (useSecondIntersection) {\n          outObj = secondIntersect;\n          x[0] = secondIntersectTmpObj.x[0];\n          x[1] = secondIntersectTmpObj.x[1];\n          x[2] = secondIntersectTmpObj.x[2];\n          pcoords[0] = 1.0 - (secondIntersectTmpObj.pCoords[0] + secondIntersectTmpObj.pCoords[1]);\n          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];\n          pcoords[2] = secondIntersectTmpObj.pCoords[2];\n        }\n        break;\n      case 1:\n        points.setPoint(0, ...point0);\n        points.setPoint(1, ...point1);\n        points.setPoint(2, ...point3);\n        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);\n        points.setPoint(0, ...point2);\n        points.setPoint(1, ...point3);\n        points.setPoint(2, ...point1);\n        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);\n        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;\n        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;\n        if (useFirstIntersection) {\n          outObj = firstIntersect;\n          x[0] = firstIntersectTmpObj.x[0];\n          x[1] = firstIntersectTmpObj.x[1];\n          x[2] = firstIntersectTmpObj.x[2];\n          pcoords[0] = firstIntersectTmpObj.pCoords[0];\n          pcoords[1] = firstIntersectTmpObj.pCoords[1];\n          pcoords[2] = firstIntersectTmpObj.pCoords[2];\n        } else if (useSecondIntersection) {\n          outObj = secondIntersect;\n          x[0] = secondIntersectTmpObj.x[0];\n          x[1] = secondIntersectTmpObj.x[1];\n          x[2] = secondIntersectTmpObj.x[2];\n          pcoords[0] = 1 - secondIntersectTmpObj.pCoords[0];\n          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];\n          pcoords[2] = secondIntersectTmpObj.pCoords[2];\n        }\n        break;\n    }\n    return outObj;\n  };\n  publicAPI.interpolationFunctions = (pcoords, weights) => {\n    const rm = 1 - pcoords[0];\n    const sm = 1 - pcoords[1];\n    weights[0] = rm * sm;\n    weights[1] = pcoords[0] * sm;\n    weights[2] = pcoords[0] * pcoords[1];\n    weights[3] = rm * pcoords[1];\n  };\n  publicAPI.evaluateLocation = (pcoords, x, weights) => {\n    const point = [];\n\n    // Calculate the weights\n    publicAPI.interpolationFunctions(pcoords, weights);\n    x[0] = 0.0;\n    x[1] = 0.0;\n    x[2] = 0.0;\n    for (let i = 0; i < 4; i++) {\n      model.points.getPoint(i, point);\n      for (let j = 0; j < 3; j++) {\n        x[j] += point[j] * weights[i];\n      }\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  vtkQuad(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkQuad');\n\n// ----------------------------------------------------------------------------\n\nvar vtkQuad$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkQuad$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkImplicitFunction from './ImplicitFunction.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// Bounding box intersection code from David Gobbi.  Go through the\n// bounding planes one at a time and compute the parametric coordinate\n// of each intersection and return the parametric values and the calculated points\nfunction intersectWithLine(bounds, p1, p2) {\n  let plane1 = -1;\n  let plane2 = -1;\n  let t1 = 0.0;\n  let t2 = 1.0;\n  for (let j = 0; j < 3; j++) {\n    for (let k = 0; k < 2; k++) {\n      // Compute distances of p1 and p2 from the plane along the plane normal\n      const i = 2 * j + k;\n      const d1 = (bounds[i] - p1[j]) * (1 - 2 * k);\n      const d2 = (bounds[i] - p2[j]) * (1 - 2 * k);\n\n      // If both distances are positive, both points are outside\n      if (d1 > 0 && d2 > 0) {\n        return;\n      }\n      // If one of the distances is positive, the line crosses the plane\n      if (d1 > 0 || d2 > 0) {\n        // Compute fractional distance \"t\" of the crossing between p1 & p2\n        let t = 0.0;\n        if (d1 !== 0) {\n          t = d1 / (d1 - d2);\n        }\n\n        // If point p1 was clipped, adjust t1\n        if (d1 > 0) {\n          if (t >= t1) {\n            t1 = t;\n            plane1 = i;\n          }\n        }\n        // else point p2 was clipped, so adjust t2\n        else if (t <= t2) {\n          t2 = t;\n          plane2 = i;\n        }\n        // If this happens, there's no line left\n        if (t1 > t2) {\n          // Allow for planes that are coincident or slightly inverted\n          if (plane1 < 0 || plane2 < 0) {\n            return;\n          }\n        }\n      }\n    }\n  }\n  function getValues(plane, t) {\n    const x = [0, 0, 0];\n    for (let count = 0; count < 2; count++) {\n      for (let i = 0; i < 3; i++) {\n        if (plane === 2 * i || plane === 2 * i + 1) {\n          x[i] = bounds[plane];\n        } else {\n          x[i] = p1[i] * (1.0 - t) + p2[i] * t;\n          if (x[i] < bounds[2 * i]) {\n            x[i] = bounds[2 * i];\n          }\n          if (x[i] > bounds[2 * i + 1]) {\n            x[i] = bounds[2 * i + 1];\n          }\n        }\n      }\n    }\n    return x;\n  }\n  const x1 = getValues(plane1, t1);\n  const x2 = getValues(plane2, t2);\n  const outObject = {\n    t1,\n    t2,\n    x1,\n    x2\n  };\n\n  // eslint-disable-next-line consistent-return\n  return outObject;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {};\n\n// ----------------------------------------------------------------------------\n// vtkBox methods\n// ----------------------------------------------------------------------------\nfunction vtkBox(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkBox');\n\n  // TODO: replace with macro.setArray ?\n  publicAPI.setBounds = function () {\n    let boundsArray = [];\n    for (var _len = arguments.length, bounds = new Array(_len), _key = 0; _key < _len; _key++) {\n      bounds[_key] = arguments[_key];\n    }\n    if (Array.isArray(bounds[0])) {\n      boundsArray = bounds[0];\n    } else {\n      for (let i = 0; i < bounds.length; i++) {\n        boundsArray.push(bounds[i]);\n      }\n    }\n    if (boundsArray.length !== 6) {\n      console.log('vtkBox.setBounds', boundsArray, bounds);\n      return;\n    }\n    vtkBoundingBox.setBounds(model.bbox, boundsArray);\n  };\n  publicAPI.getBounds = () => model.bbox;\n  publicAPI.evaluateFunction = (x, y, z) => {\n    const point = Array.isArray(x) ? x : [x, y, z];\n    let diff;\n    let dist;\n    let t;\n    let minDistance = -Number.MAX_VALUE;\n    let distance = 0;\n    const minPoint = vtkBoundingBox.getMinPoint(model.bbox);\n    const maxPoint = vtkBoundingBox.getMaxPoint(model.bbox);\n    let inside = 1;\n    for (let i = 0; i < 3; i++) {\n      diff = vtkBoundingBox.getLength(model.bbox, i);\n      if (diff !== 0.0) {\n        t = (point[i] - minPoint[i]) / diff;\n        if (t < 0.0) {\n          inside = 0;\n          dist = minPoint[i] - point[i];\n        } else if (t > 1.0) {\n          inside = 0;\n          dist = point[i] - maxPoint[i];\n        } else {\n          // want negative distance, we are inside\n          if (t <= 0.5) {\n            dist = minPoint[i] - point[i];\n          } else {\n            dist = point[i] - maxPoint[i];\n          }\n          if (dist > minDistance) {\n            // remember, it's negative\n            minDistance = dist;\n          }\n        } // end if inside\n      } else {\n        dist = Math.abs(point[i] - minPoint[i]);\n        if (dist > 0.0) {\n          inside = 0;\n        }\n      }\n      if (dist > 0.0) {\n        distance += dist * dist;\n      }\n    } // end for i\n    distance = Math.sqrt(distance);\n    if (inside) {\n      return minDistance;\n    }\n    return distance;\n  };\n  publicAPI.addBounds = function () {\n    let boundsArray = [];\n    if (Array.isArray(arguments.length <= 0 ? undefined : arguments[0])) {\n      boundsArray = arguments.length <= 0 ? undefined : arguments[0];\n    } else {\n      for (let i = 0; i < arguments.length; i++) {\n        boundsArray.push(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n      }\n    }\n    if (boundsArray.length !== 6) {\n      return;\n    }\n    vtkBoundingBox.addBounds(model.bbox, ...boundsArray);\n    publicAPI.modified();\n  };\n  publicAPI.addBox = other => publicAPI.addBounds(other.getBounds());\n  publicAPI.intersectWithLine = (p1, p2) => intersectWithLine(model.bbox, p1, p2);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  bbox: [...vtkBoundingBox.INIT_BOUNDS]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  vtkImplicitFunction.extend(publicAPI, model, initialValues);\n  vtkBox(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkBox');\n\n// ----------------------------------------------------------------------------\n\nvar vtkBox$1 = {\n  newInstance,\n  extend,\n  intersectWithLine,\n  ...STATIC\n};\n\nexport { STATIC, vtkBox$1 as default, extend, intersectWithLine, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkCellTypes from '../../Common/DataModel/CellTypes.js';\nimport vtkLine from '../../Common/DataModel/Line.js';\nimport vtkPicker from './Picker.js';\nimport vtkPolyLine from '../../Common/DataModel/PolyLine.js';\nimport vtkTriangle from '../../Common/DataModel/Triangle.js';\nimport vtkQuad from '../../Common/DataModel/Quad.js';\nimport { l as normalize, e as distance2BetweenPoints } from '../../Common/Core/Math/index.js';\nimport { CellType } from '../../Common/DataModel/CellTypes/Constants.js';\nimport { vec3, vec4 } from 'gl-matrix';\nimport vtkBox from '../../Common/DataModel/Box.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction createCellMap() {\n  return {\n    [CellType.VTK_LINE]: vtkLine.newInstance(),\n    [CellType.VTK_POLY_LINE]: vtkPolyLine.newInstance(),\n    [CellType.VTK_TRIANGLE]: vtkTriangle.newInstance(),\n    [CellType.VTK_QUAD]: vtkQuad.newInstance()\n  };\n}\nfunction clipLineWithPlane(mapper, matrix, p1, p2) {\n  const outObj = {\n    planeId: -1,\n    t1: 0.0,\n    t2: 1.0,\n    intersect: 0\n  };\n  const nbClippingPlanes = mapper.getNumberOfClippingPlanes();\n  const plane = [];\n  for (let i = 0; i < nbClippingPlanes; i++) {\n    mapper.getClippingPlaneInDataCoords(matrix, i, plane);\n    const d1 = plane[0] * p1[0] + plane[1] * p1[1] + plane[2] * p1[2] + plane[3];\n    const d2 = plane[0] * p2[0] + plane[1] * p2[1] + plane[2] * p2[2] + plane[3];\n\n    // If both distances are negative, both points are outside\n    if (d1 < 0 && d2 < 0) {\n      return 0;\n    }\n    if (d1 < 0 || d2 < 0) {\n      // If only one of the distances is negative, the line crosses the plane\n      // Compute fractional distance \"t\" of the crossing between p1 & p2\n      let t = 0.0;\n\n      // The \"if\" here just avoids an expensive division when possible\n      if (d1 !== 0) {\n        // We will never have d1==d2 since they have different signs\n        t = d1 / (d1 - d2);\n      }\n\n      // If point p1 was clipped, adjust t1\n      if (d1 < 0) {\n        if (t >= outObj.t1) {\n          outObj.t1 = t;\n          outObj.planeId = i;\n        }\n      } else if (t <= outObj.t2) {\n        // else point p2 was clipped, so adjust t2\n        outObj.t2 = t;\n      }\n      // If this happens, there's no line left\n      if (outObj.t1 > outObj.t2) {\n        outObj.intersect = 0;\n        return outObj;\n      }\n    }\n  }\n  outObj.intersect = 1;\n  return outObj;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  clipLineWithPlane\n};\n\n// ----------------------------------------------------------------------------\n// vtkCellPicker methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellPicker(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellPicker');\n  const superClass = {\n    ...publicAPI\n  };\n  function resetCellPickerInfo() {\n    model.cellId = -1;\n    model.pCoords[0] = 0.0;\n    model.pCoords[1] = 0.0;\n    model.pCoords[2] = 0.0;\n    model.cellIJK[0] = 0.0;\n    model.cellIJK[1] = 0.0;\n    model.cellIJK[2] = 0.0;\n    model.mapperNormal[0] = 0.0;\n    model.mapperNormal[1] = 0.0;\n    model.mapperNormal[2] = 1.0;\n    model.pickNormal[0] = 0.0;\n    model.pickNormal[1] = 0.0;\n    model.pickNormal[2] = 1.0;\n  }\n  function resetPickInfo() {\n    model.dataSet = null;\n    model.mapper = null;\n    resetCellPickerInfo();\n  }\n  publicAPI.initialize = () => {\n    resetPickInfo();\n    superClass.initialize();\n  };\n  publicAPI.computeSurfaceNormal = (data, cell, weights, normal) => {\n    const normals = data.getPointData().getNormals();\n    if (normals) {\n      normal[0] = 0.0;\n      normal[1] = 0.0;\n      normal[2] = 0.0;\n      const pointNormal = [];\n      for (let i = 0; i < 3; i++) {\n        normals.getTuple(cell.getPointsIds()[i], pointNormal);\n        normal[0] += pointNormal[0] * weights[i];\n        normal[1] += pointNormal[1] * weights[i];\n        normal[2] += pointNormal[2] * weights[i];\n      }\n      normalize(normal);\n    } else {\n      return 0;\n    }\n    return 1;\n  };\n  publicAPI.pick = (selection, renderer) => {\n    publicAPI.initialize();\n    const pickResult = superClass.pick(selection, renderer);\n    if (pickResult) {\n      const camera = renderer.getActiveCamera();\n      const cameraPos = [];\n      camera.getPosition(cameraPos);\n      if (camera.getParallelProjection()) {\n        // For parallel projection, use -ve direction of projection\n        const cameraFocus = [];\n        camera.getFocalPoint(cameraFocus);\n        model.pickNormal[0] = cameraPos[0] - cameraFocus[0];\n        model.pickNormal[1] = cameraPos[1] - cameraFocus[1];\n        model.pickNormal[2] = cameraPos[2] - cameraFocus[2];\n      } else {\n        // Get the vector from pick position to the camera\n        model.pickNormal[0] = cameraPos[0] - model.pickPosition[0];\n        model.pickNormal[1] = cameraPos[1] - model.pickPosition[1];\n        model.pickNormal[2] = cameraPos[2] - model.pickPosition[2];\n      }\n      normalize(model.pickNormal);\n    }\n    return pickResult;\n  };\n  model.intersectWithLine = (p1, p2, tolerance, prop, mapper) => {\n    let tMin = Number.MAX_VALUE;\n    let t1 = 0.0;\n    let t2 = 1.0;\n    const vtkCellPickerPlaneTol = 1e-14;\n    const clipLine = clipLineWithPlane(mapper, model.transformMatrix, p1, p2);\n    if (mapper && !clipLine.intersect) {\n      return Number.MAX_VALUE;\n    }\n    if (mapper.isA('vtkImageMapper') || mapper.isA('vtkImageArrayMapper')) {\n      const pickData = mapper.intersectWithLineForCellPicking(p1, p2);\n      if (pickData) {\n        tMin = pickData.t;\n        model.cellIJK = pickData.ijk;\n        model.pCoords = pickData.pCoords;\n      }\n    } else if (mapper.isA('vtkVolumeMapper')) {\n      // we calculate here the parametric intercept points between the ray and the bounding box, so\n      // if the application defines for some reason a too large ray length (1e6), it restrict the calculation\n      // to the vtkVolume prop bounding box\n      const interceptionObject = vtkBox.intersectWithLine(mapper.getBounds(), p1, p2);\n      t1 = interceptionObject?.t1 > clipLine.t1 ? interceptionObject.t1 : clipLine.t1;\n      t2 = interceptionObject?.t2 < clipLine.t2 ? interceptionObject.t2 : clipLine.t2;\n      tMin = model.intersectVolumeWithLine(p1, p2, t1, t2, tolerance, prop);\n    } else if (mapper.isA('vtkMapper')) {\n      tMin = model.intersectActorWithLine(p1, p2, t1, t2, tolerance, mapper);\n    }\n    if (tMin < model.globalTMin) {\n      model.globalTMin = tMin;\n      if (Math.abs(tMin - t1) < vtkCellPickerPlaneTol && clipLine.clippingPlaneId >= 0) {\n        model.mapperPosition[0] = p1[0] * (1 - t1) + p2[0] * t1;\n        model.mapperPosition[1] = p1[1] * (1 - t1) + p2[1] * t1;\n        model.mapperPosition[2] = p1[2] * (1 - t1) + p2[2] * t1;\n        const plane = [];\n        mapper.getClippingPlaneInDataCoords(model.transformMatrix, clipLine.clippingPlaneId, plane);\n        normalize(plane);\n        // Want normal outward from the planes, not inward\n        model.mapperNormal[0] = -plane[0];\n        model.mapperNormal[1] = -plane[1];\n        model.mapperNormal[2] = -plane[2];\n      }\n      vec3.transformMat4(model.pickPosition, model.mapperPosition, model.transformMatrix);\n      // Transform vector\n      const mat = model.transformMatrix;\n      model.mapperNormal[0] = mat[0] * model.pickNormal[0] + mat[4] * model.pickNormal[1] + mat[8] * model.pickNormal[2];\n      model.mapperNormal[1] = mat[1] * model.pickNormal[0] + mat[5] * model.pickNormal[1] + mat[9] * model.pickNormal[2];\n      model.mapperNormal[2] = mat[2] * model.pickNormal[0] + mat[6] * model.pickNormal[1] + mat[10] * model.pickNormal[2];\n    }\n    return tMin;\n  };\n  model.intersectVolumeWithLine = (p1, p2, t1, t2, tolerance, volume) => {\n    let tMin = Number.MAX_VALUE;\n    const mapper = volume.getMapper();\n    const imageData = mapper.getInputData();\n    const dims = imageData.getDimensions();\n    const scalars = imageData.getPointData().getScalars().getData();\n    const extent = imageData.getExtent();\n    // get the world to index transform to correctly transform from world to volume index\n    const imageTransform = imageData.getWorldToIndex();\n\n    // calculate opacity table\n    const numIComps = 1;\n    let oWidth = mapper.getOpacityTextureWidth();\n    if (oWidth <= 0) {\n      oWidth = 1024;\n    }\n    const tmpTable = new Float32Array(oWidth);\n    const opacityArray = new Float32Array(oWidth);\n    let ofun;\n    let oRange;\n    const sampleDist = volume.getMapper().getSampleDistance();\n    for (let c = 0; c < numIComps; ++c) {\n      ofun = volume.getProperty().getScalarOpacity(c);\n      oRange = ofun.getRange();\n      ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);\n      const opacityFactor = sampleDist / volume.getProperty().getScalarOpacityUnitDistance(c);\n\n      // adjust for sample distance etc\n      for (let i = 0; i < oWidth; ++i) {\n        opacityArray[i] = 1.0 - (1.0 - tmpTable[i]) ** opacityFactor;\n      }\n    }\n    const scale = oWidth / (oRange[1] - oRange[0] + 1);\n\n    // Make a new p1 and p2 using the clipped t1 and t2\n    const q1 = [0, 0, 0, 1];\n    const q2 = [0, 0, 0, 1];\n    q1[0] = p1[0];\n    q1[1] = p1[1];\n    q1[2] = p1[2];\n    q2[0] = p2[0];\n    q2[1] = p2[1];\n    q2[2] = p2[2];\n    if (t1 !== 0.0 || t2 !== 1.0) {\n      for (let j = 0; j < 3; j++) {\n        q1[j] = p1[j] * (1.0 - t1) + p2[j] * t1;\n        q2[j] = p1[j] * (1.0 - t2) + p2[j] * t2;\n      }\n    }\n\n    // convert q1, q2 world coordinates to x1, x2 volume index coordinates\n    const x1 = [0, 0, 0, 0];\n    const x2 = [0, 0, 0, 0];\n    vec4.transformMat4(x1, q1, imageTransform);\n    vec4.transformMat4(x2, q2, imageTransform);\n    const x = [0, 0, 0];\n    const xi = [0, 0, 0];\n    const sliceSize = dims[1] * dims[0];\n    const rowSize = dims[0];\n    // here the step is the 1 over the distance between volume index location x1 and x2\n    const step = 1 / Math.sqrt(distance2BetweenPoints(x1, x2));\n    let insideVolume;\n    // here we reinterpret the t value as the distance between x1 and x2\n    // When calculating the tMin, we weight t between t1 and t2 values\n    for (let t = 0; t < 1; t += step) {\n      // calculate the location of the point\n      insideVolume = true;\n      for (let j = 0; j < 3; j++) {\n        // \"t\" is the fractional distance between endpoints x1 and x2\n        x[j] = x1[j] * (1.0 - t) + x2[j] * t;\n      }\n      for (let j = 0; j < 3; j++) {\n        // Bounds check\n        if (x[j] < extent[2 * j]) {\n          x[j] = extent[2 * j];\n          insideVolume = false;\n        } else if (x[j] > extent[2 * j + 1]) {\n          x[j] = extent[2 * j + 1];\n          insideVolume = false;\n        }\n        xi[j] = Math.round(x[j]);\n      }\n      if (insideVolume) {\n        const index = xi[2] * sliceSize + xi[1] * rowSize + xi[0];\n        let value = scalars[index];\n        if (value < oRange[0]) {\n          value = oRange[0];\n        } else if (value > oRange[1]) {\n          value = oRange[1];\n        }\n        value = Math.floor((value - oRange[0]) * scale);\n        const opacity = tmpTable[value];\n        if (opacity > model.opacityThreshold) {\n          // returning the tMin to the original scale, if t1 > 0 or t2 < 1\n          tMin = t1 * (1.0 - t) + t2 * t;\n          break;\n        }\n      }\n    }\n    return tMin;\n  };\n  model.intersectActorWithLine = (p1, p2, t1, t2, tolerance, mapper) => {\n    let tMin = Number.MAX_VALUE;\n    const minXYZ = [0, 0, 0];\n    let pDistMin = Number.MAX_VALUE;\n    const minPCoords = [0, 0, 0];\n    let minCellId = null;\n    let minCell = null;\n    let minCellType = null;\n    let subId = null;\n    const x = [];\n    const data = mapper.getInputData();\n\n    // Make a new p1 and p2 using the clipped t1 and t2\n    const q1 = [0, 0, 0];\n    const q2 = [0, 0, 0];\n    q1[0] = p1[0];\n    q1[1] = p1[1];\n    q1[2] = p1[2];\n    q2[0] = p2[0];\n    q2[1] = p2[1];\n    q2[2] = p2[2];\n    if (t1 !== 0.0 || t2 !== 1.0) {\n      for (let j = 0; j < 3; j++) {\n        q1[j] = p1[j] * (1.0 - t1) + p2[j] * t1;\n        q2[j] = p1[j] * (1.0 - t2) + p2[j] * t2;\n      }\n    }\n    if (data.getCells) {\n      if (!data.getCells()) {\n        data.buildLinks();\n      }\n      const tempCellMap = createCellMap();\n      const minCellMap = createCellMap();\n      const numberOfCells = data.getNumberOfCells();\n\n      /* eslint-disable no-continue */\n      for (let cellId = 0; cellId < numberOfCells; cellId++) {\n        const pCoords = [0, 0, 0];\n        minCellType = data.getCellType(cellId);\n\n        // Skip cells that are marked as empty\n        if (minCellType === CellType.VTK_EMPTY_CELL) {\n          continue;\n        }\n        const cell = tempCellMap[minCellType];\n        if (cell == null) {\n          continue;\n        }\n        minCell = minCellMap[minCellType];\n        data.getCell(cellId, cell);\n        let cellPicked;\n        {\n          if (vtkCellTypes.hasSubCells(minCellType)) {\n            cellPicked = cell.intersectWithLine(t1, t2, p1, p2, tolerance, x, pCoords);\n          } else {\n            cellPicked = cell.intersectWithLine(p1, p2, tolerance, x, pCoords);\n          }\n        }\n        if (cellPicked.intersect === 1 && cellPicked.t <= tMin + model.tolerance && cellPicked.t >= t1 && cellPicked.t <= t2) {\n          const pDist = cell.getParametricDistance(pCoords);\n          if (pDist < pDistMin || pDist === pDistMin && cellPicked.t < tMin) {\n            tMin = cellPicked.t;\n            pDistMin = pDist;\n            subId = cellPicked.subId;\n            minCellId = cellId;\n            cell.deepCopy(minCell);\n            for (let k = 0; k < 3; k++) {\n              minXYZ[k] = x[k];\n              minPCoords[k] = pCoords[k];\n            }\n          }\n        }\n      }\n      /* eslint-enable no-continue */\n    }\n\n    if (minCellId >= 0 && tMin < model.globalTMin) {\n      resetPickInfo();\n      const nbPointsInCell = minCell.getNumberOfPoints();\n      const weights = new Array(nbPointsInCell);\n      for (let i = 0; i < nbPointsInCell; i++) {\n        weights[i] = 0.0;\n      }\n      const point = [];\n      if (vtkCellTypes.hasSubCells(minCellType)) {\n        minCell.evaluateLocation(subId, minPCoords, point, weights);\n      } else {\n        minCell.evaluateLocation(minPCoords, point, weights);\n      }\n\n      // Return the polydata to the user\n      model.dataSet = data;\n      model.cellId = minCellId;\n      model.pCoords[0] = minPCoords[0];\n      model.pCoords[1] = minPCoords[1];\n      model.pCoords[2] = minPCoords[2];\n\n      // Find the point with the maximum weight\n      let maxWeight = 0;\n      let iMaxWeight = -1;\n      for (let i = 0; i < nbPointsInCell; i++) {\n        if (weights[i] > maxWeight) {\n          iMaxWeight = i;\n          maxWeight = weights[i];\n        }\n      }\n\n      // If maximum weight is found, use it to get the PointId\n      if (iMaxWeight !== -1) {\n        model.pointId = minCell.getPointsIds()[iMaxWeight];\n      }\n\n      // Set the mapper position\n      model.mapperPosition[0] = minXYZ[0];\n      model.mapperPosition[1] = minXYZ[1];\n      model.mapperPosition[2] = minXYZ[2];\n\n      // Compute the normal\n      if (!publicAPI.computeSurfaceNormal(data, minCell, weights, model.mapperNormal)) {\n        // By default, the normal points back along view ray\n        model.mapperNormal[0] = p1[0] - p2[0];\n        model.mapperNormal[1] = p1[1] - p2[1];\n        model.mapperNormal[2] = p1[2] - p2[2];\n        normalize(model.mapperNormal);\n      }\n    }\n    return tMin;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  cellId: -1,\n  pCoords: [],\n  cellIJK: [],\n  pickNormal: [],\n  mapperNormal: [],\n  opacityThreshold: 0.2\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkPicker.extend(publicAPI, model, initialValues);\n  macro.getArray(publicAPI, model, ['pickNormal', 'mapperNormal', 'pCoords', 'cellIJK']);\n  macro.setGet(publicAPI, model, ['opacityThreshold']);\n  macro.get(publicAPI, model, ['cellId']);\n\n  // Object methods\n  vtkCellPicker(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCellPicker');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellPicker$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkCellPicker$1 as default, extend, newInstance };\n"],
  "mappings": "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",
  "names": ["DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "STATIC", "DEFAULT_VALUES", "extend", "newInstance"]
}

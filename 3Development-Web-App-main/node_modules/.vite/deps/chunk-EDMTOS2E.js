import {
  vtkProperty$1
} from "./chunk-MZPB4RVF.js";
import {
  vtkBoundingBox
} from "./chunk-OR5FAYKF.js";
import {
  mat4_exports,
  quat_exports,
  vec3_exports
} from "./chunk-OX3JD63S.js";
import {
  areMatricesEqual,
  degreesFromRadians,
  radiansFromDegrees
} from "./chunk-TIDT2POU.js";
import {
  macro
} from "./chunk-RF5CWC6R.js";

// node_modules/@kitware/vtk.js/Rendering/Core/Prop/Constants.js
var CoordinateSystem = {
  DISPLAY: 0,
  WORLD: 1
};
var Constants = {
  CoordinateSystem
};

// node_modules/@kitware/vtk.js/Rendering/Core/Prop.js
var {
  CoordinateSystem: CoordinateSystem2
} = Constants;
function notImplemented(method) {
  return () => macro.vtkErrorMacro(`vtkProp::${method} - NOT IMPLEMENTED`);
}
function vtkProp(publicAPI, model) {
  model.classHierarchy.push("vtkProp");
  publicAPI.getMTime = () => {
    let m1 = model.mtime;
    for (let index = 0; index < model.textures.length; ++index) {
      const m2 = model.textures[index].getMTime();
      if (m2 > m1) {
        m1 = m2;
      }
    }
    return m1;
  };
  publicAPI.processSelectorPixelBuffers = (selector, pixeloffsets) => {
  };
  publicAPI.getNestedProps = () => null;
  publicAPI.getActors = () => [];
  publicAPI.getActors2D = () => [];
  publicAPI.getVolumes = () => [];
  publicAPI.pick = notImplemented("pick");
  publicAPI.hasKey = notImplemented("hasKey");
  publicAPI.getNestedVisibility = () => model.visibility && (!model._parentProp || model._parentProp.getNestedVisibility());
  publicAPI.getNestedPickable = () => model.pickable && (!model._parentProp || model._parentProp.getNestedPickable());
  publicAPI.getNestedDragable = () => model.dragable && (!model._parentProp || model._parentProp.getNestedDragable());
  publicAPI.getRedrawMTime = () => model.mtime;
  publicAPI.setEstimatedRenderTime = (t) => {
    model.estimatedRenderTime = t;
    model.savedEstimatedRenderTime = t;
  };
  publicAPI.restoreEstimatedRenderTime = () => {
    model.estimatedRenderTime = model.savedEstimatedRenderTime;
  };
  publicAPI.addEstimatedRenderTime = (t) => {
    model.estimatedRenderTime += t;
  };
  publicAPI.setAllocatedRenderTime = (t) => {
    model.allocatedRenderTime = t;
    model.savedEstimatedRenderTime = model.estimatedRenderTime;
    model.estimatedRenderTime = 0;
  };
  publicAPI.getSupportsSelection = () => false;
  publicAPI.getTextures = () => model.textures;
  publicAPI.hasTexture = (texture) => model.textures.indexOf(texture) !== -1;
  publicAPI.addTexture = (texture) => {
    if (texture && !publicAPI.hasTexture(texture)) {
      model.textures = model.textures.concat(texture);
      publicAPI.modified();
    }
  };
  publicAPI.removeTexture = (texture) => {
    const newTextureList = model.textures.filter((item) => item !== texture);
    if (model.textures.length !== newTextureList.length) {
      model.textures = newTextureList;
      publicAPI.modified();
    }
  };
  publicAPI.removeAllTextures = () => {
    model.textures = [];
    publicAPI.modified();
  };
  publicAPI.setCoordinateSystemToWorld = () => publicAPI.setCoordinateSystem(CoordinateSystem2.WORLD);
  publicAPI.setCoordinateSystemToDisplay = () => publicAPI.setCoordinateSystem(CoordinateSystem2.DISPLAY);
}
var DEFAULT_VALUES = {
  // _parentProp: null,
  allocatedRenderTime: 10,
  coordinateSystem: CoordinateSystem2.WORLD,
  dragable: true,
  estimatedRenderTime: 0,
  paths: null,
  pickable: true,
  renderTimeMultiplier: 1,
  savedEstimatedRenderTime: 0,
  textures: [],
  useBounds: true,
  visibility: true
};
function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["estimatedRenderTime", "allocatedRenderTime"]);
  macro.setGet(publicAPI, model, ["_parentProp", "coordinateSystem", "dragable", "pickable", "renderTimeMultiplier", "useBounds", "visibility"]);
  macro.moveToProtected(publicAPI, model, ["parentProp"]);
  vtkProp(publicAPI, model);
}
var newInstance = macro.newInstance(extend, "vtkProp");
var vtkProp$1 = {
  newInstance,
  extend,
  ...Constants
};

// node_modules/@kitware/vtk.js/Rendering/Core/Prop3D.js
var VTK_EPSILON = 1e-6;
function vtkProp3D(publicAPI, model) {
  model.classHierarchy.push("vtkProp3D");
  publicAPI.addPosition = (deltaXYZ) => {
    model.position = model.position.map((value, index) => value + deltaXYZ[index]);
    publicAPI.modified();
  };
  publicAPI.getOrientationWXYZ = () => {
    const q = quat_exports.create();
    mat4_exports.getRotation(q, model.rotation);
    const oaxis = new Float64Array(3);
    const w = quat_exports.getAxisAngle(oaxis, q);
    return [degreesFromRadians(w), oaxis[0], oaxis[1], oaxis[2]];
  };
  publicAPI.getOrientationQuaternion = function() {
    let out = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return mat4_exports.getRotation(out, model.rotation);
  };
  publicAPI.rotateX = (val) => {
    if (val === 0) {
      return;
    }
    mat4_exports.rotateX(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateY = (val) => {
    if (val === 0) {
      return;
    }
    mat4_exports.rotateY(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateZ = (val) => {
    if (val === 0) {
      return;
    }
    mat4_exports.rotateZ(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateWXYZ = (degrees, x, y, z) => {
    if (degrees === 0 || x === 0 && y === 0 && z === 0) {
      return;
    }
    const angle = radiansFromDegrees(degrees);
    const q = quat_exports.create();
    quat_exports.setAxisAngle(q, [x, y, z], angle);
    const quatMat = new Float64Array(16);
    mat4_exports.fromQuat(quatMat, q);
    mat4_exports.multiply(model.rotation, model.rotation, quatMat);
    publicAPI.modified();
  };
  publicAPI.rotateQuaternion = (orientationQuaternion) => {
    if (Math.abs(orientationQuaternion[3]) >= 1 - VTK_EPSILON) {
      return;
    }
    const oriQuatMat = mat4_exports.fromQuat(new Float64Array(16), orientationQuaternion);
    mat4_exports.multiply(model.rotation, model.rotation, oriQuatMat);
    publicAPI.modified();
  };
  publicAPI.setOrientation = (x, y, z) => {
    if (x === model.orientation[0] && y === model.orientation[1] && z === model.orientation[2]) {
      return false;
    }
    model.orientation = [x, y, z];
    mat4_exports.identity(model.rotation);
    publicAPI.rotateZ(z);
    publicAPI.rotateX(x);
    publicAPI.rotateY(y);
    publicAPI.modified();
    return true;
  };
  publicAPI.setUserMatrix = (matrix) => {
    if (areMatricesEqual(model.userMatrix, matrix)) {
      return false;
    }
    mat4_exports.copy(model.userMatrix, matrix);
    publicAPI.modified();
    return true;
  };
  publicAPI.getMatrix = () => {
    publicAPI.computeMatrix();
    return model.matrix;
  };
  publicAPI.computeMatrix = () => {
    if (publicAPI.getMTime() > model.matrixMTime.getMTime()) {
      mat4_exports.identity(model.matrix);
      if (model.userMatrix) {
        mat4_exports.multiply(model.matrix, model.matrix, model.userMatrix);
      }
      mat4_exports.translate(model.matrix, model.matrix, model.origin);
      mat4_exports.translate(model.matrix, model.matrix, model.position);
      mat4_exports.multiply(model.matrix, model.matrix, model.rotation);
      mat4_exports.scale(model.matrix, model.matrix, model.scale);
      mat4_exports.translate(model.matrix, model.matrix, [-model.origin[0], -model.origin[1], -model.origin[2]]);
      mat4_exports.transpose(model.matrix, model.matrix);
      model.isIdentity = true;
      for (let i = 0; i < 4; ++i) {
        for (let j = 0; j < 4; ++j) {
          if ((i === j ? 1 : 0) !== model.matrix[i + j * 4]) {
            model.isIdentity = false;
          }
        }
      }
      model.matrixMTime.modified();
    }
  };
  publicAPI.getCenter = () => vtkBoundingBox.getCenter(model.bounds);
  publicAPI.getLength = () => vtkBoundingBox.getLength(model.bounds);
  publicAPI.getXRange = () => vtkBoundingBox.getXRange(model.bounds);
  publicAPI.getYRange = () => vtkBoundingBox.getYRange(model.bounds);
  publicAPI.getZRange = () => vtkBoundingBox.getZRange(model.bounds);
  publicAPI.getUserMatrix = () => model.userMatrix;
  function updateIdentityFlag() {
    publicAPI.computeMatrix();
  }
  publicAPI.onModified(updateIdentityFlag);
}
var DEFAULT_VALUES2 = {
  origin: [0, 0, 0],
  position: [0, 0, 0],
  orientation: [0, 0, 0],
  rotation: null,
  scale: [1, 1, 1],
  bounds: [1, -1, 1, -1, 1, -1],
  userMatrix: null,
  userMatrixMTime: null,
  cachedProp3D: null,
  isIdentity: true,
  matrixMTime: null
};
function extend2(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  vtkProp$1.extend(publicAPI, model, initialValues);
  model.matrixMTime = {};
  macro.obj(model.matrixMTime);
  macro.get(publicAPI, model, ["bounds", "isIdentity"]);
  macro.getArray(publicAPI, model, ["orientation"]);
  macro.setGetArray(publicAPI, model, ["origin", "position", "scale"], 3);
  model.matrix = mat4_exports.identity(new Float64Array(16));
  model.rotation = mat4_exports.identity(new Float64Array(16));
  model.userMatrix = mat4_exports.identity(new Float64Array(16));
  model.transform = null;
  vtkProp3D(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend2, "vtkProp3D");
var vtkProp3D$1 = {
  newInstance: newInstance2,
  extend: extend2
};

// node_modules/@kitware/vtk.js/Rendering/Core/Actor.js
var {
  vtkDebugMacro
} = macro;
function vtkActor(publicAPI, model) {
  model.classHierarchy.push("vtkActor");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getActors = () => [publicAPI];
  publicAPI.getIsOpaque = () => {
    if (model.forceOpaque) {
      return true;
    }
    if (model.forceTranslucent) {
      return false;
    }
    if (!model.property) {
      publicAPI.getProperty();
    }
    let isOpaque = model.property.getOpacity() >= 1;
    isOpaque = isOpaque && (!model.texture || !model.texture.isTranslucent());
    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());
    return isOpaque;
  };
  publicAPI.hasTranslucentPolygonalGeometry = () => {
    if (model.mapper === null) {
      return false;
    }
    if (model.property === null) {
      publicAPI.setProperty(publicAPI.makeProperty());
    }
    return !publicAPI.getIsOpaque();
  };
  publicAPI.makeProperty = vtkProperty$1.newInstance;
  publicAPI.getProperty = () => {
    if (model.property === null) {
      model.property = publicAPI.makeProperty();
    }
    return model.property;
  };
  publicAPI.getBounds = () => {
    if (model.mapper === null) {
      return model.bounds;
    }
    const bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds.concat();
      model.bounds = [1, -1, 1, -1, 1, -1];
      model.boundsMTime.modified();
      return bds;
    }
    if (!model.mapperBounds || bds[0] !== model.mapperBounds[0] || bds[1] !== model.mapperBounds[1] || bds[2] !== model.mapperBounds[2] || bds[3] !== model.mapperBounds[3] || bds[4] !== model.mapperBounds[4] || bds[5] !== model.mapperBounds[5] || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
      vtkDebugMacro("Recomputing bounds...");
      model.mapperBounds = bds.concat();
      const bbox = [];
      vtkBoundingBox.getCorners(bds, bbox);
      publicAPI.computeMatrix();
      const tmp4 = new Float64Array(16);
      mat4_exports.transpose(tmp4, model.matrix);
      bbox.forEach((pt) => vec3_exports.transformMat4(pt, pt, tmp4));
      model.bounds[0] = model.bounds[2] = model.bounds[4] = Number.MAX_VALUE;
      model.bounds[1] = model.bounds[3] = model.bounds[5] = -Number.MAX_VALUE;
      model.bounds = model.bounds.map((d, i) => i % 2 === 0 ? bbox.reduce((a, b) => a > b[i / 2] ? b[i / 2] : a, d) : bbox.reduce((a, b) => a < b[(i - 1) / 2] ? b[(i - 1) / 2] : a, d));
      model.boundsMTime.modified();
    }
    return model.bounds;
  };
  publicAPI.getMTime = () => {
    let mt = superClass.getMTime();
    if (model.property !== null) {
      const time = model.property.getMTime();
      mt = time > mt ? time : mt;
    }
    if (model.backfaceProperty !== null) {
      const time = model.backfaceProperty.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getRedrawMTime = () => {
    let mt = model.mtime;
    if (model.mapper !== null) {
      let time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };
  publicAPI.getSupportsSelection = () => model.mapper ? model.mapper.getSupportsSelection() : false;
  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {
    if (model.mapper && model.mapper.processSelectorPixelBuffers) {
      model.mapper.processSelectorPixelBuffers(selector, pixelOffsets);
    }
  };
}
var DEFAULT_VALUES3 = {
  mapper: null,
  property: null,
  backfaceProperty: null,
  forceOpaque: false,
  forceTranslucent: false,
  bounds: [1, -1, 1, -1, 1, -1]
};
function extend3(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  vtkProp3D$1.extend(publicAPI, model, initialValues);
  model.boundsMTime = {};
  macro.obj(model.boundsMTime);
  macro.set(publicAPI, model, ["property"]);
  macro.setGet(publicAPI, model, ["backfaceProperty", "forceOpaque", "forceTranslucent", "mapper"]);
  vtkActor(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend3, "vtkActor");
var vtkActor$1 = {
  newInstance: newInstance3,
  extend: extend3
};

export {
  vtkProp$1,
  extend3 as extend,
  newInstance3 as newInstance,
  vtkActor$1
};
//# sourceMappingURL=chunk-EDMTOS2E.js.map

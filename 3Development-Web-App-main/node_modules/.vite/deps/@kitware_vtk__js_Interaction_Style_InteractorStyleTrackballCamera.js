import {
  Device,
  Input,
  vtkRenderWindowInteractor$1
} from "./chunk-6VCNSPPG.js";
import {
  degreesFromRadians
} from "./chunk-TIDT2POU.js";
import {
  macro
} from "./chunk-RF5CWC6R.js";

// node_modules/@kitware/vtk.js/Rendering/Core/InteractorObserver.js
var {
  vtkErrorMacro,
  VOID
} = macro;
function computeWorldToDisplay(renderer, x, y, z) {
  const view = renderer.getRenderWindow().getViews()[0];
  return view.worldToDisplay(x, y, z, renderer);
}
function computeDisplayToWorld(renderer, x, y, z) {
  const view = renderer.getRenderWindow().getViews()[0];
  return view.displayToWorld(x, y, z, renderer);
}
var STATIC = {
  computeWorldToDisplay,
  computeDisplayToWorld
};
function vtkInteractorObserver(publicAPI, model) {
  model.classHierarchy.push("vtkInteractorObserver");
  const superClass = {
    ...publicAPI
  };
  function unsubscribeFromEvents() {
    while (model.subscribedEvents.length) {
      model.subscribedEvents.pop().unsubscribe();
    }
  }
  function subscribeToEvents() {
    vtkRenderWindowInteractor$1.handledEvents.forEach((eventName) => {
      if (publicAPI[`handle${eventName}`]) {
        model.subscribedEvents.push(model._interactor[`on${eventName}`]((callData) => {
          if (model.processEvents) {
            return publicAPI[`handle${eventName}`](callData);
          }
          return VOID;
        }, model.priority));
      }
    });
  }
  publicAPI.setInteractor = (i) => {
    if (i === model._interactor) {
      return;
    }
    unsubscribeFromEvents();
    model._interactor = i;
    if (i && model.enabled) {
      subscribeToEvents();
    }
    publicAPI.modified();
  };
  publicAPI.setEnabled = (enable) => {
    if (enable === model.enabled) {
      return;
    }
    unsubscribeFromEvents();
    if (enable) {
      if (model._interactor) {
        subscribeToEvents();
      } else {
        vtkErrorMacro(`
          The interactor must be set before subscribing to events
        `);
      }
    }
    model.enabled = enable;
    publicAPI.modified();
  };
  publicAPI.computeDisplayToWorld = (renderer, x, y, z) => {
    if (!renderer) {
      return null;
    }
    return model._interactor.getView().displayToWorld(x, y, z, renderer);
  };
  publicAPI.computeWorldToDisplay = (renderer, x, y, z) => {
    if (!renderer) {
      return null;
    }
    return model._interactor.getView().worldToDisplay(x, y, z, renderer);
  };
  publicAPI.setPriority = (priority) => {
    const modified = superClass.setPriority(priority);
    if (modified && model._interactor) {
      unsubscribeFromEvents();
      subscribeToEvents();
    }
  };
}
var DEFAULT_VALUES = {
  enabled: true,
  // _interactor: null,
  priority: 0,
  processEvents: true,
  subscribedEvents: []
};
function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.event(publicAPI, model, "InteractionEvent");
  macro.event(publicAPI, model, "StartInteractionEvent");
  macro.event(publicAPI, model, "EndInteractionEvent");
  macro.get(publicAPI, model, ["_interactor", "enabled"]);
  macro.setGet(publicAPI, model, ["priority", "processEvents"]);
  macro.moveToProtected(publicAPI, model, ["interactor"]);
  vtkInteractorObserver(publicAPI, model);
}
var newInstance = macro.newInstance(extend, "vtkInteractorObserver");
var vtkInteractorObserver$1 = {
  newInstance,
  extend,
  ...STATIC
};

// node_modules/@kitware/vtk.js/Rendering/Core/InteractorStyle/Constants.js
var States = {
  IS_START: 0,
  IS_NONE: 0,
  IS_ROTATE: 1,
  IS_PAN: 2,
  IS_SPIN: 3,
  IS_DOLLY: 4,
  IS_CAMERA_POSE: 11,
  IS_WINDOW_LEVEL: 1024,
  IS_SLICE: 1025
};
var vtkInteractorStyleConstants = {
  States
};

// node_modules/@kitware/vtk.js/Rendering/Core/InteractorStyle.js
var {
  States: States2
} = vtkInteractorStyleConstants;
var stateNames = {
  Rotate: States2.IS_ROTATE,
  Pan: States2.IS_PAN,
  Spin: States2.IS_SPIN,
  Dolly: States2.IS_DOLLY,
  CameraPose: States2.IS_CAMERA_POSE,
  WindowLevel: States2.IS_WINDOW_LEVEL,
  Slice: States2.IS_SLICE
};
function vtkInteractorStyle(publicAPI, model) {
  model.classHierarchy.push("vtkInteractorStyle");
  Object.keys(stateNames).forEach((key) => {
    macro.event(publicAPI, model, `Start${key}Event`);
    publicAPI[`start${key}`] = () => {
      if (model.state !== States2.IS_NONE) {
        return;
      }
      model.state = stateNames[key];
      model._interactor.requestAnimation(publicAPI);
      publicAPI.invokeStartInteractionEvent({
        type: "StartInteractionEvent"
      });
      publicAPI[`invokeStart${key}Event`]({
        type: `Start${key}Event`
      });
    };
    macro.event(publicAPI, model, `End${key}Event`);
    publicAPI[`end${key}`] = () => {
      if (model.state !== stateNames[key]) {
        return;
      }
      model.state = States2.IS_NONE;
      model._interactor.cancelAnimation(publicAPI);
      publicAPI.invokeEndInteractionEvent({
        type: "EndInteractionEvent"
      });
      publicAPI[`invokeEnd${key}Event`]({
        type: `End${key}Event`
      });
      model._interactor.render();
    };
  });
  model.getRenderer = (callData) => model.focusedRenderer || callData.pokedRenderer;
  publicAPI.handleKeyPress = (callData) => {
    const rwi = model._interactor;
    let ac = null;
    switch (callData.key) {
      case "r":
      case "R":
        model.getRenderer(callData).resetCamera();
        rwi.render();
        break;
      case "w":
      case "W":
        ac = model.getRenderer(callData).getActors();
        ac.forEach((anActor) => {
          const prop = anActor.getProperty();
          if (prop.setRepresentationToWireframe) {
            prop.setRepresentationToWireframe();
          }
        });
        rwi.render();
        break;
      case "s":
      case "S":
        ac = model.getRenderer(callData).getActors();
        ac.forEach((anActor) => {
          const prop = anActor.getProperty();
          if (prop.setRepresentationToSurface) {
            prop.setRepresentationToSurface();
          }
        });
        rwi.render();
        break;
      case "v":
      case "V":
        ac = model.getRenderer(callData).getActors();
        ac.forEach((anActor) => {
          const prop = anActor.getProperty();
          if (prop.setRepresentationToPoints) {
            prop.setRepresentationToPoints();
          }
        });
        rwi.render();
        break;
    }
  };
}
var DEFAULT_VALUES2 = {
  state: States2.IS_NONE,
  handleObservers: 1,
  autoAdjustCameraClippingRange: 1
};
function extend2(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  vtkInteractorObserver$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["focusedRenderer"]);
  vtkInteractorStyle(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend2, "vtkInteractorStyle");
var vtkInteractorStyle$1 = {
  newInstance: newInstance2,
  extend: extend2,
  ...vtkInteractorStyleConstants
};

// node_modules/@kitware/vtk.js/Interaction/Style/InteractorStyleTrackballCamera.js
var {
  States: States3
} = vtkInteractorStyleConstants;
function vtkInteractorStyleTrackballCamera(publicAPI, model) {
  model.classHierarchy.push("vtkInteractorStyleTrackballCamera");
  publicAPI.handleMouseMove = (callData) => {
    const pos = callData.position;
    const renderer = model.getRenderer(callData);
    switch (model.state) {
      case States3.IS_ROTATE:
        publicAPI.handleMouseRotate(renderer, pos);
        publicAPI.invokeInteractionEvent({
          type: "InteractionEvent"
        });
        break;
      case States3.IS_PAN:
        publicAPI.handleMousePan(renderer, pos);
        publicAPI.invokeInteractionEvent({
          type: "InteractionEvent"
        });
        break;
      case States3.IS_DOLLY:
        publicAPI.handleMouseDolly(renderer, pos);
        publicAPI.invokeInteractionEvent({
          type: "InteractionEvent"
        });
        break;
      case States3.IS_SPIN:
        publicAPI.handleMouseSpin(renderer, pos);
        publicAPI.invokeInteractionEvent({
          type: "InteractionEvent"
        });
        break;
    }
    model.previousPosition = pos;
  };
  publicAPI.handleButton3D = (ed) => {
    if (ed && ed.pressed && ed.device === Device.RightController && (ed.input === Input.Trigger || ed.input === Input.TrackPad)) {
      publicAPI.startCameraPose();
      return;
    }
    if (ed && !ed.pressed && ed.device === Device.RightController && (ed.input === Input.Trigger || ed.input === Input.TrackPad) && model.state === States3.IS_CAMERA_POSE) {
      publicAPI.endCameraPose();
    }
  };
  publicAPI.handleMove3D = (ed) => {
    switch (model.state) {
      case States3.IS_CAMERA_POSE:
        publicAPI.updateCameraPose(ed);
        break;
    }
  };
  publicAPI.updateCameraPose = (ed) => {
    const camera = model.getRenderer(ed).getActiveCamera();
    const oldTrans = camera.getPhysicalTranslation();
    const speed = 0.5;
    const pscale = speed * 0.05 * camera.getPhysicalScale();
    const dir = camera.physicalOrientationToWorldDirection([ed.orientation.x, ed.orientation.y, ed.orientation.z, ed.orientation.w]);
    camera.setPhysicalTranslation(oldTrans[0] + dir[0] * pscale, oldTrans[1] + dir[1] * pscale, oldTrans[2] + dir[2] * pscale);
  };
  publicAPI.handleLeftButtonPress = (callData) => {
    const pos = callData.position;
    model.previousPosition = pos;
    if (callData.shiftKey) {
      if (callData.controlKey || callData.altKey) {
        publicAPI.startDolly();
      } else {
        publicAPI.startPan();
      }
    } else {
      if (callData.controlKey || callData.altKey) {
        publicAPI.startSpin();
      } else {
        publicAPI.startRotate();
      }
    }
  };
  publicAPI.handleLeftButtonRelease = () => {
    switch (model.state) {
      case States3.IS_DOLLY:
        publicAPI.endDolly();
        break;
      case States3.IS_PAN:
        publicAPI.endPan();
        break;
      case States3.IS_SPIN:
        publicAPI.endSpin();
        break;
      case States3.IS_ROTATE:
        publicAPI.endRotate();
        break;
    }
  };
  publicAPI.handleStartMouseWheel = () => {
    publicAPI.startDolly();
  };
  publicAPI.handleEndMouseWheel = () => {
    publicAPI.endDolly();
  };
  publicAPI.handleStartPinch = (callData) => {
    model.previousScale = callData.scale;
    publicAPI.startDolly();
  };
  publicAPI.handleEndPinch = () => {
    publicAPI.endDolly();
  };
  publicAPI.handleStartRotate = (callData) => {
    model.previousRotation = callData.rotation;
    publicAPI.startRotate();
  };
  publicAPI.handleEndRotate = () => {
    publicAPI.endRotate();
  };
  publicAPI.handleStartPan = (callData) => {
    model.previousTranslation = callData.translation;
    publicAPI.startPan();
  };
  publicAPI.handleEndPan = () => {
    publicAPI.endPan();
  };
  publicAPI.handlePinch = (callData) => {
    publicAPI.dollyByFactor(model.getRenderer(callData), callData.scale / model.previousScale);
    model.previousScale = callData.scale;
  };
  publicAPI.handlePan = (callData) => {
    const camera = model.getRenderer(callData).getActiveCamera();
    let viewFocus = camera.getFocalPoint();
    viewFocus = publicAPI.computeWorldToDisplay(model.getRenderer(callData), viewFocus[0], viewFocus[1], viewFocus[2]);
    const focalDepth = viewFocus[2];
    const trans = callData.translation;
    const lastTrans = model.previousTranslation;
    const newPickPoint = publicAPI.computeDisplayToWorld(model.getRenderer(callData), viewFocus[0] + trans[0] - lastTrans[0], viewFocus[1] + trans[1] - lastTrans[1], focalDepth);
    const oldPickPoint = publicAPI.computeDisplayToWorld(model.getRenderer(callData), viewFocus[0], viewFocus[1], focalDepth);
    const motionVector = [];
    motionVector[0] = oldPickPoint[0] - newPickPoint[0];
    motionVector[1] = oldPickPoint[1] - newPickPoint[1];
    motionVector[2] = oldPickPoint[2] - newPickPoint[2];
    viewFocus = camera.getFocalPoint();
    const viewPoint = camera.getPosition();
    camera.setFocalPoint(motionVector[0] + viewFocus[0], motionVector[1] + viewFocus[1], motionVector[2] + viewFocus[2]);
    camera.setPosition(motionVector[0] + viewPoint[0], motionVector[1] + viewPoint[1], motionVector[2] + viewPoint[2]);
    if (model._interactor.getLightFollowCamera()) {
      model.getRenderer(callData).updateLightsGeometryToFollowCamera();
    }
    camera.orthogonalizeViewUp();
    model.previousTranslation = callData.translation;
  };
  publicAPI.handleRotate = (callData) => {
    const camera = model.getRenderer(callData).getActiveCamera();
    camera.roll(callData.rotation - model.previousRotation);
    camera.orthogonalizeViewUp();
    model.previousRotation = callData.rotation;
  };
  publicAPI.handleMouseRotate = (renderer, position) => {
    if (!model.previousPosition) {
      return;
    }
    const rwi = model._interactor;
    const dx = position.x - model.previousPosition.x;
    const dy = position.y - model.previousPosition.y;
    const size = rwi.getView().getViewportSize(renderer);
    let deltaElevation = -0.1;
    let deltaAzimuth = -0.1;
    if (size[0] && size[1]) {
      deltaElevation = -20 / size[1];
      deltaAzimuth = -20 / size[0];
    }
    const rxf = dx * deltaAzimuth * model.motionFactor;
    const ryf = dy * deltaElevation * model.motionFactor;
    const camera = renderer.getActiveCamera();
    if (!Number.isNaN(rxf) && !Number.isNaN(ryf)) {
      camera.azimuth(rxf);
      camera.elevation(ryf);
      camera.orthogonalizeViewUp();
    }
    if (model.autoAdjustCameraClippingRange) {
      renderer.resetCameraClippingRange();
    }
    if (rwi.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
  };
  publicAPI.handleMouseSpin = (renderer, position) => {
    if (!model.previousPosition) {
      return;
    }
    const rwi = model._interactor;
    const camera = renderer.getActiveCamera();
    const center = rwi.getView().getViewportCenter(renderer);
    const oldAngle = degreesFromRadians(Math.atan2(model.previousPosition.y - center[1], model.previousPosition.x - center[0]));
    const newAngle = degreesFromRadians(Math.atan2(position.y - center[1], position.x - center[0])) - oldAngle;
    if (!Number.isNaN(newAngle)) {
      camera.roll(newAngle);
      camera.orthogonalizeViewUp();
    }
  };
  publicAPI.handleMousePan = (renderer, position) => {
    if (!model.previousPosition) {
      return;
    }
    const camera = renderer.getActiveCamera();
    let viewFocus = camera.getFocalPoint();
    viewFocus = publicAPI.computeWorldToDisplay(renderer, viewFocus[0], viewFocus[1], viewFocus[2]);
    const focalDepth = viewFocus[2];
    const newPickPoint = publicAPI.computeDisplayToWorld(renderer, position.x, position.y, focalDepth);
    const oldPickPoint = publicAPI.computeDisplayToWorld(renderer, model.previousPosition.x, model.previousPosition.y, focalDepth);
    const motionVector = [];
    motionVector[0] = oldPickPoint[0] - newPickPoint[0];
    motionVector[1] = oldPickPoint[1] - newPickPoint[1];
    motionVector[2] = oldPickPoint[2] - newPickPoint[2];
    viewFocus = camera.getFocalPoint();
    const viewPoint = camera.getPosition();
    camera.setFocalPoint(motionVector[0] + viewFocus[0], motionVector[1] + viewFocus[1], motionVector[2] + viewFocus[2]);
    camera.setPosition(motionVector[0] + viewPoint[0], motionVector[1] + viewPoint[1], motionVector[2] + viewPoint[2]);
    if (model._interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
  };
  publicAPI.handleMouseDolly = (renderer, position) => {
    if (!model.previousPosition) {
      return;
    }
    const dy = position.y - model.previousPosition.y;
    const rwi = model._interactor;
    const center = rwi.getView().getViewportCenter(renderer);
    const dyf = model.motionFactor * dy / center[1];
    publicAPI.dollyByFactor(renderer, 1.1 ** dyf);
  };
  publicAPI.handleMouseWheel = (callData) => {
    const dyf = 1 - callData.spinY / model.zoomFactor;
    publicAPI.dollyByFactor(model.getRenderer(callData), dyf);
  };
  publicAPI.dollyByFactor = (renderer, factor) => {
    if (Number.isNaN(factor)) {
      return;
    }
    const camera = renderer.getActiveCamera();
    if (camera.getParallelProjection()) {
      camera.setParallelScale(camera.getParallelScale() / factor);
    } else {
      camera.dolly(factor);
      if (model.autoAdjustCameraClippingRange) {
        renderer.resetCameraClippingRange();
      }
    }
    if (model._interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
  };
}
var DEFAULT_VALUES3 = {
  motionFactor: 10,
  zoomFactor: 10
};
function extend3(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  vtkInteractorStyle$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["motionFactor", "zoomFactor"]);
  vtkInteractorStyleTrackballCamera(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend3, "vtkInteractorStyleTrackballCamera");
var vtkInteractorStyleTrackballCamera$1 = {
  newInstance: newInstance3,
  extend: extend3
};
export {
  vtkInteractorStyleTrackballCamera$1 as default,
  extend3 as extend,
  newInstance3 as newInstance
};
//# sourceMappingURL=@kitware_vtk__js_Interaction_Style_InteractorStyleTrackballCamera.js.map

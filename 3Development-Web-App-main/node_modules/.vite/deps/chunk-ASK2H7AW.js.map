{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Common/Core/CellArray.js", "../../@kitware/vtk.js/Common/DataModel/CellLinks.js", "../../@kitware/vtk.js/Common/DataModel/PointSet.js", "../../@kitware/vtk.js/Common/DataModel/PolyData/Constants.js", "../../@kitware/vtk.js/Common/DataModel/PolyData.js"],
  "sourcesContent": ["import { m as macro } from '../../macros2.js';\nimport vtkDataArray from './DataArray.js';\nimport { VtkDataTypes } from './DataArray/Constants.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction extractCellSizes(cellArray) {\n  let currentIdx = 0;\n  return cellArray.filter((value, index) => {\n    if (index === currentIdx) {\n      currentIdx += value + 1;\n      return true;\n    }\n    return false;\n  });\n}\nfunction getNumberOfCells(cellArray) {\n  let cellId = 0;\n  for (let cellArrayIndex = 0; cellArrayIndex < cellArray.length;) {\n    cellArrayIndex += cellArray[cellArrayIndex] + 1;\n    cellId++;\n  }\n  return cellId;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  extractCellSizes,\n  getNumberOfCells\n};\n\n// ----------------------------------------------------------------------------\n// vtkCellArray methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellArray(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellArray');\n  const superClass = {\n    ...publicAPI\n  };\n  publicAPI.getNumberOfCells = recompute => {\n    if (model.numberOfCells !== undefined && !recompute) {\n      return model.numberOfCells;\n    }\n    if (model.cellSizes) {\n      model.numberOfCells = model.cellSizes.length;\n    } else {\n      model.numberOfCells = getNumberOfCells(publicAPI.getData());\n    }\n    return model.numberOfCells;\n  };\n  publicAPI.getCellSizes = recompute => {\n    if (model.cellSizes !== undefined && !recompute) {\n      return model.cellSizes;\n    }\n    model.cellSizes = extractCellSizes(publicAPI.getData());\n    return model.cellSizes;\n  };\n\n  /**\n   * When `resize()` is being used, you then MUST use `insertNextCell()`.\n   */\n  publicAPI.resize = requestedNumTuples => {\n    const oldNumTuples = publicAPI.getNumberOfTuples();\n    superClass.resize(requestedNumTuples);\n    const newNumTuples = publicAPI.getNumberOfTuples();\n    if (newNumTuples < oldNumTuples) {\n      if (newNumTuples === 0) {\n        model.numberOfCells = 0;\n        model.cellSizes = [];\n      } else {\n        // We do not know how many cells are left.\n        // Set to undefined to ensure insertNextCell works correctly.\n        model.numberOfCells = undefined;\n        model.cellSizes = undefined;\n      }\n    }\n  };\n  publicAPI.setData = typedArray => {\n    superClass.setData(typedArray, 1);\n    model.numberOfCells = undefined;\n    model.cellSizes = undefined;\n  };\n  publicAPI.getCell = loc => {\n    let cellLoc = loc;\n    const numberOfPoints = model.values[cellLoc++];\n    return model.values.subarray(cellLoc, cellLoc + numberOfPoints);\n  };\n  publicAPI.insertNextCell = cellPointIds => {\n    const cellId = publicAPI.getNumberOfCells();\n    publicAPI.insertNextTuples([cellPointIds.length, ...cellPointIds]);\n    // By computing the number of cells earlier, we made sure that numberOfCells is defined\n    ++model.numberOfCells;\n    if (model.cellSizes != null) {\n      model.cellSizes.push(cellPointIds.length);\n    }\n    return cellId;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nfunction defaultValues(initialValues) {\n  return {\n    empty: true,\n    numberOfComponents: 1,\n    dataType: VtkDataTypes.UNSIGNED_INT,\n    ...initialValues\n  };\n}\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  vtkDataArray.extend(publicAPI, model, defaultValues(initialValues));\n  vtkCellArray(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCellArray');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellArray$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkCellArray$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkCell from './Cell.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\nconst InitLink = {\n  ncells: 0,\n  cells: null\n};\nfunction resize(model, sz) {\n  let newSize = sz;\n  if (sz >= model.array.length) {\n    newSize += model.array.length;\n  }\n  while (newSize > model.array.length) model.array.push({\n    ncells: 0,\n    cells: null\n  });\n  model.array.length = newSize;\n}\n\n// ----------------------------------------------------------------------------\n// vtkCellLinks methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellLinks(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellLinks');\n\n  /**\n   * Build the link list array. All subclasses of vtkAbstractCellLinks\n   * must support this method.\n   */\n  publicAPI.buildLinks = data => {\n    const numPts = data.getPoints().getNumberOfPoints();\n    const numCells = data.getNumberOfCells();\n\n    // fill out lists with number of references to cells\n    const linkLoc = new Uint32Array(numPts);\n\n    // Use fast path if polydata\n    if (data.isA('vtkPolyData')) {\n      // traverse data to determine number of uses of each point\n      for (let cellId = 0; cellId < numCells; ++cellId) {\n        const {\n          cellPointIds\n        } = data.getCellPoints(cellId);\n        cellPointIds.forEach(cellPointId => {\n          publicAPI.incrementLinkCount(cellPointId);\n        });\n      }\n\n      // now allocate storage for the links\n      publicAPI.allocateLinks(numPts);\n      model.maxId = numPts - 1;\n      for (let cellId = 0; cellId < numCells; ++cellId) {\n        const {\n          cellPointIds\n        } = data.getCellPoints(cellId);\n        cellPointIds.forEach(cellPointId => {\n          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);\n        });\n      }\n    } // any other type of dataset\n    else {\n      // traverse data to determine number of uses of each point\n      for (let cellId = 0; cellId < numCells; cellId++) {\n        // TODO: Currently not supported: const cell = data.getCell(cellId);\n        const cell = vtkCell.newInstance();\n        cell.getPointsIds().forEach(cellPointId => {\n          publicAPI.incrementLinkCount(cellPointId);\n        });\n      }\n\n      // now allocate storage for the links\n      publicAPI.allocateLinks(numPts);\n      model.maxId = numPts - 1;\n      for (let cellId = 0; cellId < numCells; ++cellId) {\n        // TODO: Currently not supported: const cell = data.getCell(cellId);\n        const cell = vtkCell.newInstance();\n        cell.getPointsIds().forEach(cellPointId => {\n          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);\n        });\n      }\n    } // end else\n  };\n\n  /**\n   * Build the link list array with a provided connectivity array.\n   */\n  // publicAPI.buildLinks = (data, connectivity) => {};\n\n  /**\n   * Allocate the specified number of links (i.e., number of points) that\n   * will be built.\n   */\n  publicAPI.allocate = function (numLinks) {\n    let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    model.array = Array(numLinks).fill().map(() => ({\n      ncells: 0,\n      cells: null\n    }));\n    model.extend = ext;\n    model.maxId = -1;\n  };\n  publicAPI.initialize = () => {\n    model.array = null;\n  };\n\n  /**\n   * Get a link structure given a point id.\n   */\n  publicAPI.getLink = ptId => model.array[ptId];\n\n  /**\n   * Get the number of cells using the point specified by ptId.\n   */\n  publicAPI.getNcells = ptId => model.array[ptId].ncells;\n\n  /**\n   * Return a list of cell ids using the point.\n   */\n  publicAPI.getCells = ptId => model.array[ptId].cells;\n\n  /**\n   * Insert a new point into the cell-links data structure. The size parameter\n   * is the initial size of the list.\n   */\n  publicAPI.insertNextPoint = numLinks => {\n    model.array.push({\n      ncells: numLinks,\n      cells: Array(numLinks)\n    });\n    ++model.maxId;\n  };\n\n  /**\n   * Insert a cell id into the list of cells (at the end) using the cell id\n   * provided. (Make sure to extend the link list (if necessary) using the\n   * method resizeCellList().)\n   */\n  publicAPI.insertNextCellReference = (ptId, cellId) => {\n    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;\n  };\n\n  /**\n   * Delete point (and storage) by destroying links to using cells.\n   */\n  publicAPI.deletePoint = ptId => {\n    model.array[ptId].ncells = 0;\n    model.array[ptId].cells = null;\n  };\n\n  /**\n   * Delete the reference to the cell (cellId) from the point (ptId). This\n   * removes the reference to the cellId from the cell list, but does not\n   * resize the list (recover memory with resizeCellList(), if necessary).\n   */\n  publicAPI.removeCellReference = (cellId, ptId) => {\n    model.array[ptId].cells = model.array[ptId].cells.filter(cell => cell !== cellId);\n    model.array[ptId].ncells = model.array[ptId].cells.length;\n  };\n\n  /**\n   * Add the reference to the cell (cellId) from the point (ptId). This\n   * adds a reference to the cellId from the cell list, but does not resize\n   * the list (extend memory with resizeCellList(), if necessary).\n   */\n  publicAPI.addCellReference = (cellId, ptId) => {\n    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;\n  };\n\n  /**\n   * Change the length of a point's link list (i.e., list of cells using a\n   * point) by the size specified.\n   */\n  publicAPI.resizeCellList = (ptId, size) => {\n    model.array[ptId].cells.length = size;\n  };\n\n  /**\n   * Reclaim any unused memory.\n   */\n  publicAPI.squeeze = () => {\n    resize(model, model.maxId + 1);\n  };\n\n  /**\n   * Reset to a state of no entries without freeing the memory.\n   */\n  publicAPI.reset = () => {\n    model.maxId = -1;\n  };\n\n  /**\n   * Standard DeepCopy method.  Since this object contains no reference\n   * to other objects, there is no ShallowCopy.\n   */\n  publicAPI.deepCopy = src => {\n    model.array = [...src.array];\n    model.extend = src.extend;\n    model.maxId = src.maxId;\n  };\n\n  /**\n   * Increment the count of the number of cells using the point.\n   */\n  publicAPI.incrementLinkCount = ptId => {\n    ++model.array[ptId].ncells;\n  };\n  publicAPI.allocateLinks = n => {\n    for (let i = 0; i < n; ++i) {\n      model.array[i].cells = new Array(model.array[i].ncells);\n    }\n  };\n\n  /**\n   * Insert a cell id into the list of cells using the point.\n   */\n  publicAPI.insertCellReference = (ptId, pos, cellId) => {\n    model.array[ptId].cells[pos] = cellId;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  array: null,\n  // pointer to data\n  maxId: 0,\n  // maximum index inserted thus far\n  extend: 0 // grow array by this point\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  vtkCellLinks(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCellLinks');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellLinks$1 = {\n  newInstance,\n  extend\n};\n\nexport { InitLink, vtkCellLinks$1 as default, extend, newInstance };\n", "import vtk from '../../vtk.js';\nimport { m as macro } from '../../macros2.js';\nimport vtkDataSet from './DataSet.js';\nimport vtkPoints from '../Core/Points.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n// vtkPointSet methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPointSet(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPointSet');\n\n  // Create empty points\n  if (!model.points) {\n    model.points = vtkPoints.newInstance();\n  } else {\n    model.points = vtk(model.points);\n  }\n  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();\n  publicAPI.getBounds = () => model.points.getBounds();\n  publicAPI.computeBounds = () => {\n    publicAPI.getBounds();\n  };\n  const superShallowCopy = publicAPI.shallowCopy;\n  publicAPI.shallowCopy = function (other) {\n    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    superShallowCopy(other, debug);\n    model.points = vtkPoints.newInstance();\n    model.points.shallowCopy(other.getPoints());\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // points: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkDataSet.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['points']);\n\n  // Object specific methods\n  vtkPointSet(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPointSet');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPointSet$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkPointSet$1 as default, extend, newInstance };\n", "const POLYDATA_FIELDS = ['verts', 'lines', 'polys', 'strips'];\nvar Constants = {\n  POLYDATA_FIELDS\n};\n\nexport { POLYDATA_FIELDS, Constants as default };\n", "import { m as macro } from '../../macros2.js';\nimport vtk from '../../vtk.js';\nimport vtkCellArray from '../Core/CellArray.js';\nimport vtkCellLinks from './CellLinks.js';\nimport vtkCellTypes from './CellTypes.js';\nimport vtkLine from './Line.js';\nimport vtkPointSet from './PointSet.js';\nimport vtkTriangle from './Triangle.js';\nimport { CellType } from './CellTypes/Constants.js';\nimport { POLYDATA_FIELDS } from './PolyData/Constants.js';\n\nconst {\n  vtkWarningMacro\n} = macro;\nconst CELL_FACTORY = {\n  [CellType.VTK_LINE]: vtkLine,\n  [CellType.VTK_POLY_LINE]: vtkLine,\n  [CellType.VTK_TRIANGLE]: vtkTriangle\n};\n\n// ----------------------------------------------------------------------------\n// vtkPolyData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPolyData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPolyData');\n  function camelize(str) {\n    return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, letter => letter.toUpperCase()).replace(/\\s+/g, '');\n  }\n\n  // build empty cell arrays and set methods\n  POLYDATA_FIELDS.forEach(type => {\n    publicAPI[`getNumberOf${camelize(type)}`] = () => model[type].getNumberOfCells();\n    if (!model[type]) {\n      model[type] = vtkCellArray.newInstance();\n    } else {\n      model[type] = vtk(model[type]);\n    }\n  });\n  publicAPI.getNumberOfCells = () => POLYDATA_FIELDS.reduce((num, cellType) => num + model[cellType].getNumberOfCells(), 0);\n  const superShallowCopy = publicAPI.shallowCopy;\n  publicAPI.shallowCopy = function (other) {\n    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    superShallowCopy(other, debug);\n    POLYDATA_FIELDS.forEach(type => {\n      model[type] = vtkCellArray.newInstance();\n      model[type].shallowCopy(other.getReferenceByName(type));\n    });\n  };\n  publicAPI.buildCells = () => {\n    // here are the number of cells we have\n    const nVerts = publicAPI.getNumberOfVerts();\n    const nLines = publicAPI.getNumberOfLines();\n    const nPolys = publicAPI.getNumberOfPolys();\n    const nStrips = publicAPI.getNumberOfStrips();\n\n    // pre-allocate the space we need\n    const nCells = nVerts + nLines + nPolys + nStrips;\n    const types = new Uint8Array(nCells);\n    let pTypes = types;\n    const locs = new Uint32Array(nCells);\n    let pLocs = locs;\n\n    // record locations and type of each cell.\n    // verts\n    if (nVerts) {\n      let nextCellPts = 0;\n      model.verts.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        pTypes[index] = numCellPts > 1 ? CellType.VTK_POLY_VERTEX : CellType.VTK_VERTEX;\n        nextCellPts += numCellPts + 1;\n      });\n      pLocs = pLocs.subarray(nVerts);\n      pTypes = pTypes.subarray(nVerts);\n    }\n\n    // lines\n    if (nLines) {\n      let nextCellPts = 0;\n      model.lines.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        pTypes[index] = numCellPts > 2 ? CellType.VTK_POLY_LINE : CellType.VTK_LINE;\n        if (numCellPts === 1) {\n          vtkWarningMacro('Building VTK_LINE ', index, ' with only one point, but VTK_LINE needs at least two points. Check the input.');\n        }\n        nextCellPts += numCellPts + 1;\n      });\n      pLocs = pLocs.subarray(nLines);\n      pTypes = pTypes.subarray(nLines);\n    }\n\n    // polys\n    if (nPolys) {\n      let nextCellPts = 0;\n      model.polys.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        switch (numCellPts) {\n          case 3:\n            pTypes[index] = CellType.VTK_TRIANGLE;\n            break;\n          case 4:\n            pTypes[index] = CellType.VTK_QUAD;\n            break;\n          default:\n            pTypes[index] = CellType.VTK_POLYGON;\n            break;\n        }\n        if (numCellPts < 3) {\n          vtkWarningMacro('Building VTK_TRIANGLE ', index, ' with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.');\n        }\n        nextCellPts += numCellPts + 1;\n      });\n      pLocs += pLocs.subarray(nPolys);\n      pTypes += pTypes.subarray(nPolys);\n    }\n\n    // strips\n    if (nStrips) {\n      let nextCellPts = 0;\n      pTypes.fill(CellType.VTK_TRIANGLE_STRIP, 0, nStrips);\n      model.strips.getCellSizes().forEach((numCellPts, index) => {\n        pLocs[index] = nextCellPts;\n        nextCellPts += numCellPts + 1;\n      });\n    }\n\n    // set up the cell types data structure\n    model.cells = vtkCellTypes.newInstance();\n    model.cells.setCellTypes(nCells, types, locs);\n  };\n\n  /**\n   * Create upward links from points to cells that use each point. Enables\n   * topologically complex queries.\n   */\n  publicAPI.buildLinks = function () {\n    let initialSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (model.cells === undefined) {\n      publicAPI.buildCells();\n    }\n    model.links = vtkCellLinks.newInstance();\n    if (initialSize > 0) {\n      model.links.allocate(initialSize);\n    } else {\n      model.links.allocate(publicAPI.getPoints().getNumberOfPoints());\n    }\n    model.links.buildLinks(publicAPI);\n  };\n  publicAPI.getCellType = cellId => model.cells.getCellType(cellId);\n  publicAPI.getCellPoints = cellId => {\n    const cellType = publicAPI.getCellType(cellId);\n    let cells = null;\n    switch (cellType) {\n      case CellType.VTK_VERTEX:\n      case CellType.VTK_POLY_VERTEX:\n        cells = model.verts;\n        break;\n      case CellType.VTK_LINE:\n      case CellType.VTK_POLY_LINE:\n        cells = model.lines;\n        break;\n      case CellType.VTK_TRIANGLE:\n      case CellType.VTK_QUAD:\n      case CellType.VTK_POLYGON:\n        cells = model.polys;\n        break;\n      case CellType.VTK_TRIANGLE_STRIP:\n        cells = model.strips;\n        break;\n      default:\n        cells = null;\n        return {\n          type: 0,\n          cellPointIds: null\n        };\n    }\n    const loc = model.cells.getCellLocation(cellId);\n    const cellPointIds = cells.getCell(loc);\n    return {\n      cellType,\n      cellPointIds\n    };\n  };\n  publicAPI.getPointCells = ptId => model.links.getCells(ptId);\n  publicAPI.getCellEdgeNeighbors = (cellId, point1, point2) => {\n    const link1 = model.links.getLink(point1);\n    const link2 = model.links.getLink(point2);\n    return link1.cells.filter(cell => cell !== cellId && link2.cells.indexOf(cell) !== -1);\n  };\n\n  /**\n   * If you know the type of cell, you may provide it to improve performances.\n   */\n  publicAPI.getCell = function (cellId) {\n    let cellHint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const cellInfo = publicAPI.getCellPoints(cellId);\n    const cell = cellHint || CELL_FACTORY[cellInfo.cellType].newInstance();\n    cell.initialize(publicAPI.getPoints(), cellInfo.cellPointIds);\n    return cell;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // verts: null,\n  // lines: null,\n  // polys: null,\n  // strips: null,\n  // cells: null,\n  // links: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkPointSet.extend(publicAPI, model, initialValues);\n  macro.get(publicAPI, model, ['cells', 'links']);\n  macro.setGet(publicAPI, model, ['verts', 'lines', 'polys', 'strips']);\n\n  // Object specific methods\n  vtkPolyData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPolyData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPolyData$1 = {\n  newInstance,\n  extend\n};\n\nexport { CELL_FACTORY, vtkPolyData$1 as default, extend, newInstance };\n"],
  "mappings": "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",
  "names": ["extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance"]
}

{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Common/DataModel/CellTypes/Constants.js", "../../@kitware/vtk.js/Common/DataModel/CellTypes.js", "../../@kitware/vtk.js/Common/DataModel/Line/Constants.js", "../../@kitware/vtk.js/Common/Core/Points.js", "../../@kitware/vtk.js/Common/DataModel/Cell.js", "../../@kitware/vtk.js/Common/DataModel/Line.js", "../../@kitware/vtk.js/Common/DataModel/Triangle.js"],
  "sourcesContent": ["const CellType = {\n  // Linear cells\n  VTK_EMPTY_CELL: 0,\n  VTK_VERTEX: 1,\n  VTK_POLY_VERTEX: 2,\n  VTK_LINE: 3,\n  VTK_POLY_LINE: 4,\n  VTK_TRIANGLE: 5,\n  VTK_TRIANGLE_STRIP: 6,\n  VTK_POLYGON: 7,\n  VTK_PIXEL: 8,\n  VTK_QUAD: 9,\n  VTK_TETRA: 10,\n  VTK_VOXEL: 11,\n  VTK_HEXAHEDRON: 12,\n  VTK_WEDGE: 13,\n  VTK_PYRAMID: 14,\n  VTK_PENTAGONAL_PRISM: 15,\n  VTK_HEXAGONAL_PRISM: 16,\n  // Quadratic, isoparametric cells\n  VTK_QUADRATIC_EDGE: 21,\n  VTK_QUADRATIC_TRIANGLE: 22,\n  VTK_QUADRATIC_QUAD: 23,\n  VTK_QUADRATIC_POLYGON: 36,\n  VTK_QUADRATIC_TETRA: 24,\n  VTK_QUADRATIC_HEXAHEDRON: 25,\n  VTK_QUADRATIC_WEDGE: 26,\n  VTK_QUADRATIC_PYRAMID: 27,\n  VTK_BIQUADRATIC_QUAD: 28,\n  VTK_TRIQUADRATIC_HEXAHEDRON: 29,\n  VTK_QUADRATIC_LINEAR_QUAD: 30,\n  VTK_QUADRATIC_LINEAR_WEDGE: 31,\n  VTK_BIQUADRATIC_QUADRATIC_WEDGE: 32,\n  VTK_BIQUADRATIC_QUADRATIC_HEXAHEDRON: 33,\n  VTK_BIQUADRATIC_TRIANGLE: 34,\n  // Cubic, isoparametric cell\n  VTK_CUBIC_LINE: 35,\n  // Special class of cells formed by convex group of points\n  VTK_CONVEX_POINT_SET: 41,\n  // Polyhedron cell (consisting of polygonal faces)\n  VTK_POLYHEDRON: 42,\n  // Higher order cells in parametric form\n  VTK_PARAMETRIC_CURVE: 51,\n  VTK_PARAMETRIC_SURFACE: 52,\n  VTK_PARAMETRIC_TRI_SURFACE: 53,\n  VTK_PARAMETRIC_QUAD_SURFACE: 54,\n  VTK_PARAMETRIC_TETRA_REGION: 55,\n  VTK_PARAMETRIC_HEX_REGION: 56,\n  // Higher order cells\n  VTK_HIGHER_ORDER_EDGE: 60,\n  VTK_HIGHER_ORDER_TRIANGLE: 61,\n  VTK_HIGHER_ORDER_QUAD: 62,\n  VTK_HIGHER_ORDER_POLYGON: 63,\n  VTK_HIGHER_ORDER_TETRAHEDRON: 64,\n  VTK_HIGHER_ORDER_WEDGE: 65,\n  VTK_HIGHER_ORDER_PYRAMID: 66,\n  VTK_HIGHER_ORDER_HEXAHEDRON: 67,\n  // Arbitrary order Lagrange elements (formulated separated from generic higher order cells)\n  VTK_LAGRANGE_CURVE: 68,\n  VTK_LAGRANGE_TRIANGLE: 69,\n  VTK_LAGRANGE_QUADRILATERAL: 70,\n  VTK_LAGRANGE_TETRAHEDRON: 71,\n  VTK_LAGRANGE_HEXAHEDRON: 72,\n  VTK_LAGRANGE_WEDGE: 73,\n  VTK_LAGRANGE_PYRAMID: 74,\n  VTK_NUMBER_OF_CELL_TYPES: 75\n};\n\n// This list should contain the cell class names in\n// the same order as in CellType.\nconst CellTypesStrings = ['vtkEmptyCell', 'vtkVertex', 'vtkPolyVertex', 'vtkLine', 'vtkPolyLine', 'vtkTriangle', 'vtkTriangleStrip', 'vtkPolygon', 'vtkPixel', 'vtkQuad', 'vtkTetra', 'vtkVoxel', 'vtkHexahedron', 'vtkWedge', 'vtkPyramid', 'vtkPentagonalPrism', 'vtkHexagonalPrism', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkQuadraticEdge', 'vtkQuadraticTriangle', 'vtkQuadraticQuad', 'vtkQuadraticTetra', 'vtkQuadraticHexahedron', 'vtkQuadraticWedge', 'vtkQuadraticPyramid', 'vtkBiQuadraticQuad', 'vtkTriQuadraticHexahedron', 'vtkQuadraticLinearQuad', 'vtkQuadraticLinearWedge', 'vtkBiQuadraticQuadraticWedge', 'vtkBiQuadraticQuadraticHexahedron', 'vtkBiQuadraticTriangle', 'vtkCubicLine', 'vtkQuadraticPolygon', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkConvexPointSet', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkParametricCurve', 'vtkParametricSurface', 'vtkParametricTriSurface', 'vtkParametricQuadSurface', 'vtkParametricTetraRegion', 'vtkParametricHexRegion', 'UnknownClass', 'UnknownClass', 'UnknownClass', 'vtkHigherOrderEdge', 'vtkHigherOrderTriangle', 'vtkHigherOrderQuad', 'vtkHigherOrderPolygon', 'vtkHigherOrderTetrahedron', 'vtkHigherOrderWedge', 'vtkHigherOrderPyramid', 'vtkHigherOrderHexahedron'];\nvar Constants = {\n  CellType,\n  CellTypesStrings\n};\n\nexport { CellType, CellTypesStrings, Constants as default };\n", "import { m as macro } from '../../macros2.js';\nimport { CellTypesStrings, CellType } from './CellTypes/Constants.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n/**\n * Given an int (as defined in vtkCellType.h) identifier for a class\n * return it's classname.\n */\nfunction getClassNameFromTypeId(typeId) {\n  return typeId < CellTypesStrings.length ? CellTypesStrings[typeId] : 'UnknownClass';\n}\n\n/**\n * Given a data object classname, return it's int identified (as\n * defined in vtkCellType.h)\n */\nfunction getTypeIdFromClassName(cellTypeString) {\n  return CellTypesStrings.findIndex(cellTypeString);\n}\n\n/**\n * This convenience method is a fast check to determine if a cell type\n * represents a linear or nonlinear cell.  This is generally much more\n * efficient than getting the appropriate vtkCell and checking its IsLinear\n * method.\n */\nfunction isLinear(type) {\n  return type < CellType.VTK_QUADRATIC_EDGE || type === CellType.VTK_CONVEX_POINT_SET || type === CellType.VTK_POLYHEDRON;\n}\nfunction hasSubCells(cellType) {\n  return cellType === CellType.VTK_TRIANGLE_STRIP || cellType === CellType.VTK_POLY_LINE || cellType === CellType.VTK_POLY_VERTEX;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  getClassNameFromTypeId,\n  getTypeIdFromClassName,\n  isLinear,\n  hasSubCells\n};\n\n// ----------------------------------------------------------------------------\n// vtkCellTypes methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCellTypes(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCellTypes');\n\n  /**\n   * Allocate memory for this array. Delete old storage only if necessary.\n   */\n  publicAPI.allocate = function () {\n    let sz = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 512;\n    let ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    model.size = sz > 0 ? sz : 1;\n    model.extend = ext > 0 ? ext : 1;\n    model.maxId = -1;\n    model.typeArray = new Uint8Array(sz);\n    model.locationArray = new Uint32Array(sz);\n  };\n\n  /**\n   * Add a cell at specified id.\n   */\n  publicAPI.insertCell = (cellId, type, loc) => {\n    model.typeArray[cellId] = type;\n    model.locationArray[cellId] = loc;\n    if (cellId > model.maxId) {\n      model.maxId = cellId;\n    }\n  };\n\n  /**\n   * Add a cell to the object in the next available slot.\n   */\n  publicAPI.insertNextCell = (type, loc) => {\n    publicAPI.insertCell(++model.maxId, type, loc);\n    return model.maxId;\n  };\n\n  /**\n   * Specify a group of cell types. This version is provided to maintain\n   * backwards compatibility and does a copy of the cellLocations\n   */\n  publicAPI.setCellTypes = (ncells, cellTypes, cellLocations) => {\n    model.size = ncells;\n    model.typeArray = cellTypes;\n    model.locationArray = cellLocations;\n    model.maxId = ncells - 1;\n  };\n\n  /**\n   * Return the location of the cell in the associated vtkCellArray.\n   */\n  publicAPI.getCellLocation = cellId => model.locationArray[cellId];\n\n  /**\n   * Delete cell by setting to nullptr cell type.\n   */\n  publicAPI.deleteCell = cellId => {\n    model.typeArray[cellId] = CellType.VTK_EMPTY_CELL;\n  };\n\n  /**\n   * Return the number of types in the list.\n   */\n  publicAPI.getNumberOfTypes = () => model.maxId + 1;\n\n  /**\n   * Return true if type specified is contained in list; false otherwise.\n   */\n  publicAPI.isType = type => {\n    const numTypes = publicAPI.getNumberOfTypes();\n    for (let i = 0; i < numTypes; ++i) {\n      if (type === publicAPI.getCellType(i)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Add the type specified to the end of the list. Range checking is performed.\n   */\n  publicAPI.insertNextType = type => publicAPI.insertNextCell(type, -1);\n\n  /**\n   * Return the type of cell.\n   */\n  publicAPI.getCellType = cellId => model.typeArray[cellId];\n\n  /**\n   * Reclaim any extra memory.\n   */\n  // TODO: publicAPI.squeeze = () =>  {};\n\n  /**\n   * Initialize object without releasing memory.\n   */\n  publicAPI.reset = () => {\n    model.maxId = -1;\n  };\n\n  /**\n   * Standard DeepCopy method.  Since this object contains no reference\n   * to other objects, there is no ShallowCopy.\n   */\n  publicAPI.deepCopy = src => {\n    publicAPI.allocate(src.getSize(), src.getExtend());\n    model.typeArray.set(src.getTypeArray());\n    model.locationArray.set(src.getLocationArray());\n    model.maxId = src.getMaxId();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // typeArray: null, // pointer to types array\n  // locationArray: null;   // pointer to array of offsets\n  size: 0,\n  // allocated size of data\n  maxId: -1,\n  // maximum index inserted thus far\n  extend: 1000 // grow array by this point\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['size', 'maxId', 'extend']);\n  macro.getArray(publicAPI, model, ['typeArray', 'locationArray']);\n  vtkCellTypes(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCellTypes');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellTypes$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkCellTypes$1 as default, extend, newInstance };\n", "const IntersectionState = {\n  NO_INTERSECTION: 0,\n  YES_INTERSECTION: 1,\n  ON_LINE: 2\n};\nvar Constants = {\n  IntersectionState\n};\n\nexport { IntersectionState, Constants as default };\n", "import { m as macro } from '../../macros2.js';\nimport vtkDataArray from './DataArray.js';\nimport { VtkDataTypes } from './DataArray/Constants.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nconst INVALID_BOUNDS = [1, -1, 1, -1, 1, -1];\n\n// ----------------------------------------------------------------------------\n// vtkPoints methods\n// ----------------------------------------------------------------------------\n\nfunction vtkPoints(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkPoints');\n\n  // Forwarding methods\n  publicAPI.getNumberOfPoints = publicAPI.getNumberOfTuples;\n  publicAPI.setNumberOfPoints = function (nbPoints) {\n    let dimension = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n    if (publicAPI.getNumberOfPoints() !== nbPoints) {\n      model.size = nbPoints * dimension;\n      model.values = macro.newTypedArray(model.dataType, model.size);\n      publicAPI.setNumberOfComponents(dimension);\n      publicAPI.modified();\n    }\n  };\n  publicAPI.setPoint = function (idx) {\n    for (var _len = arguments.length, xyz = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      xyz[_key - 1] = arguments[_key];\n    }\n    publicAPI.setTuple(idx, xyz);\n  };\n  publicAPI.getPoint = publicAPI.getTuple;\n  publicAPI.findPoint = publicAPI.findTuple;\n  publicAPI.insertNextPoint = (x, y, z) => publicAPI.insertNextTuple([x, y, z]);\n  publicAPI.getBounds = () => {\n    if (publicAPI.getNumberOfComponents() === 3) {\n      const xRange = publicAPI.getRange(0);\n      model.bounds[0] = xRange[0];\n      model.bounds[1] = xRange[1];\n      const yRange = publicAPI.getRange(1);\n      model.bounds[2] = yRange[0];\n      model.bounds[3] = yRange[1];\n      const zRange = publicAPI.getRange(2);\n      model.bounds[4] = zRange[0];\n      model.bounds[5] = zRange[1];\n      return model.bounds;\n    }\n    if (publicAPI.getNumberOfComponents() !== 2) {\n      vtkErrorMacro(`getBounds called on an array with components of\n        ${publicAPI.getNumberOfComponents()}`);\n      return INVALID_BOUNDS;\n    }\n    const xRange = publicAPI.getRange(0);\n    model.bounds[0] = xRange[0];\n    model.bounds[1] = xRange[1];\n    const yRange = publicAPI.getRange(1);\n    model.bounds[2] = yRange[0];\n    model.bounds[3] = yRange[1];\n    model.bounds[4] = 0;\n    model.bounds[5] = 0;\n    return model.bounds;\n  };\n\n  // Trigger the computation of bounds\n  publicAPI.computeBounds = publicAPI.getBounds;\n\n  // Initialize\n  publicAPI.setNumberOfComponents(model.numberOfComponents < 2 ? 3 : model.numberOfComponents);\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  empty: true,\n  numberOfComponents: 3,\n  dataType: VtkDataTypes.FLOAT,\n  bounds: [1, -1, 1, -1, 1, -1]\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkDataArray.extend(publicAPI, model, initialValues);\n  vtkPoints(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkPoints');\n\n// ----------------------------------------------------------------------------\n\nvar vtkPoints$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkPoints$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport { u as uninitializeBounds } from '../Core/Math/index.js';\nimport vtkPoints from '../Core/Points.js';\n\n// ----------------------------------------------------------------------------\n// vtkCell methods\n// ----------------------------------------------------------------------------\n\nfunction vtkCell(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkCell');\n  publicAPI.initialize = function (points) {\n    let pointIdsList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (!pointIdsList) {\n      model.points = points;\n      model.pointsIds = new Array(points.getNumberOfPoints());\n      for (let i = points.getNumberOfPoints() - 1; i >= 0; --i) {\n        model.pointsIds[i] = i;\n      }\n    } else {\n      model.pointsIds = pointIdsList;\n      let triangleData = model.points.getData();\n      if (triangleData.length !== 3 * model.pointsIds.length) {\n        triangleData = macro.newTypedArray(points.getDataType(), 3 * model.pointsIds.length);\n      }\n      const pointsData = points.getData();\n      model.pointsIds.forEach((pointId, index) => {\n        // const start = 3 * pointId;\n        // pointsData.set(p.subarray(start, start + 3), 3 * index);\n        let pointOffset = 3 * pointId;\n        let trianglePointOffset = 3 * index;\n        triangleData[trianglePointOffset] = pointsData[pointOffset];\n        triangleData[++trianglePointOffset] = pointsData[++pointOffset];\n        triangleData[++trianglePointOffset] = pointsData[++pointOffset];\n      });\n      model.points.setData(triangleData);\n    }\n  };\n  publicAPI.getBounds = () => {\n    const nbPoints = model.points.getNumberOfPoints();\n    const x = [];\n    if (nbPoints) {\n      model.points.getPoint(0, x);\n      model.bounds[0] = x[0];\n      model.bounds[1] = x[0];\n      model.bounds[2] = x[1];\n      model.bounds[3] = x[1];\n      model.bounds[4] = x[2];\n      model.bounds[5] = x[2];\n      for (let i = 1; i < nbPoints; i++) {\n        model.points.getPoint(i, x);\n        model.bounds[0] = x[0] < model.bounds[0] ? x[0] : model.bounds[0];\n        model.bounds[1] = x[0] > model.bounds[1] ? x[0] : model.bounds[1];\n        model.bounds[2] = x[1] < model.bounds[2] ? x[1] : model.bounds[2];\n        model.bounds[3] = x[1] > model.bounds[3] ? x[1] : model.bounds[3];\n        model.bounds[4] = x[2] < model.bounds[4] ? x[2] : model.bounds[4];\n        model.bounds[5] = x[2] > model.bounds[5] ? x[2] : model.bounds[5];\n      }\n    } else {\n      uninitializeBounds(model.bounds);\n    }\n    return model.bounds;\n  };\n  publicAPI.getLength2 = () => {\n    publicAPI.getBounds();\n    let length = 0.0;\n    let diff = 0;\n    for (let i = 0; i < 3; i++) {\n      diff = model.bounds[2 * i + 1] - model.bounds[2 * i];\n      length += diff * diff;\n    }\n    return length;\n  };\n  publicAPI.getParametricDistance = pcoords => {\n    let pDist;\n    let pDistMax = 0.0;\n    for (let i = 0; i < 3; i++) {\n      if (pcoords[i] < 0.0) {\n        pDist = -pcoords[i];\n      } else if (pcoords[i] > 1.0) {\n        pDist = pcoords[i] - 1.0;\n      } else {\n        // inside the cell in the parametric direction\n        pDist = 0.0;\n      }\n      if (pDist > pDistMax) {\n        pDistMax = pDist;\n      }\n    }\n    return pDistMax;\n  };\n  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();\n  publicAPI.deepCopy = cell => {\n    cell.initialize(model.points, model.pointsIds);\n  };\n  publicAPI.getCellDimension = () => {}; // virtual\n  publicAPI.intersectWithLine = (p1, p2, tol, t, x, pcoords, subId) => {}; // virtual\n  publicAPI.evaluatePosition = (x, closestPoint, subId, pcoords, dist2, weights) => {\n    macro.vtkErrorMacro('vtkCell.evaluatePosition is not implemented.');\n  }; // virtual\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  bounds: [-1, -1, -1, -1, -1, -1],\n  pointsIds: []\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  if (!model.points) {\n    model.points = vtkPoints.newInstance();\n  }\n  macro.get(publicAPI, model, ['points', 'pointsIds']);\n  vtkCell(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkCell');\n\n// ----------------------------------------------------------------------------\n\nvar vtkCell$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkCell$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport Constants from './Line/Constants.js';\nimport vtkCell from './Cell.js';\nimport { d as dot, e as distance2BetweenPoints, s as subtract, g as solveLinearSystem } from '../Core/Math/index.js';\nimport { quat } from 'gl-matrix';\n\nconst {\n  IntersectionState\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\nfunction distanceToLine(x, p1, p2) {\n  let closestPoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  const outObj = {\n    t: Number.MIN_VALUE,\n    distance: 0\n  };\n  const p21 = [];\n  let closest;\n  // Determine appropriate vector\n  p21[0] = p2[0] - p1[0];\n  p21[1] = p2[1] - p1[1];\n  p21[2] = p2[2] - p1[2];\n\n  // Get parametric location\n  const num = p21[0] * (x[0] - p1[0]) + p21[1] * (x[1] - p1[1]) + p21[2] * (x[2] - p1[2]);\n  const denom = dot(p21, p21);\n\n  // trying to avoid an expensive fabs\n  let tolerance = 1e-5 * num;\n  if (denom !== 0.0) {\n    outObj.t = num / denom;\n  }\n  if (tolerance < 0.0) {\n    tolerance = -tolerance;\n  }\n  if (-tolerance < denom && denom < tolerance) {\n    closest = p1;\n  } else if (denom <= 0.0 || outObj.t < 0.0) {\n    // If parametric coordinate is within 0<=p<=1, then the point is closest to\n    // the line.  Otherwise, it's closest to a point at the end of the line.\n    closest = p1;\n  } else if (outObj.t > 1.0) {\n    closest = p2;\n  } else {\n    closest = p21;\n    p21[0] = p1[0] + outObj.t * p21[0];\n    p21[1] = p1[1] + outObj.t * p21[1];\n    p21[2] = p1[2] + outObj.t * p21[2];\n  }\n  if (closestPoint) {\n    closestPoint[0] = closest[0];\n    closestPoint[1] = closest[1];\n    closestPoint[2] = closest[2];\n  }\n  outObj.distance = distance2BetweenPoints(closest, x);\n  return outObj;\n}\nfunction intersection(a1, a2, b1, b2, u, v) {\n  const a21 = [];\n  const b21 = [];\n  const b1a1 = [];\n  u[0] = 0.0;\n  v[0] = 0.0;\n\n  // Determine line vectors.\n  subtract(a2, a1, a21);\n  subtract(b2, b1, b21);\n  subtract(b1, a1, b1a1);\n\n  // Compute the system (least squares) matrix.\n  const A = [dot(a21, a21), -dot(a21, b21), -dot(a21, b21), dot(b21, b21)];\n\n  // Compute the least squares system constant term.\n  const c = [];\n  c[0] = dot(a21, b1a1);\n  c[1] = -dot(b21, b1a1);\n  // Solve the system of equations\n  if (solveLinearSystem(A, c, 2) === 0) {\n    // The lines are colinear. Therefore, one of the four endpoints is the\n    // point of closest approach\n    let minDist = Number.MAX_VALUE;\n    const p = [a1, a2, b1, b2];\n    const l1 = [b1, b1, a1, a1];\n    const l2 = [b2, b2, a2, a2];\n    [v[0], v[0], u[0], u[0]];\n    [u[0], u[0], v[0], v[0]];\n    let obj;\n    for (let i = 0; i < 4; i++) {\n      obj = distanceToLine(p[i], l1[i], l2[i]);\n      if (obj.distance < minDist) {\n        minDist = obj.distance;\n        obj.t;\n      }\n    }\n    return IntersectionState.ON_LINE;\n  }\n  u[0] = c[0];\n  v[0] = c[1];\n\n  // Check parametric coordinates for intersection.\n  if (u[0] >= 0.0 && u[0] <= 1.0 && v[0] >= 0.0 && v[0] <= 1.0) {\n    return IntersectionState.YES_INTERSECTION;\n  }\n  return IntersectionState.NO_INTERSECTION;\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  distanceToLine,\n  intersection\n};\n\n// ----------------------------------------------------------------------------\n// vtkLine methods\n// ----------------------------------------------------------------------------\n\nfunction vtkLine(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkLine');\n  function isBetweenPoints(t) {\n    return t >= 0.0 && t <= 1.0;\n  }\n  publicAPI.getCellDimension = () => 1;\n  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {\n    const outObj = {\n      intersect: 0,\n      t: Number.MAX_VALUE,\n      subId: 0,\n      betweenPoints: null\n    };\n    pcoords[1] = 0.0;\n    pcoords[2] = 0.0;\n    const projXYZ = [];\n    const a1 = [];\n    const a2 = [];\n    model.points.getPoint(0, a1);\n    model.points.getPoint(1, a2);\n    const u = [];\n    const v = [];\n    const intersect = intersection(p1, p2, a1, a2, u, v);\n    outObj.t = u[0];\n    outObj.betweenPoints = isBetweenPoints(outObj.t);\n    pcoords[0] = v[0];\n    if (intersect === IntersectionState.YES_INTERSECTION) {\n      // make sure we are within tolerance\n      for (let i = 0; i < 3; i++) {\n        x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);\n        projXYZ[i] = p1[i] + outObj.t * (p2[i] - p1[i]);\n      }\n      if (distance2BetweenPoints(x, projXYZ) <= tol * tol) {\n        outObj.intersect = 1;\n        return outObj;\n      }\n    } else {\n      let outDistance;\n      // check to see if it lies within tolerance\n      // one of the parametric coords must be outside 0-1\n      if (outObj.t < 0.0) {\n        outDistance = distanceToLine(p1, a1, a2, x);\n        if (outDistance.distance <= tol * tol) {\n          outObj.t = 0.0;\n          outObj.intersect = 1;\n          outObj.betweenPoints = true; // Intersection is near p1\n          return outObj;\n        }\n        return outObj;\n      }\n      if (outObj.t > 1.0) {\n        outDistance = distanceToLine(p2, a1, a2, x);\n        if (outDistance.distance <= tol * tol) {\n          outObj.t = 1.0;\n          outObj.intersect = 1;\n          outObj.betweenPoints = true; // Intersection is near p2\n          return outObj;\n        }\n        return outObj;\n      }\n      if (pcoords[0] < 0.0) {\n        pcoords[0] = 0.0;\n        outDistance = distanceToLine(a1, p1, p2, x);\n        outObj.t = outDistance.t;\n        if (outDistance.distance <= tol * tol) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        return outObj;\n      }\n      if (pcoords[0] > 1.0) {\n        pcoords[0] = 1.0;\n        outDistance = distanceToLine(a2, p1, p2, x);\n        outObj.t = outDistance.t;\n        if (outDistance.distance <= tol * tol) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        return outObj;\n      }\n    }\n    return outObj;\n  };\n  publicAPI.evaluateLocation = (pcoords, x, weights) => {\n    const a1 = [];\n    const a2 = [];\n    model.points.getPoint(0, a1);\n    model.points.getPoint(1, a2);\n    for (let i = 0; i < 3; i++) {\n      x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);\n    }\n    weights[0] = 1.0 - pcoords[0];\n    weights[1] = pcoords[0];\n  };\n  publicAPI.evaluateOrientation = (pcoords, q, weights) => {\n    if (model.orientations) {\n      quat.slerp(q, model.orientations[0], model.orientations[1], pcoords[0]);\n      weights[0] = 1.0 - pcoords[0];\n      weights[1] = pcoords[0];\n      return true;\n    }\n    return false;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  orientations: null // an array of two quat or null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['orientations']);\n  vtkLine(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkLine');\n\n// ----------------------------------------------------------------------------\n\nvar vtkLine$1 = {\n  newInstance,\n  extend,\n  ...STATIC,\n  ...Constants\n};\n\nexport { STATIC, vtkLine$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkCell from './Cell.js';\nimport { d as dot, j as cross, l as normalize, m as multiplyAccumulate, e as distance2BetweenPoints, o as determinant2x2 } from '../Core/Math/index.js';\nimport vtkLine from './Line.js';\nimport vtkPlane from './Plane.js';\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\nfunction computeNormalDirection(v1, v2, v3, n) {\n  // order is important!!! maintain consistency with triangle vertex order\n  const ax = v3[0] - v2[0];\n  const ay = v3[1] - v2[1];\n  const az = v3[2] - v2[2];\n  const bx = v1[0] - v2[0];\n  const by = v1[1] - v2[1];\n  const bz = v1[2] - v2[2];\n  n[0] = ay * bz - az * by;\n  n[1] = az * bx - ax * bz;\n  n[2] = ax * by - ay * bx;\n}\nfunction computeNormal(v1, v2, v3, n) {\n  computeNormalDirection(v1, v2, v3, n);\n  const length = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);\n  if (length !== 0.0) {\n    n[0] /= length;\n    n[1] /= length;\n    n[2] /= length;\n  }\n}\nfunction intersectWithTriangle(p1, q1, r1, p2, q2, r2) {\n  let tolerance = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1e-6;\n  let coplanar = false;\n  const pt1 = [];\n  const pt2 = [];\n  const surfaceId = [];\n  const n1 = [];\n  const n2 = [];\n\n  // Compute supporting plane normals.\n  computeNormal(p1, q1, r1, n1);\n  computeNormal(p2, q2, r2, n2);\n  const s1 = -dot(n1, p1);\n  const s2 = -dot(n2, p2);\n\n  // Compute signed distances of points p1, q1, r1 from supporting\n  // plane of second triangle.\n  const dist1 = [dot(n2, p1) + s2, dot(n2, q1) + s2, dot(n2, r1) + s2];\n\n  // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n  if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 1!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n  // Do the same for p2, q2, r2 and supporting plane of first\n  // triangle.\n  const dist2 = [dot(n1, p2) + s1, dot(n1, q2) + s1, dot(n1, r2) + s1];\n\n  // If signs of all points are the same, all the points lie on the\n  // same side of the supporting plane, and we can exit early.\n  if (dist2[0] * dist2[1] > tolerance && dist2[0] * dist2[2] > tolerance) {\n    // vtkDebugMacro(<<\"Same side supporting plane 2!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n  // Check for coplanarity of the supporting planes.\n  if (Math.abs(n1[0] - n2[0]) < 1e-9 && Math.abs(n1[1] - n2[1]) < 1e-9 && Math.abs(n1[2] - n2[2]) < 1e-9 && Math.abs(s1 - s2) < 1e-9) {\n    coplanar = true;\n    // vtkDebugMacro(<<\"Coplanar!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n\n  // There are more efficient ways to find the intersection line (if\n  // it exists), but this is clear enough.\n  const pts1 = [p1, q1, r1];\n  const pts2 = [p2, q2, r2];\n\n  // Find line of intersection (L = p + t*v) between two planes.\n  const n1n2 = dot(n1, n2);\n  const a = (s1 - s2 * n1n2) / (n1n2 * n1n2 - 1.0);\n  const b = (s2 - s1 * n1n2) / (n1n2 * n1n2 - 1.0);\n  const p = [a * n1[0] + b * n2[0], a * n1[1] + b * n2[1], a * n1[2] + b * n2[2]];\n  const v = cross(n1, n2, []);\n  normalize(v);\n  let index1 = 0;\n  let index2 = 0;\n  const t1 = [];\n  const t2 = [];\n  let ts1 = 50;\n  let ts2 = 50;\n  for (let i = 0; i < 3; i++) {\n    const id1 = i;\n    const id2 = (i + 1) % 3;\n\n    // Find t coordinate on line of intersection between two planes.\n    const val1 = vtkPlane.intersectWithLine(pts1[id1], pts1[id2], p2, n2);\n    if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {\n      if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {\n        ts1 = index1;\n      }\n      t1[index1++] = dot(val1.x, v) - dot(p, v);\n    }\n    const val2 = vtkPlane.intersectWithLine(pts2[id1], pts2[id2], p1, n1);\n    if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {\n      if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {\n        ts2 = index2;\n      }\n      t2[index2++] = dot(val2.x, v) - dot(p, v);\n    }\n  }\n\n  // If the value of the index is greater than 2, the intersecting point\n  // actually is intersected by all three edges. In this case, set the two\n  // edges to the two edges where the intersecting point is not the end point\n  if (index1 > 2) {\n    index1--;\n    // swap\n    const t12 = t1[2];\n    t1[2] = t1[ts1];\n    t1[ts1] = t12;\n  }\n  if (index2 > 2) {\n    index2--;\n    const t22 = t2[2];\n    t2[2] = t2[ts2];\n    t2[ts2] = t22;\n  }\n  // Check if only one edge or all edges intersect the supporting\n  // planes intersection.\n  if (index1 !== 2 || index2 !== 2) {\n    // vtkDebugMacro(<<\"Only one edge intersecting!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n\n  // Check for NaNs\n  if (Number.isNaN(t1[0]) || Number.isNaN(t1[1]) || Number.isNaN(t2[0]) || Number.isNaN(t2[1])) {\n    // vtkWarningMacro(<<\"NaNs!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    };\n  }\n  if (t1[0] > t1[1]) {\n    // swap\n    const t11 = t1[1];\n    t1[1] = t1[0];\n    t1[0] = t11;\n  }\n  if (t2[0] > t2[1]) {\n    // swap\n    const t21 = t2[1];\n    t2[1] = t2[0];\n    t2[0] = t21;\n  }\n  // Handle the different interval configuration cases.\n  let tt1;\n  let tt2;\n  if (t1[1] < t2[0] || t2[1] < t1[0]) {\n    // vtkDebugMacro(<<\"No Overlap!\");\n    return {\n      intersect: false,\n      coplanar,\n      pt1,\n      pt2,\n      surfaceId\n    }; // No overlap\n  }\n\n  if (t1[0] < t2[0]) {\n    if (t1[1] < t2[1]) {\n      // First point on surface 2, second point on surface 1\n      surfaceId[0] = 2;\n      surfaceId[1] = 1;\n      tt1 = t2[0];\n      tt2 = t1[1];\n    } else {\n      // Both points belong to lines on surface 2\n      surfaceId[0] = 2;\n      surfaceId[1] = 2;\n      tt1 = t2[0];\n      tt2 = t2[1];\n    }\n  } // t1[0] >= t2[0]\n  else if (t1[1] < t2[1]) {\n    // Both points belong to lines on surface 1\n    surfaceId[0] = 1;\n    surfaceId[1] = 1;\n    tt1 = t1[0];\n    tt2 = t1[1];\n  } else {\n    // First point on surface 1, second point on surface 2\n    surfaceId[0] = 1;\n    surfaceId[1] = 2;\n    tt1 = t1[0];\n    tt2 = t2[1];\n  }\n\n  // Create actual intersection points.\n  multiplyAccumulate(p, v, tt1, pt1);\n  multiplyAccumulate(p, v, tt2, pt2);\n  return {\n    intersect: true,\n    coplanar,\n    pt1,\n    pt2,\n    surfaceId\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {\n  computeNormalDirection,\n  computeNormal,\n  intersectWithTriangle\n};\n\n// ----------------------------------------------------------------------------\n// vtkTriangle methods\n// ----------------------------------------------------------------------------\n\nfunction vtkTriangle(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkTriangle');\n  publicAPI.getCellDimension = () => 2;\n  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {\n    const outObj = {\n      subId: 0,\n      t: Number.MAX_VALUE,\n      intersect: 0,\n      betweenPoints: false\n    };\n    pcoords[2] = 0.0;\n    const closestPoint = [];\n    const tol2 = tol * tol;\n\n    // Get normal for triangle\n    const pt1 = [];\n    const pt2 = [];\n    const pt3 = [];\n    model.points.getPoint(0, pt1);\n    model.points.getPoint(1, pt2);\n    model.points.getPoint(2, pt3);\n    const n = [];\n    const weights = [];\n    computeNormal(pt1, pt2, pt3, n);\n    if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {\n      // Intersect plane of triangle with line\n      const plane = vtkPlane.intersectWithLine(p1, p2, pt1, n);\n      outObj.betweenPoints = plane.betweenPoints;\n      outObj.t = plane.t;\n      x[0] = plane.x[0];\n      x[1] = plane.x[1];\n      x[2] = plane.x[2];\n      if (!plane.intersection) {\n        pcoords[0] = 0.0;\n        pcoords[1] = 0.0;\n        outObj.intersect = 0;\n        return outObj;\n      }\n\n      // Evaluate position\n      const inside = publicAPI.evaluatePosition(x, closestPoint, pcoords, weights);\n      if (inside.evaluation >= 0) {\n        if (inside.dist2 <= tol2) {\n          outObj.intersect = 1;\n          return outObj;\n        }\n        outObj.intersect = inside.evaluation;\n        return outObj;\n      }\n    }\n\n    // Normals are null, so the triangle is degenerated and\n    // we still need to check intersection between line and\n    // the longest edge.\n    const dist2Pt1Pt2 = distance2BetweenPoints(pt1, pt2);\n    const dist2Pt2Pt3 = distance2BetweenPoints(pt2, pt3);\n    const dist2Pt3Pt1 = distance2BetweenPoints(pt3, pt1);\n    if (!model.line) {\n      model.line = vtkLine.newInstance();\n    }\n    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {\n      model.line.getPoints().setPoint(0, pt1);\n      model.line.getPoints().setPoint(1, pt2);\n    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {\n      model.line.getPoints().setPoint(0, pt2);\n      model.line.getPoints().setPoint(1, pt3);\n    } else {\n      model.line.getPoints().setPoint(0, pt3);\n      model.line.getPoints().setPoint(1, pt1);\n    }\n    const intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);\n    outObj.betweenPoints = intersectLine.betweenPoints;\n    outObj.t = intersectLine.t;\n    if (intersectLine.intersect) {\n      const pt3Pt1 = [];\n      const pt3Pt2 = [];\n      const pt3X = [];\n      // Compute r and s manually, using dot and norm.\n      for (let i = 0; i < 3; i++) {\n        pt3Pt1[i] = pt1[i] - pt3[i];\n        pt3Pt2[i] = pt2[i] - pt3[i];\n        pt3X[i] = x[i] - pt3[i];\n      }\n      pcoords[0] = dot(pt3X, pt3Pt1) / dist2Pt3Pt1;\n      pcoords[1] = dot(pt3X, pt3Pt2) / dist2Pt2Pt3;\n      outObj.intersect = 1;\n      return outObj;\n    }\n    pcoords[0] = 0.0;\n    pcoords[1] = 0.0;\n    outObj.intersect = 0;\n    return outObj;\n  };\n  publicAPI.evaluatePosition = (x, closestPoint, pcoords, weights) => {\n    // will return obj\n    const outObj = {\n      subId: 0,\n      dist2: 0,\n      evaluation: -1\n    };\n    let i;\n    let j;\n    const pt1 = [];\n    const pt2 = [];\n    const pt3 = [];\n    const n = [];\n    let fabsn;\n    const rhs = [];\n    const c1 = [];\n    const c2 = [];\n    let det = 0;\n    let idx = 0;\n    const indices = [];\n    let dist2Point;\n    let dist2Line1;\n    let dist2Line2;\n    let closest = [];\n    const closestPoint1 = [];\n    const closestPoint2 = [];\n    const cp = [];\n    outObj.subId = 0;\n    pcoords[2] = 0.0;\n\n    // Get normal for triangle, only the normal direction is needed, i.e. the\n    // normal need not be normalized (unit length)\n    //\n    model.points.getPoint(1, pt1);\n    model.points.getPoint(2, pt2);\n    model.points.getPoint(0, pt3);\n    computeNormalDirection(pt1, pt2, pt3, n);\n\n    // Project point to plane\n    vtkPlane.generalizedProjectPoint(x, pt1, n, cp);\n\n    // Construct matrices.  Since we have over determined system, need to find\n    // which 2 out of 3 equations to use to develop equations. (Any 2 should\n    // work since we've projected point to plane.)\n    let maxComponent = 0.0;\n    for (i = 0; i < 3; i++) {\n      // trying to avoid an expensive call to fabs()\n      if (n[i] < 0) {\n        fabsn = -n[i];\n      } else {\n        fabsn = n[i];\n      }\n      if (fabsn > maxComponent) {\n        maxComponent = fabsn;\n        idx = i;\n      }\n    }\n    for (j = 0, i = 0; i < 3; i++) {\n      if (i !== idx) {\n        indices[j++] = i;\n      }\n    }\n    for (i = 0; i < 2; i++) {\n      rhs[i] = cp[indices[i]] - pt3[indices[i]];\n      c1[i] = pt1[indices[i]] - pt3[indices[i]];\n      c2[i] = pt2[indices[i]] - pt3[indices[i]];\n    }\n    det = determinant2x2(c1, c2);\n    if (det === 0.0) {\n      pcoords[0] = 0.0;\n      pcoords[1] = 0.0;\n      outObj.evaluation = -1;\n      return outObj;\n    }\n    pcoords[0] = determinant2x2(rhs, c2) / det;\n    pcoords[1] = determinant2x2(c1, rhs) / det;\n\n    // Okay, now find closest point to element\n    weights[0] = 1 - (pcoords[0] + pcoords[1]);\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n    if (weights[0] >= 0.0 && weights[0] <= 1.0 && weights[1] >= 0.0 && weights[1] <= 1.0 && weights[2] >= 0.0 && weights[2] <= 1.0) {\n      // projection distance\n      if (closestPoint) {\n        outObj.dist2 = distance2BetweenPoints(cp, x);\n        closestPoint[0] = cp[0];\n        closestPoint[1] = cp[1];\n        closestPoint[2] = cp[2];\n      }\n      outObj.evaluation = 1;\n    } else {\n      let t;\n      if (closestPoint) {\n        if (weights[1] < 0.0 && weights[2] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt3);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt3, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt3;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[2] < 0.0 && weights[0] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt1);\n          dist2Line1 = vtkLine.distanceToLine(x, pt1, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt1;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[1] < 0.0 && weights[0] < 0.0) {\n          dist2Point = distance2BetweenPoints(x, pt2);\n          dist2Line1 = vtkLine.distanceToLine(x, pt2, pt3, t, closestPoint1);\n          dist2Line2 = vtkLine.distanceToLine(x, pt1, pt2, t, closestPoint2);\n          if (dist2Point < dist2Line1) {\n            outObj.dist2 = dist2Point;\n            closest = pt2;\n          } else {\n            outObj.dist2 = dist2Line1;\n            closest = closestPoint1;\n          }\n          if (dist2Line2 < outObj.dist2) {\n            outObj.dist2 = dist2Line2;\n            closest = closestPoint2;\n          }\n          for (i = 0; i < 3; i++) {\n            closestPoint[i] = closest[i];\n          }\n        } else if (weights[0] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(x, pt1, pt2, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        } else if (weights[1] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(x, pt2, pt3, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        } else if (weights[2] < 0.0) {\n          const lineDistance = vtkLine.distanceToLine(x, pt1, pt3, closestPoint);\n          outObj.dist2 = lineDistance.distance;\n        }\n      }\n      outObj.evaluation = 0;\n    }\n    return outObj;\n  };\n  publicAPI.evaluateLocation = (pcoords, x, weights) => {\n    const p0 = [];\n    const p1 = [];\n    const p2 = [];\n    model.points.getPoint(0, p0);\n    model.points.getPoint(1, p1);\n    model.points.getPoint(2, p2);\n    const u3 = 1.0 - pcoords[0] - pcoords[1];\n    for (let i = 0; i < 3; i++) {\n      x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];\n    }\n    weights[0] = u3;\n    weights[1] = pcoords[0];\n    weights[2] = pcoords[1];\n  };\n  publicAPI.getParametricDistance = pcoords => {\n    let pDist;\n    let pDistMax = 0.0;\n    const pc = [];\n    pc[0] = pcoords[0];\n    pc[1] = pcoords[1];\n    pc[2] = 1.0 - pcoords[0] - pcoords[1];\n    for (let i = 0; i < 3; i++) {\n      if (pc[i] < 0.0) {\n        pDist = -pc[i];\n      } else if (pc[i] > 1.0) {\n        pDist = pc[i] - 1.0;\n      } else {\n        // inside the cell in the parametric direction\n        pDist = 0.0;\n      }\n      if (pDist > pDistMax) {\n        pDistMax = pDist;\n      }\n    }\n    return pDistMax;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  vtkCell.extend(publicAPI, model, initialValues);\n  vtkTriangle(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkTriangle');\n\n// ----------------------------------------------------------------------------\n\nvar vtkTriangle$1 = {\n  newInstance,\n  extend,\n  ...STATIC\n};\n\nexport { STATIC, vtkTriangle$1 as default, extend, newInstance };\n"],
  "mappings": "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",
  "names": ["xRange", "yRange", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "IntersectionState", "STATIC", "DEFAULT_VALUES", "extend", "newInstance", "STATIC", "DEFAULT_VALUES", "extend", "newInstance"]
}

{
  "version": 3,
  "sources": ["../../@kitware/vtk.js/Rendering/SceneGraph/ViewNodeFactory.js", "../../@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js", "../../@kitware/vtk.js/Rendering/OpenGL/Texture.js", "../../@kitware/vtk.js/Rendering/OpenGL/Texture/Constants.js", "../../@kitware/vtk.js/Common/Core/HalfFloat.js", "../../@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js", "../../@kitware/vtk.js/Rendering/OpenGL/Texture/supportsNorm16Linear.js", "../../@kitware/vtk.js/Rendering/OpenGL/Shader.js", "../../@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js", "../../@kitware/vtk.js/Rendering/OpenGL/BufferObject/Constants.js", "../../@kitware/vtk.js/Rendering/OpenGL/BufferObject.js", "../../@kitware/vtk.js/Rendering/OpenGL/CellArrayBufferObject/helpers.js", "../../@kitware/vtk.js/Rendering/OpenGL/CellArrayBufferObject.js", "../../@kitware/vtk.js/Rendering/OpenGL/VertexArrayObject.js", "../../@kitware/vtk.js/Rendering/OpenGL/Helper.js"],
  "sourcesContent": ["import { m as macro } from '../../macros2.js';\n\n// ----------------------------------------------------------------------------\n// vtkViewNodeFactory methods\n// ----------------------------------------------------------------------------\n\nfunction vtkViewNodeFactory(publicAPI, model) {\n  // Make sure our overrides is just for our instance not shared with everyone...\n  if (!model.overrides) {\n    model.overrides = {};\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkViewNodeFactory');\n  publicAPI.createNode = dataObject => {\n    if (dataObject.isDeleted()) {\n      return null;\n    }\n    let cpt = 0;\n    let className = dataObject.getClassName(cpt++);\n    let isObject = false;\n    const keys = Object.keys(model.overrides);\n    while (className && !isObject) {\n      if (keys.indexOf(className) !== -1) {\n        isObject = true;\n      } else {\n        className = dataObject.getClassName(cpt++);\n      }\n    }\n    if (!isObject) {\n      return null;\n    }\n    const vn = model.overrides[className]();\n    vn.setMyFactory(publicAPI);\n    return vn;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // overrides: {},\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n\n  // Object methods\n  vtkViewNodeFactory(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkViewNodeFactory');\n\n// ----------------------------------------------------------------------------\n\nvar vtkViewNodeFactory$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkViewNodeFactory$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkViewNodeFactory$1 from '../SceneGraph/ViewNodeFactory.js';\n\nconst CLASS_MAPPING = Object.create(null);\nfunction registerOverride(className, fn) {\n  CLASS_MAPPING[className] = fn;\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLViewNodeFactory methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLViewNodeFactory(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLViewNodeFactory');\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Static class mapping shared across instances\n  model.overrides = CLASS_MAPPING;\n\n  // Inheritance\n  vtkViewNodeFactory$1.extend(publicAPI, model, initialValues);\n\n  // Object methods\n  vtkOpenGLViewNodeFactory(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkOpenGLViewNodeFactory');\n\n// ----------------------------------------------------------------------------\n\nvar vtkViewNodeFactory = {\n  newInstance,\n  extend\n};\n\nexport { vtkViewNodeFactory as default, extend, newInstance, registerOverride };\n", "import DeepEqual from 'fast-deep-equal';\nimport Constants from './Texture/Constants.js';\nimport HalfFloat from '../../Common/Core/HalfFloat.js';\nimport { n as newInstance$1, o as obj, s as set, e as setGet, g as get, i as moveToProtected, a as newTypedArray, c as macro } from '../../macros2.js';\nimport vtkDataArray from '../../Common/Core/DataArray.js';\nimport { V as isPowerOfTwo, R as nearestPowerOfTwo } from '../../Common/Core/Math/index.js';\nimport vtkViewNode from '../SceneGraph/ViewNode.js';\nimport { registerOverride } from './ViewNodeFactory.js';\nimport supportsNorm16LinearCached from './Texture/supportsNorm16Linear.js';\n\nconst {\n  Wrap,\n  Filter\n} = Constants;\nconst {\n  VtkDataTypes\n} = vtkDataArray;\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\nconst {\n  toHalf\n} = HalfFloat;\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLTexture methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLTexture(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLTexture');\n  function getTexParams() {\n    return {\n      internalFormat: model.internalFormat,\n      format: model.format,\n      openGLDataType: model.openGLDataType,\n      width: model.width,\n      height: model.height\n    };\n  }\n\n  // Renders myself\n  publicAPI.render = function () {\n    let renWin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    if (renWin) {\n      model._openGLRenderWindow = renWin;\n    } else {\n      model._openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');\n      // sync renderable properties\n      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType('vtkOpenGLRenderWindow');\n    }\n    model.context = model._openGLRenderWindow.getContext();\n    if (model.renderable.getInterpolate()) {\n      if (model.generateMipmap) {\n        publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n      } else {\n        publicAPI.setMinificationFilter(Filter.LINEAR);\n      }\n      publicAPI.setMagnificationFilter(Filter.LINEAR);\n    } else {\n      publicAPI.setMinificationFilter(Filter.NEAREST);\n      publicAPI.setMagnificationFilter(Filter.NEAREST);\n    }\n    if (model.renderable.getRepeat()) {\n      publicAPI.setWrapR(Wrap.REPEAT);\n      publicAPI.setWrapS(Wrap.REPEAT);\n      publicAPI.setWrapT(Wrap.REPEAT);\n    }\n    // clear image if input data is set\n    if (model.renderable.getInputData()) {\n      model.renderable.setImage(null);\n    }\n    // create the texture if it is not done already\n    if (!model.handle || model.renderable.getMTime() > model.textureBuildTime.getMTime()) {\n      // if we have an Image\n      if (model.renderable.getImage() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        // Have an Image which may not be complete\n        if (model.renderable.getImage() && model.renderable.getImageLoaded()) {\n          publicAPI.create2DFromImage(model.renderable.getImage());\n          publicAPI.activate();\n          publicAPI.sendParameters();\n          model.textureBuildTime.modified();\n        }\n      }\n      // if we have a canvas\n      if (model.renderable.getCanvas() !== null) {\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        const canvas = model.renderable.getCanvas();\n        publicAPI.create2DFromRaw(canvas.width, canvas.height, 4, VtkDataTypes.UNSIGNED_CHAR, canvas, true);\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n      // if we have jsImageData\n      if (model.renderable.getJsImageData() !== null) {\n        const jsid = model.renderable.getJsImageData();\n        if (model.renderable.getInterpolate()) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        publicAPI.create2DFromRaw(jsid.width, jsid.height, 4, VtkDataTypes.UNSIGNED_CHAR, jsid.data, true);\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n      // if we have InputData\n      const input = model.renderable.getInputData(0);\n      if (input && input.getPointData().getScalars()) {\n        const ext = input.getExtent();\n        const inScalars = input.getPointData().getScalars();\n\n        // do we have a cube map? Six inputs\n        const data = [];\n        for (let i = 0; i < model.renderable.getNumberOfInputPorts(); ++i) {\n          const indata = model.renderable.getInputData(i);\n          const scalars = indata ? indata.getPointData().getScalars().getData() : null;\n          if (scalars) {\n            data.push(scalars);\n          }\n        }\n        if (model.renderable.getInterpolate() && inScalars.getNumberOfComponents() === 4) {\n          model.generateMipmap = true;\n          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);\n        }\n        if (data.length % 6 === 0) {\n          publicAPI.createCubeFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), data);\n        } else {\n          publicAPI.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());\n        }\n        publicAPI.activate();\n        publicAPI.sendParameters();\n        model.textureBuildTime.modified();\n      }\n    }\n    if (model.handle) {\n      publicAPI.activate();\n    }\n  };\n  const getNorm16Ext = () => {\n    if ((model.minificationFilter === Filter.LINEAR || model.magnificationFilter === Filter.LINEAR) && !supportsNorm16LinearCached()) {\n      return undefined;\n    }\n    return model.oglNorm16Ext;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.destroyTexture = () => {\n    // deactivate it first\n    publicAPI.deactivate();\n    if (model.context && model.handle) {\n      model.context.deleteTexture(model.handle);\n    }\n    model._prevTexParams = null;\n    model.handle = 0;\n    model.numberOfDimensions = 0;\n    model.target = 0;\n    model.components = 0;\n    model.width = 0;\n    model.height = 0;\n    model.depth = 0;\n    publicAPI.resetFormatAndType();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createTexture = () => {\n    // reuse the existing handle if we have one\n    if (!model.handle) {\n      model.handle = model.context.createTexture();\n      if (model.target) {\n        model.context.bindTexture(model.target, model.handle);\n\n        // See: http://www.openmodel.context..org/wiki/Common_Mistakes#Creating_a_complete_texture\n        // turn off mip map filter or set the base and max level correctly. here\n        // both are done.\n        model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));\n        model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));\n        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));\n        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));\n        if (model._openGLRenderWindow.getWebgl2()) {\n          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));\n        }\n        model.context.bindTexture(model.target, null);\n      }\n    }\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.getTextureUnit = () => {\n    if (model._openGLRenderWindow) {\n      return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);\n    }\n    return -1;\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.activate = () => {\n    // activate a free texture unit for this texture\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.bind();\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.deactivate = () => {\n    if (model._openGLRenderWindow) {\n      model._openGLRenderWindow.deactivateTexture(publicAPI);\n    }\n  };\n\n  //---------------------------------------------------------------------------\n  publicAPI.releaseGraphicsResources = rwin => {\n    if (rwin && model.handle) {\n      rwin.activateTexture(publicAPI);\n      rwin.deactivateTexture(publicAPI);\n      model.context.deleteTexture(model.handle);\n      model._prevTexParams = null;\n      model.handle = 0;\n      model.numberOfDimensions = 0;\n      model.target = 0;\n      model.internalFormat = 0;\n      model.format = 0;\n      model.openGLDataType = 0;\n      model.components = 0;\n      model.width = 0;\n      model.height = 0;\n      model.depth = 0;\n      model.allocatedGPUMemoryInBytes = 0;\n    }\n    if (model.shaderProgram) {\n      model.shaderProgram.releaseGraphicsResources(rwin);\n      model.shaderProgram = null;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.bind = () => {\n    model.context.bindTexture(model.target, model.handle);\n    if (model.autoParameters && publicAPI.getMTime() > model.sendParametersTime.getMTime()) {\n      publicAPI.sendParameters();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.isBound = () => {\n    let result = false;\n    if (model.context && model.handle) {\n      let target = 0;\n      switch (model.target) {\n        case model.context.TEXTURE_2D:\n          target = model.context.TEXTURE_BINDING_2D;\n          break;\n        default:\n          vtkWarningMacro('impossible case');\n          break;\n      }\n      const oid = model.context.getIntegerv(target);\n      result = oid === model.handle;\n    }\n    return result;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.sendParameters = () => {\n    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));\n    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));\n    }\n    model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));\n    model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));\n    if (model._openGLRenderWindow.getWebgl2()) {\n      model.context.texParameteri(model.target, model.context.TEXTURE_BASE_LEVEL, model.baseLevel);\n      model.context.texParameteri(model.target, model.context.TEXTURE_MAX_LEVEL, model.maxLevel);\n    }\n\n    // model.context.texParameterf(model.target, model.context.TEXTURE_MIN_LOD, model.minLOD);\n    // model.context.texParameterf(model.target, model.context.TEXTURE_MAX_LOD, model.maxLOD);\n\n    model.sendParametersTime.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getInternalFormat = (vtktype, numComps) => {\n    if (!model._forceInternalFormat) {\n      model.internalFormat = publicAPI.getDefaultInternalFormat(vtktype, numComps);\n    }\n    if (!model.internalFormat) {\n      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);\n    }\n    if ([model.context.R32F, model.context.RG32F, model.context.RGB32F, model.context.RGBA32F].includes(model.internalFormat) && !model.context.getExtension('OES_texture_float_linear')) {\n      vtkWarningMacro('Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats.');\n    }\n    return model.internalFormat;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultInternalFormat = (vtktype, numComps) => {\n    let result = 0;\n    // try default next\n    result = model._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, getNorm16Ext(), publicAPI.useHalfFloat());\n    if (result) {\n      return result;\n    }\n    if (!result) {\n      vtkDebugMacro('Unsupported internal texture type!');\n      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);\n    }\n    return result;\n  };\n  publicAPI.useHalfFloat = () => model.enableUseHalfFloat && model.canUseHalfFloat;\n\n  //----------------------------------------------------------------------------\n  publicAPI.setInternalFormat = iFormat => {\n    model._forceInternalFormat = true;\n    if (iFormat !== model.internalFormat) {\n      model.internalFormat = iFormat;\n      publicAPI.modified();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getFormat = (vtktype, numComps) => {\n    model.format = publicAPI.getDefaultFormat(vtktype, numComps);\n    return model.format;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultFormat = (vtktype, numComps) => {\n    if (model._openGLRenderWindow.getWebgl2()) {\n      switch (numComps) {\n        case 1:\n          return model.context.RED;\n        case 2:\n          return model.context.RG;\n        case 3:\n          return model.context.RGB;\n        case 4:\n          return model.context.RGBA;\n        default:\n          return model.context.RGB;\n      }\n    } else {\n      // webgl1\n      switch (numComps) {\n        case 1:\n          return model.context.LUMINANCE;\n        case 2:\n          return model.context.LUMINANCE_ALPHA;\n        case 3:\n          return model.context.RGB;\n        case 4:\n          return model.context.RGBA;\n        default:\n          return model.context.RGB;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.resetFormatAndType = () => {\n    model._prevTexParams = null;\n    model.format = 0;\n    model.internalFormat = 0;\n    model._forceInternalFormat = false;\n    model.openGLDataType = 0;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getDefaultDataType = vtkScalarType => {\n    const useHalfFloat = publicAPI.useHalfFloat();\n    // DON'T DEAL with VTK_CHAR as this is platform dependent.\n    if (model._openGLRenderWindow.getWebgl2()) {\n      switch (vtkScalarType) {\n        // case VtkDataTypes.SIGNED_CHAR:\n        //   return model.context.BYTE;\n        case VtkDataTypes.UNSIGNED_CHAR:\n          return model.context.UNSIGNED_BYTE;\n        // prefer norm16 since that is accurate compared to\n        // half float which is not\n        case getNorm16Ext() && !useHalfFloat && VtkDataTypes.SHORT:\n          return model.context.SHORT;\n        case getNorm16Ext() && !useHalfFloat && VtkDataTypes.UNSIGNED_SHORT:\n          return model.context.UNSIGNED_SHORT;\n        // use half float type\n        case useHalfFloat && VtkDataTypes.SHORT:\n          return model.context.HALF_FLOAT;\n        case useHalfFloat && VtkDataTypes.UNSIGNED_SHORT:\n          return model.context.HALF_FLOAT;\n        // case VtkDataTypes.INT:\n        //   return model.context.INT;\n        // case VtkDataTypes.UNSIGNED_INT:\n        //   return model.context.UNSIGNED_INT;\n        case VtkDataTypes.FLOAT:\n        case VtkDataTypes.VOID: // used for depth component textures.\n        default:\n          return model.context.FLOAT;\n      }\n    }\n    switch (vtkScalarType) {\n      // case VtkDataTypes.SIGNED_CHAR:\n      //   return model.context.BYTE;\n      case VtkDataTypes.UNSIGNED_CHAR:\n        return model.context.UNSIGNED_BYTE;\n      // case VtkDataTypes.SHORT:\n      //   return model.context.SHORT;\n      // case VtkDataTypes.UNSIGNED_SHORT:\n      //   return model.context.UNSIGNED_SHORT;\n      // case VtkDataTypes.INT:\n      //   return model.context.INT;\n      // case VtkDataTypes.UNSIGNED_INT:\n      //   return model.context.UNSIGNED_INT;\n      case VtkDataTypes.FLOAT:\n      case VtkDataTypes.VOID: // used for depth component textures.\n      default:\n        if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n          return model.context.FLOAT;\n        }\n        {\n          const halfFloat = model.context.getExtension('OES_texture_half_float');\n          if (halfFloat && model.context.getExtension('OES_texture_half_float_linear')) {\n            return halfFloat.HALF_FLOAT_OES;\n          }\n        }\n        return model.context.UNSIGNED_BYTE;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLDataType = function (vtkScalarType) {\n    let forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!model.openGLDataType || forceUpdate) {\n      model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType);\n    }\n    return model.openGLDataType;\n  };\n  publicAPI.getShiftAndScale = () => {\n    let shift = 0.0;\n    let scale = 1.0;\n\n    // for all float type internal formats\n    switch (model.openGLDataType) {\n      case model.context.BYTE:\n        scale = 127.5;\n        shift = scale - 128.0;\n        break;\n      case model.context.UNSIGNED_BYTE:\n        scale = 255.0;\n        shift = 0.0;\n        break;\n      case model.context.SHORT:\n        scale = 32767.5;\n        shift = scale - 32768.0;\n        break;\n      case model.context.UNSIGNED_SHORT:\n        scale = 65536.0;\n        shift = 0.0;\n        break;\n      case model.context.INT:\n        scale = 2147483647.5;\n        shift = scale - 2147483648.0;\n        break;\n      case model.context.UNSIGNED_INT:\n        scale = 4294967295.0;\n        shift = 0.0;\n        break;\n      case model.context.FLOAT:\n    }\n    return {\n      shift,\n      scale\n    };\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLFilterMode = emode => {\n    switch (emode) {\n      case Filter.NEAREST:\n        return model.context.NEAREST;\n      case Filter.LINEAR:\n        return model.context.LINEAR;\n      case Filter.NEAREST_MIPMAP_NEAREST:\n        return model.context.NEAREST_MIPMAP_NEAREST;\n      case Filter.NEAREST_MIPMAP_LINEAR:\n        return model.context.NEAREST_MIPMAP_LINEAR;\n      case Filter.LINEAR_MIPMAP_NEAREST:\n        return model.context.LINEAR_MIPMAP_NEAREST;\n      case Filter.LINEAR_MIPMAP_LINEAR:\n        return model.context.LINEAR_MIPMAP_LINEAR;\n      default:\n        return model.context.NEAREST;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getOpenGLWrapMode = vtktype => {\n    switch (vtktype) {\n      case Wrap.CLAMP_TO_EDGE:\n        return model.context.CLAMP_TO_EDGE;\n      case Wrap.REPEAT:\n        return model.context.REPEAT;\n      case Wrap.MIRRORED_REPEAT:\n        return model.context.MIRRORED_REPEAT;\n      default:\n        return model.context.CLAMP_TO_EDGE;\n    }\n  };\n\n  //----------------------------------------------------------------------------\n\n  /**\n   * Gets the extent's size.\n   * @param {Extent} extent\n   */\n  function getExtentSize(extent) {\n    const [xmin, xmax, ymin, ymax, zmin, zmax] = extent;\n    return [xmax - xmin + 1, ymax - ymin + 1, zmax - zmin + 1];\n  }\n\n  //----------------------------------------------------------------------------\n\n  /**\n   * Gets the number of pixels in the extent.\n   * @param {Extent} extent\n   */\n  function getExtentPixelCount(extent) {\n    const [sx, sy, sz] = getExtentSize(extent);\n    return sx * sy * sz;\n  }\n\n  //----------------------------------------------------------------------------\n\n  /**\n   * Reads a flattened extent from the image data and writes to the given output array.\n   *\n   * Assumes X varies the fastest and Z varies the slowest.\n   *\n   * @param {*} data\n   * @param {*} dataDims\n   * @param {Extent} extent\n   * @param {TypedArray} outArray\n   * @param {number} outOffset\n   * @returns\n   */\n  function readExtentIntoArray(data, dataDims, extent, outArray, outOffset) {\n    const [xmin, xmax, ymin, ymax, zmin, zmax] = extent;\n    const [dx, dy] = dataDims;\n    const sxy = dx * dy;\n    let writeOffset = outOffset;\n    for (let zi = zmin; zi <= zmax; zi++) {\n      const zOffset = zi * sxy;\n      for (let yi = ymin; yi <= ymax; yi++) {\n        const zyOffset = zOffset + yi * dx;\n        // explicit alternative to data.subarray,\n        // due to potential perf issues on v8\n        for (let readOffset = zyOffset + xmin, end = zyOffset + xmax; readOffset <= end; readOffset++, writeOffset++) {\n          outArray[writeOffset] = data[readOffset];\n        }\n      }\n    }\n  }\n\n  //----------------------------------------------------------------------------\n\n  /**\n   * Reads several image extents into a contiguous pixel array.\n   *\n   * @param {*} data\n   * @param {Extent[]} extent\n   * @param {TypedArrayConstructor} typedArrayConstructor optional typed array constructor\n   * @returns\n   */\n  function readExtents(data, extents) {\n    let typedArrayConstructor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    const constructor = typedArrayConstructor || data.constructor;\n    const numPixels = extents.reduce((count, extent) => count + getExtentPixelCount(extent), 0);\n    const extentPixels = new constructor(numPixels);\n    const dataDims = [model.width, model.height, model.depth];\n    let writeOffset = 0;\n    extents.forEach(extent => {\n      readExtentIntoArray(data, dataDims, extent, extentPixels, writeOffset);\n      writeOffset += getExtentPixelCount(extent);\n    });\n    return extentPixels;\n  }\n\n  //----------------------------------------------------------------------------\n\n  /**\n   * Updates the data array to match the required data type for OpenGL.\n   *\n   * This function takes the input data and converts it to the appropriate\n   * format required by the OpenGL texture, based on the specified data type.\n   *\n   * @param {string} dataType - The original data type of the input data.\n   * @param {Array} data - The input data array that needs to be updated.\n   * @param {boolean} [depth=false] - Indicates whether the data is a 3D array.\n   * @param {Array<Extent>} imageExtents only consider these image extents (default: [])\n   * @returns {Array} The updated data array that matches the OpenGL data type.\n   */\n  publicAPI.updateArrayDataTypeForGL = function (dataType, data) {\n    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let imageExtents = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    const pixData = [];\n    let pixCount = model.width * model.height * model.components;\n    if (depth) {\n      pixCount *= model.depth;\n    }\n    const onlyUpdateExtents = !!imageExtents.length;\n\n    // if the opengl data type is float\n    // then the data array must be float\n    if (dataType !== VtkDataTypes.FLOAT && model.openGLDataType === model.context.FLOAT) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          if (onlyUpdateExtents) {\n            pixData.push(readExtents(data[idx], imageExtents, Float32Array));\n          } else {\n            const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];\n            pixData.push(new Float32Array(dataArrayToCopy));\n          }\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // if the opengl data type is ubyte\n    // then the data array must be u8, we currently simply truncate the data\n    if (dataType !== VtkDataTypes.UNSIGNED_CHAR && model.openGLDataType === model.context.UNSIGNED_BYTE) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          if (onlyUpdateExtents) {\n            pixData.push(readExtents(data[idx], imageExtents, Uint8Array));\n          } else {\n            const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];\n            pixData.push(new Uint8Array(dataArrayToCopy));\n          }\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // if the opengl data type is half float\n    // then the data array must be u16\n    let halfFloat = false;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      halfFloat = model.openGLDataType === model.context.HALF_FLOAT;\n    } else {\n      const halfFloatExt = model.context.getExtension('OES_texture_half_float');\n      halfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;\n    }\n    if (halfFloat) {\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx]) {\n          const src = onlyUpdateExtents ? readExtents(data[idx], imageExtents) : data[idx];\n          const newArray = new Uint16Array(onlyUpdateExtents ? src.length : pixCount);\n          const newArrayLen = newArray.length;\n          for (let i = 0; i < newArrayLen; i++) {\n            newArray[i] = toHalf(src[i]);\n          }\n          pixData.push(newArray);\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // The output has to be filled\n    if (pixData.length === 0) {\n      for (let i = 0; i < data.length; i++) {\n        pixData.push(onlyUpdateExtents && data[i] ? readExtents(data[i], imageExtents) : data[i]);\n      }\n    }\n    return pixData;\n  };\n\n  //----------------------------------------------------------------------------\n  function scaleTextureToHighestPowerOfTwo(data) {\n    if (model._openGLRenderWindow.getWebgl2()) {\n      // No need if webGL2\n      return data;\n    }\n    const pixData = [];\n    const width = model.width;\n    const height = model.height;\n    const numComps = model.components;\n    if (data && (!isPowerOfTwo(width) || !isPowerOfTwo(height))) {\n      // Scale up the texture to the next highest power of two dimensions.\n      const halfFloat = model.context.getExtension('OES_texture_half_float');\n      const newWidth = nearestPowerOfTwo(width);\n      const newHeight = nearestPowerOfTwo(height);\n      const pixCount = newWidth * newHeight * model.components;\n      for (let idx = 0; idx < data.length; idx++) {\n        if (data[idx] !== null) {\n          let newArray = null;\n          const jFactor = height / newHeight;\n          const iFactor = width / newWidth;\n          let usingHalf = false;\n          if (model.openGLDataType === model.context.FLOAT) {\n            newArray = new Float32Array(pixCount);\n          } else if (halfFloat && model.openGLDataType === halfFloat.HALF_FLOAT_OES) {\n            newArray = new Uint16Array(pixCount);\n            usingHalf = true;\n          } else {\n            newArray = new Uint8Array(pixCount);\n          }\n          for (let j = 0; j < newHeight; j++) {\n            const joff = j * newWidth * numComps;\n            const jidx = j * jFactor;\n            let jlow = Math.floor(jidx);\n            let jhi = Math.ceil(jidx);\n            if (jhi >= height) {\n              jhi = height - 1;\n            }\n            const jmix = jidx - jlow;\n            const jmix1 = 1.0 - jmix;\n            jlow = jlow * width * numComps;\n            jhi = jhi * width * numComps;\n            for (let i = 0; i < newWidth; i++) {\n              const ioff = i * numComps;\n              const iidx = i * iFactor;\n              let ilow = Math.floor(iidx);\n              let ihi = Math.ceil(iidx);\n              if (ihi >= width) {\n                ihi = width - 1;\n              }\n              const imix = iidx - ilow;\n              ilow *= numComps;\n              ihi *= numComps;\n              for (let c = 0; c < numComps; c++) {\n                if (usingHalf) {\n                  newArray[joff + ioff + c] = HalfFloat.toHalf(HalfFloat.fromHalf(data[idx][jlow + ilow + c]) * jmix1 * (1.0 - imix) + HalfFloat.fromHalf(data[idx][jlow + ihi + c]) * jmix1 * imix + HalfFloat.fromHalf(data[idx][jhi + ilow + c]) * jmix * (1.0 - imix) + HalfFloat.fromHalf(data[idx][jhi + ihi + c]) * jmix * imix);\n                } else {\n                  newArray[joff + ioff + c] = data[idx][jlow + ilow + c] * jmix1 * (1.0 - imix) + data[idx][jlow + ihi + c] * jmix1 * imix + data[idx][jhi + ilow + c] * jmix * (1.0 - imix) + data[idx][jhi + ihi + c] * jmix * imix;\n                }\n              }\n            }\n          }\n          pixData.push(newArray);\n          model.width = newWidth;\n          model.height = newHeight;\n        } else {\n          pixData.push(null);\n        }\n      }\n    }\n\n    // The output has to be filled\n    if (pixData.length === 0) {\n      for (let i = 0; i < data.length; i++) {\n        pixData.push(data[i]);\n      }\n    }\n    return pixData;\n  }\n\n  //----------------------------------------------------------------------------\n  function useTexStorage(dataType) {\n    if (model._openGLRenderWindow) {\n      if (model.resizable || model.renderable?.getResizable()) {\n        // Cannot use texStorage if the texture is supposed to be resizable.\n        return false;\n      }\n      if (model._openGLRenderWindow.getWebgl2()) {\n        const webGLInfo = model._openGLRenderWindow.getGLInformations();\n        if (webGLInfo.RENDERER.value.match(/WebKit/gi) && navigator.platform.match(/Mac/gi) && getNorm16Ext() && (dataType === VtkDataTypes.UNSIGNED_SHORT || dataType === VtkDataTypes.SHORT)) {\n          // Cannot use texStorage with EXT_texture_norm16 textures on Mac M1 GPU.\n          // No errors reported but the texture is unusable.\n          return false;\n        }\n        // Use texStorage for WebGL2\n        return true;\n      }\n      return false;\n    }\n    return false;\n  }\n\n  //----------------------------------------------------------------------------\n  publicAPI.create2DFromRaw = function (width, height, numComps, dataType, data) {\n    let flip = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType, true);\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Create an array of texture with one texture\n    const dataArray = [data];\n    const pixData = publicAPI.updateArrayDataTypeForGL(dataType, dataArray);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // Source texture data from the PBO.\n    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (scaledData[0] != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, scaledData[0]);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, scaledData[0]);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n\n    // always reset the flip\n    if (flip) {\n      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, getNorm16Ext(), publicAPI.useHalfFloat());\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createCubeFromRaw = (width, height, numComps, dataType, data) => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    publicAPI.getInternalFormat(dataType, numComps);\n    publicAPI.getFormat(dataType, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_CUBE_MAP;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    model.maxLevel = data.length / 6 - 1;\n    publicAPI.createTexture();\n    publicAPI.bind();\n    const pixData = publicAPI.updateArrayDataTypeForGL(dataType, data);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // invert the data because opengl is messed up with cube maps\n    // and uses the old renderman standard with Y going down\n    // even though it is completely at odds with OpenGL standards\n    const invertedData = [];\n    let widthLevel = model.width;\n    let heightLevel = model.height;\n    for (let i = 0; i < scaledData.length; i++) {\n      if (i % 6 === 0 && i !== 0) {\n        widthLevel /= 2;\n        heightLevel /= 2;\n      }\n      invertedData[i] = newTypedArray(dataType, heightLevel * widthLevel * model.components);\n      for (let y = 0; y < heightLevel; ++y) {\n        const row1 = y * widthLevel * model.components;\n        const row2 = (heightLevel - y - 1) * widthLevel * model.components;\n        invertedData[i].set(scaledData[i].slice(row2, row2 + widthLevel * model.components), row1);\n      }\n    }\n\n    // Source texture data from the PBO.\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 6, model.internalFormat, model.width, model.height);\n    }\n    // We get the 6 images\n    for (let i = 0; i < 6; i++) {\n      // For each mipmap level\n      let j = 0;\n      let w = model.width;\n      let h = model.height;\n      while (w >= 1 && h >= 1) {\n        // In webgl 1, all levels need to be defined. So if the latest level size is\n        // 8x8, we have to add 3 more null textures (4x4, 2x2, 1x1)\n        // In webgl 2, the attribute maxLevel will be use.\n        let tempData = null;\n        if (j <= model.maxLevel) {\n          tempData = invertedData[6 * j + i];\n        }\n        if (useTexStorage(dataType)) {\n          if (tempData != null) {\n            model.context.texSubImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, w, h, model.format, model.openGLDataType, tempData);\n          }\n        } else {\n          model.context.texImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, model.internalFormat, w, h, 0, model.format, model.openGLDataType, tempData);\n        }\n        j++;\n        w /= 2;\n        h /= 2;\n      }\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, getNorm16Ext(), publicAPI.useHalfFloat());\n    // generateMipmap must not be called here because we manually upload all levels\n    // if it is called, all levels will be overwritten\n\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.createDepthFromRaw = (width, height, dataType, data) => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataType);\n    model.format = model.context.DEPTH_COMPONENT;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      if (dataType === VtkDataTypes.FLOAT) {\n        model.internalFormat = model.context.DEPTH_COMPONENT32F;\n      } else {\n        model.internalFormat = model.context.DEPTH_COMPONENT16;\n      }\n    } else {\n      model.internalFormat = model.context.DEPTH_COMPONENT;\n    }\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = 1;\n    model.width = width;\n    model.height = height;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataType)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (data != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, data);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, data);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, getNorm16Ext(), publicAPI.useHalfFloat());\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.create2DFromImage = image => {\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(VtkDataTypes.UNSIGNED_CHAR);\n    publicAPI.getInternalFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n    publicAPI.getFormat(VtkDataTypes.UNSIGNED_CHAR, 4);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_2D;\n    model.components = 4;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n\n    // Scale up the texture to the next highest power of two dimensions (if needed) and flip y.\n    const needNearestPowerOfTwo = !model._openGLRenderWindow.getWebgl2() && (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height));\n    const canvas = document.createElement('canvas');\n    canvas.width = needNearestPowerOfTwo ? nearestPowerOfTwo(image.width) : image.width;\n    canvas.height = needNearestPowerOfTwo ? nearestPowerOfTwo(image.height) : image.height;\n    model.width = canvas.width;\n    model.height = canvas.height;\n    const ctx = canvas.getContext('2d');\n    ctx.translate(0, canvas.height);\n    ctx.scale(1, -1);\n    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);\n    const safeImage = canvas;\n    if (useTexStorage(VtkDataTypes.UNSIGNED_CHAR)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (safeImage != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, safeImage);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, safeImage);\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(VtkDataTypes.UNSIGNED_CHAR, getNorm16Ext(), publicAPI.useHalfFloat());\n    publicAPI.deactivate();\n    return true;\n  };\n\n  // Compute scale and offset per component from min and max per component\n  function computeScaleOffsets(min, max, numComps) {\n    const offset = new Array(numComps);\n    const scale = new Array(numComps);\n    for (let c = 0; c < numComps; ++c) {\n      offset[c] = min[c];\n      scale[c] = max[c] - min[c] || 1.0;\n    }\n    return {\n      scale,\n      offset\n    };\n  }\n\n  // HalfFloat only represents numbers between [-2048, 2048] exactly accurate,\n  // for numbers outside of this range there is a precision limitation\n  function hasExactHalfFloat(offset, scale) {\n    // Per Component\n    for (let c = 0; c < offset.length; c++) {\n      const min = offset[c];\n      const max = scale[c] + min;\n      if (min < -2048 || min > 2048 || max < -2048 || max > 2048) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function setCanUseHalfFloat(dataType, offset, scale, preferSizeOverAccuracy) {\n    publicAPI.getOpenGLDataType(dataType);\n\n    // Don't consider halfFloat and convert back to Float when the range of data does not generate an accurate halfFloat\n    // AND it is not preferable to have a smaller texture than an exact texture.\n    const isExactHalfFloat = hasExactHalfFloat(offset, scale) || preferSizeOverAccuracy;\n    let useHalfFloat = false;\n    if (model._openGLRenderWindow.getWebgl2()) {\n      // If OES_texture_float_linear is not available, and using a half float would still be exact, force half floats\n      // This is because half floats are always texture filterable in webgl2, while full *32F floats are not (unless the extension is present)\n      const forceHalfFloat = model.openGLDataType === model.context.FLOAT && model.context.getExtension('OES_texture_float_linear') === null && isExactHalfFloat;\n      useHalfFloat = forceHalfFloat || model.openGLDataType === model.context.HALF_FLOAT;\n    } else {\n      const halfFloatExt = model.context.getExtension('OES_texture_half_float');\n      useHalfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;\n    }\n    model.canUseHalfFloat = useHalfFloat && isExactHalfFloat;\n  }\n  function processDataArray(dataArray, preferSizeOverAccuracy) {\n    const numComps = dataArray.getNumberOfComponents();\n    const dataType = dataArray.getDataType();\n    const data = dataArray.getData();\n\n    // Compute min max from array\n    // Using the vtkDataArray.getRange() enables caching\n    const minArray = new Array(numComps);\n    const maxArray = new Array(numComps);\n    for (let c = 0; c < numComps; ++c) {\n      const [min, max] = dataArray.getRange(c);\n      minArray[c] = min;\n      maxArray[c] = max;\n    }\n    const scaleOffsets = computeScaleOffsets(minArray, maxArray, numComps);\n\n    // preferSizeOverAccuracy will override norm16 due to bug with norm16 implementation\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=1408247\n    setCanUseHalfFloat(dataType, scaleOffsets.offset, scaleOffsets.scale, preferSizeOverAccuracy);\n\n    // since our default is to use half float, in case that we can't use it\n    // we need to use another type\n    if (!publicAPI.useHalfFloat()) {\n      publicAPI.getOpenGLDataType(dataType, true);\n    }\n    return {\n      numComps,\n      dataType,\n      data,\n      scaleOffsets\n    };\n  }\n  publicAPI.create2DFilterableFromRaw = function (width, height, numberOfComponents, dataType, values) {\n    let preferSizeOverAccuracy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    let ranges = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : undefined;\n    return publicAPI.create2DFilterableFromDataArray(width, height, vtkDataArray.newInstance({\n      numberOfComponents,\n      dataType,\n      values,\n      ranges\n    }), preferSizeOverAccuracy);\n  };\n  publicAPI.create2DFilterableFromDataArray = function (width, height, dataArray) {\n    let preferSizeOverAccuracy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const {\n      numComps,\n      dataType,\n      data\n    } = processDataArray(dataArray, preferSizeOverAccuracy);\n    publicAPI.create2DFromRaw(width, height, numComps, dataType, data);\n  };\n  publicAPI.updateVolumeInfoForGL = (dataType, numComps) => {\n    let isScalingApplied = false;\n    const useHalfFloat = publicAPI.useHalfFloat();\n\n    // Initialize volume info if it doesn't exist\n    if (!model.volumeInfo?.scale || !model.volumeInfo?.offset) {\n      model.volumeInfo = {\n        scale: new Array(numComps),\n        offset: new Array(numComps)\n      };\n    }\n\n    // Default scaling and offset\n    for (let c = 0; c < numComps; ++c) {\n      model.volumeInfo.scale[c] = 1.0;\n      model.volumeInfo.offset[c] = 0.0;\n    }\n\n    // Handle SHORT data type with EXT_texture_norm16 extension\n    if (getNorm16Ext() && !useHalfFloat && dataType === VtkDataTypes.SHORT) {\n      for (let c = 0; c < numComps; ++c) {\n        model.volumeInfo.scale[c] = 32767.0; // Scale to [-1, 1] range\n      }\n\n      isScalingApplied = true;\n    }\n\n    // Handle UNSIGNED_SHORT data type with EXT_texture_norm16 extension\n    if (getNorm16Ext() && !useHalfFloat && dataType === VtkDataTypes.UNSIGNED_SHORT) {\n      for (let c = 0; c < numComps; ++c) {\n        model.volumeInfo.scale[c] = 65535.0; // Scale to [0, 1] range\n      }\n\n      isScalingApplied = true;\n    }\n\n    // Handle UNSIGNED_CHAR data type\n    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {\n      for (let c = 0; c < numComps; ++c) {\n        model.volumeInfo.scale[c] = 255.0; // Scale to [0, 1] range\n      }\n\n      isScalingApplied = true;\n    }\n\n    // No scaling needed for FLOAT or HalfFloat (SHORT/UNSIGNED_SHORT)\n    if (dataType === VtkDataTypes.FLOAT || useHalfFloat && (dataType === VtkDataTypes.SHORT || dataType === VtkDataTypes.UNSIGNED_SHORT)) {\n      isScalingApplied = true;\n    }\n    return isScalingApplied;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.create3DFromRaw = function (width, height, depth, numComps, dataType, data) {\n    let updatedExtents = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n    let dataTypeToUse = dataType;\n    let dataToUse = data;\n    if (!publicAPI.updateVolumeInfoForGL(dataTypeToUse, numComps) && dataToUse) {\n      const numPixelsIn = width * height * depth;\n      const scaleOffsetsCopy = structuredClone(model.volumeInfo);\n      // otherwise convert to float\n      const newArray = new Float32Array(numPixelsIn * numComps);\n      // use computed scale and offset\n      model.volumeInfo.offset = scaleOffsetsCopy.offset;\n      model.volumeInfo.scale = scaleOffsetsCopy.scale;\n      let count = 0;\n      const scaleInverse = scaleOffsetsCopy.scale.map(s => 1 / s);\n      for (let i = 0; i < numPixelsIn; i++) {\n        for (let nc = 0; nc < numComps; nc++) {\n          newArray[count] = (dataToUse[count] - scaleOffsetsCopy.offset[nc]) * scaleInverse[nc];\n          count++;\n        }\n      }\n      dataTypeToUse = VtkDataTypes.FLOAT;\n      dataToUse = newArray;\n    }\n\n    // Permit OpenGLDataType to be half float, if applicable, for 3D\n    publicAPI.getOpenGLDataType(dataTypeToUse);\n\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getInternalFormat(dataTypeToUse, numComps);\n    publicAPI.getFormat(dataTypeToUse, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n    model.target = model.context.TEXTURE_3D;\n    model.components = numComps;\n    model.width = width;\n    model.height = height;\n    model.depth = depth;\n    model.numberOfDimensions = 3;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n    const hasUpdatedExtents = updatedExtents.length > 0;\n\n    // It's possible for the texture parameters to change while\n    // streaming, so check for such a change.\n    const rebuildEntireTexture = !hasUpdatedExtents || !DeepEqual(model._prevTexParams, getTexParams());\n\n    // Create an array of texture with one texture\n    const dataArray = [dataToUse];\n    const is3DArray = true;\n    const pixData = publicAPI.updateArrayDataTypeForGL(dataTypeToUse, dataArray, is3DArray, rebuildEntireTexture ? [] : updatedExtents);\n    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (rebuildEntireTexture) {\n      if (useTexStorage(dataTypeToUse)) {\n        model.context.texStorage3D(model.target, 1, model.internalFormat, model.width, model.height, model.depth);\n        if (scaledData[0] != null) {\n          model.context.texSubImage3D(model.target, 0, 0, 0, 0, model.width, model.height, model.depth, model.format, model.openGLDataType, scaledData[0]);\n        }\n      } else {\n        model.context.texImage3D(model.target, 0, model.internalFormat, model.width, model.height, model.depth, 0, model.format, model.openGLDataType, scaledData[0]);\n      }\n      model._prevTexParams = getTexParams();\n    } else if (hasUpdatedExtents) {\n      const extentPixels = scaledData[0];\n      let readOffset = 0;\n      for (let i = 0; i < updatedExtents.length; i++) {\n        const extent = updatedExtents[i];\n        const extentSize = getExtentSize(extent);\n        const extentPixelCount = getExtentPixelCount(extent);\n        const textureData = new extentPixels.constructor(extentPixels.buffer, readOffset, extentPixelCount);\n        readOffset += textureData.byteLength;\n        model.context.texSubImage3D(model.target, 0, extent[0], extent[2], extent[4], extentSize[0], extentSize[1], extentSize[2], model.format, model.openGLDataType, textureData);\n      }\n    }\n    if (model.generateMipmap) {\n      model.context.generateMipmap(model.target);\n    }\n    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataTypeToUse, getNorm16Ext(), publicAPI.useHalfFloat());\n    publicAPI.deactivate();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  // This method simulates a 3D texture using 2D\n  // Prefer create3DFilterableFromDataArray to enable caching of min and max values\n  publicAPI.create3DFilterableFromRaw = function (width, height, depth, numberOfComponents, dataType, values) {\n    let preferSizeOverAccuracy = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n    let ranges = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : undefined;\n    let updatedExtents = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];\n    return publicAPI.create3DFilterableFromDataArray(width, height, depth, vtkDataArray.newInstance({\n      numberOfComponents,\n      dataType,\n      values,\n      ranges\n    }), preferSizeOverAccuracy, updatedExtents);\n  };\n\n  //----------------------------------------------------------------------------\n  // This method create a 3D texture from dimensions and a DataArray\n  publicAPI.create3DFilterableFromDataArray = function (width, height, depth, dataArray) {\n    let preferSizeOverAccuracy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    let updatedExtents = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n    const {\n      numComps,\n      dataType,\n      data,\n      scaleOffsets\n    } = processDataArray(dataArray, preferSizeOverAccuracy);\n    const offset = [];\n    const scale = [];\n    for (let c = 0; c < numComps; ++c) {\n      offset[c] = 0.0;\n      scale[c] = 1.0;\n    }\n\n    // store the information, we will need it later\n    // offset and scale are the offset and scale required to get\n    // the texture value back to data values ala\n    // data = texture * scale + offset\n    // and texture = (data - offset)/scale\n    model.volumeInfo = {\n      scale,\n      offset,\n      dataComputedScale: scaleOffsets.scale,\n      dataComputedOffset: scaleOffsets.offset,\n      width,\n      height,\n      depth\n    };\n\n    // Create a copy of scale and offset to avoid aliasing issues\n    // Original is read only, copy is read/write\n    // Use the copy as volumeInfo.scale and volumeInfo.offset\n\n    // WebGL2 path, we have 3d textures etc\n    if (model._openGLRenderWindow.getWebgl2()) {\n      return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data, updatedExtents);\n    }\n    const numPixelsIn = width * height * depth;\n    const scaleOffsetsCopy = structuredClone(scaleOffsets);\n\n    // not webgl2, deal with webgl1, no 3d textures\n    // and maybe no float textures\n\n    let volCopyData = (outArray, outIdx, inValue, smin, smax) => {\n      outArray[outIdx] = inValue;\n    };\n    let dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;\n    // unsigned char gets used as is\n    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {\n      for (let c = 0; c < numComps; ++c) {\n        scaleOffsetsCopy.offset[c] = 0.0;\n        scaleOffsetsCopy.scale[c] = 255.0;\n      }\n    } else if (model.context.getExtension('OES_texture_float') && model.context.getExtension('OES_texture_float_linear')) {\n      // use float textures scaled to 0.0 to 1.0\n      dataTypeToUse = VtkDataTypes.FLOAT;\n      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {\n        outArray[outIdx] = (inValue - soffset) / sscale;\n      };\n    } else {\n      // worst case, scale data to uchar\n      dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;\n      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {\n        outArray[outIdx] = 255.0 * (inValue - soffset) / sscale;\n      };\n    }\n\n    // Now determine the texture parameters using the arguments.\n    publicAPI.getOpenGLDataType(dataTypeToUse);\n    publicAPI.getInternalFormat(dataTypeToUse, numComps);\n    publicAPI.getFormat(dataTypeToUse, numComps);\n    if (!model.internalFormat || !model.format || !model.openGLDataType) {\n      vtkErrorMacro('Failed to determine texture parameters.');\n      return false;\n    }\n\n    // have to pack this 3D texture into pot 2D texture\n    model.target = model.context.TEXTURE_2D;\n    model.components = numComps;\n    model.depth = 1;\n    model.numberOfDimensions = 2;\n\n    // MAX_TEXTURE_SIZE gives the max dimensions that can be supported by the GPU,\n    // but it doesn't mean it will fit in memory. If we have to use a float data type\n    // or 4 components, there are good chances that the texture size will blow up\n    // and could not fit in the GPU memory. Use a smaller texture size in that case,\n    // which will force a downsampling of the dataset.\n    // That problem does not occur when using webGL2 since we can pack the data in\n    // denser textures based on our data type.\n    // TODO: try to fit in the biggest supported texture, catch the gl error if it\n    // does not fix (OUT_OF_MEMORY), then attempt with smaller texture\n    let maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);\n    if (maxTexDim > 4096 && (dataTypeToUse === VtkDataTypes.FLOAT || numComps >= 3)) {\n      maxTexDim = 4096;\n    }\n\n    // compute estimate for XY subsample\n    let xstride = 1;\n    let ystride = 1;\n    if (numPixelsIn > maxTexDim * maxTexDim) {\n      xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));\n      ystride = xstride;\n    }\n    let targetWidth = Math.sqrt(numPixelsIn) / xstride;\n    targetWidth = nearestPowerOfTwo(targetWidth);\n    // determine X reps\n    const xreps = Math.floor(targetWidth * xstride / width);\n    const yreps = Math.ceil(depth / xreps);\n    const targetHeight = nearestPowerOfTwo(height * yreps / ystride);\n    model.width = targetWidth;\n    model.height = targetHeight;\n    model._openGLRenderWindow.activateTexture(publicAPI);\n    publicAPI.createTexture();\n    publicAPI.bind();\n\n    // store the information, we will need it later\n    model.volumeInfo.xreps = xreps;\n    model.volumeInfo.yreps = yreps;\n    model.volumeInfo.xstride = xstride;\n    model.volumeInfo.ystride = ystride;\n    model.volumeInfo.offset = scaleOffsetsCopy.offset;\n    model.volumeInfo.scale = scaleOffsetsCopy.scale;\n\n    // OK stuff the data into the 2d TEXTURE\n\n    // first allocate the new texture\n    let newArray;\n    const pixCount = targetWidth * targetHeight * numComps;\n    if (dataTypeToUse === VtkDataTypes.FLOAT) {\n      newArray = new Float32Array(pixCount);\n    } else {\n      newArray = new Uint8Array(pixCount);\n    }\n\n    // then stuff the data into it, nothing fancy right now\n    // for stride\n    let outIdx = 0;\n    const tileWidth = Math.floor(width / xstride);\n    const tileHeight = Math.floor(height / ystride);\n    for (let yRep = 0; yRep < yreps; yRep++) {\n      const xrepsThisRow = Math.min(xreps, depth - yRep * xreps);\n      const outXContIncr = numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));\n      for (let tileY = 0; tileY < tileHeight; tileY++) {\n        for (let xRep = 0; xRep < xrepsThisRow; xRep++) {\n          const inOffset = numComps * ((yRep * xreps + xRep) * width * height + ystride * tileY * width);\n          for (let tileX = 0; tileX < tileWidth; tileX++) {\n            // copy value\n            for (let nc = 0; nc < numComps; nc++) {\n              volCopyData(newArray, outIdx, data[inOffset + xstride * tileX * numComps + nc], scaleOffsetsCopy.offset[nc], scaleOffsetsCopy.scale[nc]);\n              outIdx++;\n            }\n          }\n        }\n        outIdx += outXContIncr;\n      }\n    }\n\n    // Source texture data from the PBO.\n    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);\n    if (useTexStorage(dataTypeToUse)) {\n      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);\n      if (newArray != null) {\n        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, newArray);\n      }\n    } else {\n      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, newArray);\n    }\n    publicAPI.deactivate();\n    return true;\n  };\n  publicAPI.setOpenGLRenderWindow = rw => {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getMaximumTextureSize = ctx => {\n    if (ctx && ctx.isCurrent()) {\n      return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);\n    }\n    return -1;\n  };\n\n  // set use half float\n  publicAPI.enableUseHalfFloat = use => {\n    model.enableUseHalfFloat = use;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  _openGLRenderWindow: null,\n  _forceInternalFormat: false,\n  _prevTexParams: null,\n  context: null,\n  handle: 0,\n  sendParametersTime: null,\n  textureBuildTime: null,\n  numberOfDimensions: 0,\n  target: 0,\n  format: 0,\n  openGLDataType: 0,\n  components: 0,\n  width: 0,\n  height: 0,\n  depth: 0,\n  autoParameters: true,\n  wrapS: Wrap.CLAMP_TO_EDGE,\n  wrapT: Wrap.CLAMP_TO_EDGE,\n  wrapR: Wrap.CLAMP_TO_EDGE,\n  minificationFilter: Filter.NEAREST,\n  magnificationFilter: Filter.NEAREST,\n  minLOD: -1000.0,\n  maxLOD: 1000.0,\n  baseLevel: 0,\n  maxLevel: 1000,\n  generateMipmap: false,\n  oglNorm16Ext: null,\n  allocatedGPUMemoryInBytes: 0,\n  // by default it is enabled\n  enableUseHalfFloat: true,\n  // but by default we don't know if we can use half float base on the data range\n  canUseHalfFloat: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkViewNode.extend(publicAPI, model, initialValues);\n  model.sendParametersTime = {};\n  obj(model.sendParametersTime, {\n    mtime: 0\n  });\n  model.textureBuildTime = {};\n  obj(model.textureBuildTime, {\n    mtime: 0\n  });\n\n  // Build VTK API\n  set(publicAPI, model, ['format', 'openGLDataType']);\n  setGet(publicAPI, model, ['keyMatrixTime', 'minificationFilter', 'magnificationFilter', 'wrapS', 'wrapT', 'wrapR', 'generateMipmap', 'oglNorm16Ext']);\n  get(publicAPI, model, ['width', 'height', 'volumeInfo', 'components', 'handle', 'target', 'allocatedGPUMemoryInBytes']);\n  moveToProtected(publicAPI, model, ['openGLRenderWindow']);\n\n  // Object methods\n  vtkOpenGLTexture(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = newInstance$1(extend, 'vtkOpenGLTexture');\n\n// ----------------------------------------------------------------------------\n\nvar vtkOpenGLTexture$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\n// Register ourself to OpenGL backend if imported\nregisterOverride('vtkTexture', newInstance);\n\nexport { vtkOpenGLTexture$1 as default, extend, newInstance };\n", "const Wrap = {\n  CLAMP_TO_EDGE: 0,\n  REPEAT: 1,\n  MIRRORED_REPEAT: 2\n};\nconst Filter = {\n  NEAREST: 0,\n  LINEAR: 1,\n  NEAREST_MIPMAP_NEAREST: 2,\n  NEAREST_MIPMAP_LINEAR: 3,\n  LINEAR_MIPMAP_NEAREST: 4,\n  LINEAR_MIPMAP_LINEAR: 5\n};\nvar Constants = {\n  Wrap,\n  Filter\n};\n\nexport { Filter, Wrap, Constants as default };\n", "/* eslint-disable no-bitwise */\n\nconst floatView = new Float32Array(1);\nconst int32View = new Int32Array(floatView.buffer);\n\n/* eslint-disable no-bitwise */\n/* This method is faster than the OpenEXR implementation (very often\n * used, eg. in Ogre), with the additional benefit of rounding, inspired\n * by James Tursa?s half-precision code. */\nfunction toHalf(val) {\n  floatView[0] = val;\n  const x = int32View[0];\n  let bits = x >> 16 & 0x8000; /* Get the sign */\n  let m = x >> 12 & 0x07ff; /* Keep one extra bit for rounding */\n  const e = x >> 23 & 0xff; /* Using int is faster here */\n\n  /* If zero, or denormal, or exponent underflows too much for a denormal\n   * half, return signed zero. */\n  if (e < 103) {\n    return bits;\n  }\n\n  /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n  if (e > 142) {\n    bits |= 0x7c00;\n    /* If exponent was 0xff and one mantissa bit was set, it means NaN,\n     * not Inf, so make sure we set one mantissa bit too. */\n    bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;\n    return bits;\n  }\n\n  /* If exponent underflows but not too much, return a denormal */\n  if (e < 113) {\n    m |= 0x0800;\n    /* Extra rounding may overflow and set mantissa to 0 and exponent\n     * to 1, which is OK. */\n    bits |= (m >> 114 - e) + (m >> 113 - e & 1);\n    return bits;\n  }\n  bits |= e - 112 << 10 | m >> 1;\n  /* Extra rounding. An overflow will set mantissa to 0 and increment\n   * the exponent, which is OK. */\n  bits += m & 1;\n  return bits;\n}\nfunction fromHalf(h) {\n  const s = (h & 0x8000) >> 15;\n  const e = (h & 0x7c00) >> 10;\n  const f = h & 0x03ff;\n  if (e === 0) {\n    return (s ? -1 : 1) * 2 ** -14 * (f / 2 ** 10);\n  }\n  if (e === 0x1f) {\n    return f ? NaN : (s ? -1 : 1) * Infinity;\n  }\n  return (s ? -1 : 1) * 2 ** (e - 15) * (1 + f / 2 ** 10);\n}\nvar HalfFloat = {\n  fromHalf,\n  toHalf\n};\n\nexport { HalfFloat as default };\n", "import { m as macro } from '../../macros2.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\nconst PASS_TYPES = ['Build', 'Render'];\n\n// ----------------------------------------------------------------------------\n// vtkViewNode methods\n// ----------------------------------------------------------------------------\n\nfunction vtkViewNode(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkViewNode');\n\n  // Builds myself.\n  publicAPI.build = prepass => {};\n\n  // Renders myself\n  publicAPI.render = prepass => {};\n  publicAPI.traverse = renderPass => {\n    // we can choose to do special\n    // traversal here based on pass\n    const passTraversal = renderPass.getTraverseOperation();\n    const fn = publicAPI[passTraversal];\n    if (fn) {\n      fn(renderPass);\n      return;\n    }\n\n    // default traversal\n    publicAPI.apply(renderPass, true);\n    for (let index = 0; index < model.children.length; index++) {\n      model.children[index].traverse(renderPass);\n    }\n    publicAPI.apply(renderPass, false);\n  };\n  publicAPI.apply = (renderPass, prepass) => {\n    const customRenderPass = publicAPI[renderPass.getOperation()];\n    if (customRenderPass) {\n      customRenderPass(prepass, renderPass);\n    }\n  };\n  publicAPI.getViewNodeFor = dataObject => {\n    if (model.renderable === dataObject) {\n      return publicAPI;\n    }\n    for (let index = 0; index < model.children.length; ++index) {\n      const child = model.children[index];\n      const vn = child.getViewNodeFor(dataObject);\n      if (vn) {\n        return vn;\n      }\n    }\n    return undefined;\n  };\n  publicAPI.getFirstAncestorOfType = type => {\n    if (!model._parent) {\n      return null;\n    }\n    if (model._parent.isA(type)) {\n      return model._parent;\n    }\n    return model._parent.getFirstAncestorOfType(type);\n  };\n  publicAPI.getLastAncestorOfType = type => {\n    if (!model._parent) {\n      return null;\n    }\n    const lastAncestor = model._parent.getLastAncestorOfType(type);\n    if (lastAncestor) {\n      return lastAncestor;\n    }\n    if (model._parent.isA(type)) {\n      return model._parent;\n    }\n    return null;\n  };\n\n  // add a missing node/child for the passed in renderables. This should\n  // be called only in between prepareNodes and removeUnusedNodes\n  publicAPI.addMissingNode = dobj => {\n    if (!dobj) {\n      return undefined;\n    }\n\n    // if found just mark as visited\n    const result = model._renderableChildMap.get(dobj);\n    if (result !== undefined) {\n      result.setVisited(true);\n      return result;\n    }\n\n    // otherwise create a node\n    const newNode = publicAPI.createViewNode(dobj);\n    if (newNode) {\n      newNode.setParent(publicAPI);\n      newNode.setVisited(true);\n      model._renderableChildMap.set(dobj, newNode);\n      model.children.push(newNode);\n      return newNode;\n    }\n    return undefined;\n  };\n\n  // add missing nodes/children for the passed in renderables. This should\n  // be called only in between prepareNodes and removeUnusedNodes\n  publicAPI.addMissingNodes = function (dataObjs) {\n    let enforceOrder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!dataObjs || !dataObjs.length) {\n      return;\n    }\n    for (let index = 0; index < dataObjs.length; ++index) {\n      const dobj = dataObjs[index];\n      const node = publicAPI.addMissingNode(dobj);\n      if (enforceOrder && node !== undefined && model.children[index] !== node) {\n        for (let i = index + 1; i < model.children.length; ++i) {\n          if (model.children[i] === node) {\n            model.children.splice(i, 1);\n            model.children.splice(index, 0, node);\n            break;\n          }\n        }\n      }\n    }\n  };\n\n  // ability to add children that have no renderable use in the same manner\n  // as addMissingNodes This case is when a normal viewnode wants to\n  // delegate passes to a helper or child that doeasn't map to a clear\n  // renderable or any renderable\n  publicAPI.addMissingChildren = children => {\n    if (!children || !children.length) {\n      return;\n    }\n    for (let index = 0; index < children.length; ++index) {\n      const child = children[index];\n      const cindex = model.children.indexOf(child);\n      if (cindex === -1) {\n        child.setParent(publicAPI);\n        model.children.push(child);\n        const childRenderable = child.getRenderable();\n        if (childRenderable) {\n          model._renderableChildMap.set(childRenderable, child);\n        }\n      }\n      child.setVisited(true);\n    }\n  };\n  publicAPI.removeNode = child => {\n    const childIdx = model.children.findIndex(x => x === child);\n    if (childIdx < 0) {\n      return false;\n    }\n    const renderable = child.getRenderable();\n    if (renderable) {\n      model._renderableChildMap.delete(renderable);\n    }\n    child.delete();\n    model.children.splice(childIdx, 1);\n    return true;\n  };\n  publicAPI.prepareNodes = () => {\n    for (let index = 0; index < model.children.length; ++index) {\n      model.children[index].setVisited(false);\n    }\n  };\n  publicAPI.setVisited = val => {\n    model.visited = val;\n  };\n  publicAPI.removeUnusedNodes = () => {\n    let visitedCount = 0;\n    for (let index = 0; index < model.children.length; ++index) {\n      const child = model.children[index];\n      const visited = child.getVisited();\n      if (visited) {\n        model.children[visitedCount++] = child;\n        child.setVisited(false);\n      } else {\n        const renderable = child.getRenderable();\n        if (renderable) {\n          model._renderableChildMap.delete(renderable);\n        }\n        child.delete();\n      }\n    }\n    model.children.length = visitedCount;\n  };\n  publicAPI.createViewNode = dataObj => {\n    if (!model.myFactory) {\n      vtkErrorMacro('Cannot create view nodes without my own factory');\n      return null;\n    }\n    const ret = model.myFactory.createNode(dataObj);\n    if (ret) {\n      ret.setRenderable(dataObj);\n    }\n    return ret;\n  };\n  const parentDelete = publicAPI.delete;\n  publicAPI.delete = () => {\n    for (let i = 0; i < model.children.length; i++) {\n      model.children[i].delete();\n    }\n    parentDelete();\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  // _parent: null,\n  renderable: null,\n  myFactory: null,\n  children: [],\n  visited: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.event(publicAPI, model, 'event');\n  model._renderableChildMap = new Map();\n  macro.get(publicAPI, model, ['visited']);\n  macro.setGet(publicAPI, model, ['_parent', 'renderable', 'myFactory']);\n  macro.getArray(publicAPI, model, ['children']);\n  macro.moveToProtected(publicAPI, model, ['parent']);\n\n  // Object methods\n  vtkViewNode(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkViewNode');\n\n// ----------------------------------------------------------------------------\n\nvar vtkViewNode$1 = {\n  newInstance,\n  extend,\n  PASS_TYPES\n};\n\nexport { vtkViewNode$1 as default };\n", "/**\n * Even when the EXT_texture_norm16 extension is present, linear filtering\n * might not be supported for normalized fixed point textures.\n *\n * This is a driver bug. See https://github.com/KhronosGroup/WebGL/issues/3706\n * @return {boolean}\n */\nfunction supportsNorm16Linear() {\n  try {\n    const canvasSize = 4;\n    const texWidth = 2;\n    const texHeight = 1;\n    const texData = new Int16Array([0, 2 ** 15 - 1]);\n    const pixelToCheck = [1, 1];\n    const canvas = document.createElement('canvas');\n    canvas.width = canvasSize;\n    canvas.height = canvasSize;\n    const gl = canvas.getContext('webgl2');\n    if (!gl) {\n      return false;\n    }\n    const ext = gl.getExtension('EXT_texture_norm16');\n    if (!ext) {\n      return false;\n    }\n    const vs = `#version 300 es\n    void main() {\n      gl_PointSize = ${canvasSize.toFixed(1)};\n      gl_Position = vec4(0, 0, 0, 1);\n    }\n  `;\n    const fs = `#version 300 es\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n\n    uniform sampler2D u_image;\n\n    out vec4 color;\n\n    void main() {\n        vec4 intColor = texture(u_image, gl_PointCoord.xy);\n        color = vec4(vec3(intColor.rrr), 1);\n    }\n    `;\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(vertexShader, vs);\n    gl.compileShader(vertexShader);\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      return false;\n    }\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(fragmentShader, fs);\n    gl.compileShader(fragmentShader);\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      return false;\n    }\n    const program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      return false;\n    }\n    const tex = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, tex);\n    gl.texImage2D(gl.TEXTURE_2D, 0, ext.R16_SNORM_EXT, texWidth, texHeight, 0, gl.RED, gl.SHORT, texData);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.useProgram(program);\n    gl.drawArrays(gl.POINTS, 0, 1);\n    const pixel = new Uint8Array(4);\n    gl.readPixels(pixelToCheck[0], pixelToCheck[1], 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n    const [r, g, b] = pixel;\n    const webglLoseContext = gl.getExtension('WEBGL_lose_context');\n    if (webglLoseContext) {\n      webglLoseContext.loseContext();\n    }\n    return r === g && g === b && r !== 0;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * @type {boolean | undefined}\n */\nlet supportsNorm16LinearCache;\nfunction supportsNorm16LinearCached() {\n  // Only create a canvas+texture+shaders the first time\n  if (supportsNorm16LinearCache === undefined) {\n    supportsNorm16LinearCache = supportsNorm16Linear();\n  }\n  return supportsNorm16LinearCache;\n}\n\nexport { supportsNorm16LinearCached as default };\n", "import { m as macro } from '../../macros2.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// export const SHADER_TYPES = ['Vertex', 'Fragment', 'Geometry', 'Unknown'];\n\n// ----------------------------------------------------------------------------\n// vtkShader methods\n// ----------------------------------------------------------------------------\n\nfunction vtkShader(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkShader');\n  publicAPI.compile = () => {\n    let stype = model.context.VERTEX_SHADER;\n    if (!model.source || !model.source.length || model.shaderType === 'Unknown') {\n      return false;\n    }\n\n    // Ensure we delete the previous shader if necessary.\n    if (model.handle !== 0) {\n      model.context.deleteShader(model.handle);\n      model.handle = 0;\n    }\n    switch (model.shaderType) {\n      // case vtkShader::Geometry:\n      //   type = GL_GEOMETRY_SHADER;\n      //   break;\n      case 'Fragment':\n        stype = model.context.FRAGMENT_SHADER;\n        break;\n      case 'Vertex':\n      default:\n        stype = model.context.VERTEX_SHADER;\n        break;\n    }\n    model.handle = model.context.createShader(stype);\n    model.context.shaderSource(model.handle, model.source);\n    model.context.compileShader(model.handle);\n    const isCompiled = model.context.getShaderParameter(model.handle, model.context.COMPILE_STATUS);\n    if (!isCompiled) {\n      const lastError = model.context.getShaderInfoLog(model.handle);\n      vtkErrorMacro(`Error compiling shader '${model.source}': ${lastError}`);\n      model.context.deleteShader(model.handle);\n      model.handle = 0;\n      return false;\n    }\n\n    // The shader compiled, store its handle and return success.\n    return true;\n  };\n  publicAPI.cleanup = () => {\n    if (model.shaderType === 'Unknown' || model.handle === 0) {\n      return;\n    }\n    model.context.deleteShader(model.handle);\n    model.handle = 0;\n    model.dirty = true;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  shaderType: 'Unknown',\n  source: '',\n  error: '',\n  handle: 0,\n  dirty: false,\n  context: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.setGet(publicAPI, model, ['shaderType', 'source', 'error', 'handle', 'context']);\n\n  // Object methods\n  vtkShader(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkShader');\n\n// ----------------------------------------------------------------------------\n\nvar vtkShader$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkShader$1 as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkShader from './Shader.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// perform in place string substitutions, indicate if a substitution was done\n// this is useful for building up shader strings which typically involve\n// lots of string substitutions. Return true if a substitution was done.\nfunction substitute(source, search, replace, all) {\n  // We only accept strings or array of strings, typeof is faster than Array.isArray\n  const replaceStr = typeof replace === 'string' ? replace : replace.join('\\n');\n\n  // We don't need to instantiate a RegExp if we don't want a global substitution.\n  // In all other cases, we need to take the provided string or RegExp and\n  // instantiate a new one to add the `g` flag.\n  // Argument defaults are transpiled to slow `arguments`-based operations\n  // better assume undefined as flag to know if the value is set or not\n  const replaceSearch = all === false ? search : new RegExp(search, 'g');\n  const resultstr = source.replace(replaceSearch, replaceStr);\n  return {\n    // If the result is different than the input, we did perform a replacement\n    replace: resultstr !== replaceStr,\n    result: resultstr\n  };\n}\n\n// ----------------------------------------------------------------------------\n// vtkShaderProgram methods\n// ----------------------------------------------------------------------------\n\nfunction vtkShaderProgram(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkShaderProgram');\n  publicAPI.compileShader = () => {\n    if (!model.vertexShader.compile()) {\n      vtkErrorMacro(model.vertexShader.getSource().split('\\n').map((line, index) => `${index}: ${line}`).join('\\n'));\n      vtkErrorMacro(model.vertexShader.getError());\n      return 0;\n    }\n    if (!model.fragmentShader.compile()) {\n      vtkErrorMacro(model.fragmentShader.getSource().split('\\n').map((line, index) => `${index}: ${line}`).join('\\n'));\n      vtkErrorMacro(model.fragmentShader.getError());\n      return 0;\n    }\n    // skip geometry for now\n    if (!publicAPI.attachShader(model.vertexShader)) {\n      vtkErrorMacro(model.error);\n      return 0;\n    }\n    if (!publicAPI.attachShader(model.fragmentShader)) {\n      vtkErrorMacro(model.error);\n      return 0;\n    }\n    if (!publicAPI.link()) {\n      vtkErrorMacro(`Links failed: ${model.error}`);\n      return 0;\n    }\n    publicAPI.setCompiled(true);\n    return 1;\n  };\n  publicAPI.cleanup = () => {\n    if (model.shaderType === 'Unknown' || model.handle === 0) {\n      return;\n    }\n    publicAPI.release();\n    if (model.vertexShaderHandle !== 0) {\n      model.context.detachShader(model.handle, model.vertexShaderHandle);\n      model.vertexShaderHandle = 0;\n    }\n    if (model.fragmentShaderHandle !== 0) {\n      model.context.detachShader(model.handle, model.fragmentShaderHandle);\n      model.fragmentShaderHandle = 0;\n    }\n    model.context.deleteProgram(model.handle);\n    model.handle = 0;\n    publicAPI.setCompiled(false);\n  };\n  publicAPI.bind = () => {\n    if (!model.linked && !publicAPI.link()) {\n      return false;\n    }\n    model.context.useProgram(model.handle);\n    publicAPI.setBound(true);\n    return true;\n  };\n  publicAPI.isBound = () => !!model.bound;\n  publicAPI.release = () => {\n    model.context.useProgram(null);\n    publicAPI.setBound(false);\n  };\n  publicAPI.setContext = ctx => {\n    model.vertexShader.setContext(ctx);\n    model.fragmentShader.setContext(ctx);\n    model.geometryShader.setContext(ctx);\n  };\n  publicAPI.link = () => {\n    if (model.linked) {\n      return true;\n    }\n    if (model.handle === 0) {\n      model.error = 'Program has not been initialized, and/or does not have shaders.';\n      return false;\n    }\n\n    // clear out the list of uniforms used\n    model.uniformLocs = {};\n    model.context.linkProgram(model.handle);\n    const isCompiled = model.context.getProgramParameter(model.handle, model.context.LINK_STATUS);\n    if (!isCompiled) {\n      const lastError = model.context.getProgramInfoLog(model.handle);\n      vtkErrorMacro(`Error linking shader ${lastError}`);\n      model.handle = 0;\n      return false;\n    }\n    publicAPI.setLinked(true);\n    model.attributeLocs = {};\n    return true;\n  };\n  publicAPI.setUniformMatrix = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    const f32 = new Float32Array(v);\n    model.context.uniformMatrix4fv(location, false, f32);\n    return true;\n  };\n  publicAPI.setUniformMatrix3x3 = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    const f32 = new Float32Array(v);\n    model.context.uniformMatrix3fv(location, false, f32);\n    return true;\n  };\n  publicAPI.setUniformf = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform1f(location, v);\n    return true;\n  };\n  publicAPI.setUniformfv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform1fv(location, v);\n    return true;\n  };\n  publicAPI.setUniformi = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform1i(location, v);\n    return true;\n  };\n  publicAPI.setUniformiv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform1iv(location, v);\n    return true;\n  };\n  publicAPI.setUniform2f = (name, v1, v2) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    if (v2 === undefined) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform2f(location, v1, v2);\n    return true;\n  };\n  publicAPI.setUniform2fv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform2fv(location, v);\n    return true;\n  };\n  publicAPI.setUniform2i = (name, v1, v2) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    if (v2 === undefined) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform2i(location, v1, v2);\n    return true;\n  };\n  publicAPI.setUniform2iv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform2iv(location, v);\n    return true;\n  };\n  publicAPI.setUniform3f = (name, a1, a2, a3) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    if (a3 === undefined) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform3f(location, a1, a2, a3);\n    return true;\n  };\n  publicAPI.setUniform3fArray = (name, a) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    if (!Array.isArray(a) || a.length !== 3) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform3f(location, a[0], a[1], a[2]);\n    return true;\n  };\n  publicAPI.setUniform3fv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform3fv(location, v);\n    return true;\n  };\n  publicAPI.setUniform3i = function (name) {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    let array = args;\n    // allow an array passed as a single argument\n    if (array.length === 1 && Array.isArray(array[0])) {\n      array = array[0];\n    }\n    if (array.length !== 3) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform3i(location, array[0], array[1], array[2]);\n    return true;\n  };\n  publicAPI.setUniform3iv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform3iv(location, v);\n    return true;\n  };\n  publicAPI.setUniform4f = function (name) {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    let array = args;\n    // allow an array passed as a single argument\n    if (array.length === 1 && Array.isArray(array[0])) {\n      array = array[0];\n    }\n    if (array.length !== 4) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform4f(location, array[0], array[1], array[2], array[3]);\n    return true;\n  };\n  publicAPI.setUniform4fv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform4fv(location, v);\n    return true;\n  };\n  publicAPI.setUniform4i = function (name) {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    let array = args;\n    // allow an array passed as a single argument\n    if (array.length === 1 && Array.isArray(array[0])) {\n      array = array[0];\n    }\n    if (array.length !== 4) {\n      throw new RangeError('Invalid number of values for array');\n    }\n    model.context.uniform4i(location, array[0], array[1], array[2], array[3]);\n    return true;\n  };\n  publicAPI.setUniform4iv = (name, v) => {\n    const location = publicAPI.findUniform(name);\n    if (location === -1) {\n      model.error = `Could not set uniform ${name} . No such uniform.`;\n      return false;\n    }\n    model.context.uniform4iv(location, v);\n    return true;\n  };\n  publicAPI.findUniform = name => {\n    if (!name || !model.linked) {\n      return -1;\n    }\n\n    // see if we have cached the result\n    let loc = model.uniformLocs[name];\n    if (loc !== undefined) {\n      return loc;\n    }\n    loc = model.context.getUniformLocation(model.handle, name);\n    if (loc === null) {\n      model.error = `Uniform ${name} not found in current shader program.`;\n      model.uniformLocs[name] = -1;\n      return -1;\n    }\n    model.uniformLocs[name] = loc;\n    return loc;\n  };\n  publicAPI.isUniformUsed = name => {\n    if (!name) {\n      return false;\n    }\n\n    // see if we have cached the result\n    let loc = model.uniformLocs[name];\n    if (loc !== undefined) {\n      return loc !== null;\n    }\n    if (!model.linked) {\n      vtkErrorMacro('attempt to find uniform when the shader program is not linked');\n      return false;\n    }\n    loc = model.context.getUniformLocation(model.handle, name);\n    model.uniformLocs[name] = loc;\n    if (loc === null) {\n      return false;\n    }\n    return true;\n  };\n  publicAPI.isAttributeUsed = name => {\n    if (!name) {\n      return false;\n    }\n\n    // see if we have cached the result\n    if (name in model.attributeLocs) {\n      return true;\n    }\n    if (!model.linked) {\n      vtkErrorMacro('attempt to find uniform when the shader program is not linked');\n      return false;\n    }\n    const loc = model.context.getAttribLocation(model.handle, name);\n    if (loc === -1) {\n      return false;\n    }\n    model.attributeLocs[name] = loc;\n    return true;\n  };\n  publicAPI.attachShader = shader => {\n    if (shader.getHandle() === 0) {\n      model.error = 'Shader object was not initialized, cannot attach it.';\n      return false;\n    }\n    if (shader.getShaderType() === 'Unknown') {\n      model.error = 'Shader object is of type Unknown and cannot be used.';\n      return false;\n    }\n    if (model.handle === 0) {\n      const thandle = model.context.createProgram();\n      if (thandle === 0) {\n        model.error = 'Could not create shader program.';\n        return false;\n      }\n      model.handle = thandle;\n      model.linked = false;\n    }\n    if (shader.getShaderType() === 'Vertex') {\n      if (model.vertexShaderHandle !== 0) {\n        model.context.detachShader(model.handle, model.vertexShaderHandle);\n      }\n      model.vertexShaderHandle = shader.getHandle();\n    }\n    if (shader.getShaderType() === 'Fragment') {\n      if (model.fragmentShaderHandle !== 0) {\n        model.context.detachShader(model.handle, model.fragmentShaderHandle);\n      }\n      model.fragmentShaderHandle = shader.getHandle();\n    }\n    model.context.attachShader(model.handle, shader.getHandle());\n    publicAPI.setLinked(false);\n    return true;\n  };\n  publicAPI.detachShader = shader => {\n    if (shader.getHandle() === 0) {\n      model.error = 'shader object was not initialized, cannot attach it.';\n      return false;\n    }\n    if (shader.getShaderType() === 'Unknown') {\n      model.error = 'Shader object is of type Unknown and cannot be used.';\n      return false;\n    }\n    if (model.handle === 0) {\n      model.error = 'This shader program has not been initialized yet.';\n    }\n    switch (shader.getShaderType()) {\n      case 'Vertex':\n        if (model.vertexShaderHandle !== shader.getHandle()) {\n          model.error = 'The supplied shader was not attached to this program.';\n          return false;\n        }\n        model.context.detachShader(model.handle, shader.getHandle());\n        model.vertexShaderHandle = 0;\n        model.linked = false;\n        return true;\n      case 'Fragment':\n        if (model.fragmentShaderHandle !== shader.getHandle()) {\n          model.error = 'The supplied shader was not attached to this program.';\n          return false;\n        }\n        model.context.detachShader(model.handle, shader.getHandle());\n        model.fragmentShaderHandle = 0;\n        model.linked = false;\n        return true;\n      default:\n        return false;\n    }\n  };\n  publicAPI.setContext = ctx => {\n    model.context = ctx;\n    model.vertexShader.setContext(ctx);\n    model.fragmentShader.setContext(ctx);\n    model.geometryShader.setContext(ctx);\n  };\n  publicAPI.setLastCameraMTime = mtime => {\n    model.lastCameraMTime = mtime;\n  };\n\n  // publicAPI.enableAttributeArray = (name) => {\n  //   const location = publicAPI.findAttributeArray(name);\n  //   if (location === -1) {\n  //     model.error = `Could not enable attribute ${name} No such attribute.`;\n  //     return false;\n  //   }\n  //   model.context.enableVertexAttribArray(location);\n  //   return true;\n  // };\n\n  // publicAPI.disableAttributeArray = (name) => {\n  //   const location = publicAPI.findAttributeArray(name);\n  //   if (location === -1) {\n  //     model.error = `Could not enable attribute ${name} No such attribute.`;\n  //     return false;\n  //   }\n  //   model.context.disableVertexAttribArray(location);\n  //   return true;\n  // };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  vertexShaderHandle: 0,\n  fragmentShaderHandle: 0,\n  geometryShaderHandle: 0,\n  vertexShader: null,\n  fragmentShader: null,\n  geometryShader: null,\n  linked: false,\n  bound: false,\n  compiled: false,\n  error: '',\n  handle: 0,\n  numberOfOutputs: 0,\n  attributesLocs: null,\n  uniformLocs: null,\n  md5Hash: 0,\n  context: null,\n  lastCameraMTime: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Instantiate internal objects\n  model.attributesLocs = {};\n  model.uniformLocs = {};\n  model.vertexShader = vtkShader.newInstance();\n  model.vertexShader.setShaderType('Vertex');\n  model.fragmentShader = vtkShader.newInstance();\n  model.fragmentShader.setShaderType('Fragment');\n  model.geometryShader = vtkShader.newInstance();\n  model.geometryShader.setShaderType('Geometry');\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['lastCameraMTime']);\n  macro.setGet(publicAPI, model, ['error', 'handle', 'compiled', 'bound', 'md5Hash', 'vertexShader', 'fragmentShader', 'geometryShader', 'linked']);\n\n  // Object methods\n  vtkShaderProgram(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkShaderProgram');\n\n// ----------------------------------------------------------------------------\n\nvar vtkShaderProgram$1 = {\n  newInstance,\n  extend,\n  substitute\n};\n\nexport { vtkShaderProgram$1 as default, substitute };\n", "const ObjectType = {\n  ARRAY_BUFFER: 0,\n  ELEMENT_ARRAY_BUFFER: 1,\n  TEXTURE_BUFFER: 2\n};\nvar Constants = {\n  ObjectType\n};\n\nexport { ObjectType, Constants as default };\n", "import { m as macro } from '../../macros2.js';\nimport Constants from './BufferObject/Constants.js';\n\nconst {\n  ObjectType\n} = Constants;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\n\nconst STATIC = {};\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLBufferObject methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLBufferObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLBufferObject');\n\n  // Class-specific private functions\n  function convertType(type) {\n    switch (type) {\n      case ObjectType.ELEMENT_ARRAY_BUFFER:\n        return model.context.ELEMENT_ARRAY_BUFFER;\n      case ObjectType.TEXTURE_BUFFER:\n        if ('TEXTURE_BUFFER' in model.context) {\n          return model.context.TEXTURE_BUFFER;\n        }\n      /* eslint-disable no-fallthrough */\n      // Intentional fallthrough in case there is no TEXTURE_BUFFER in WebGL\n      case ObjectType.ARRAY_BUFFER:\n      default:\n        return model.context.ARRAY_BUFFER;\n      /* eslint-enable no-fallthrough */\n    }\n  }\n\n  let internalType = null;\n  let internalHandle = null;\n  let dirty = true;\n  let error = '';\n\n  // Public API methods\n  publicAPI.getType = () => internalType;\n  publicAPI.setType = value => {\n    internalType = value;\n  };\n  publicAPI.getHandle = () => internalHandle;\n  publicAPI.isReady = () => dirty === false;\n  publicAPI.generateBuffer = type => {\n    const objectTypeGL = convertType(type);\n    if (internalHandle === null) {\n      internalHandle = model.context.createBuffer();\n      internalType = type;\n    }\n    return convertType(internalType) === objectTypeGL;\n  };\n  publicAPI.upload = (data, type) => {\n    // buffer, size, type\n    const alreadyGenerated = publicAPI.generateBuffer(type);\n    if (!alreadyGenerated) {\n      error = 'Trying to upload array buffer to incompatible buffer.';\n      return false;\n    }\n    model.context.bindBuffer(convertType(internalType), internalHandle);\n    model.context.bufferData(convertType(internalType), data, model.context.STATIC_DRAW);\n    model.allocatedGPUMemoryInBytes = data.length * data.BYTES_PER_ELEMENT;\n    dirty = false;\n    return true;\n  };\n  publicAPI.bind = () => {\n    if (!internalHandle) {\n      return false;\n    }\n    model.context.bindBuffer(convertType(internalType), internalHandle);\n    return true;\n  };\n  publicAPI.release = () => {\n    if (!internalHandle) {\n      return false;\n    }\n    model.context.bindBuffer(convertType(internalType), null);\n    return true;\n  };\n  publicAPI.releaseGraphicsResources = () => {\n    if (internalHandle !== null) {\n      model.context.bindBuffer(convertType(internalType), null);\n      model.context.deleteBuffer(internalHandle);\n      internalHandle = null;\n      model.allocatedGPUMemoryInBytes = 0;\n    }\n  };\n  publicAPI.setOpenGLRenderWindow = rw => {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n  publicAPI.getError = () => error;\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  objectType: ObjectType.ARRAY_BUFFER,\n  // _openGLRenderWindow: null,\n  context: null,\n  allocatedGPUMemoryInBytes: 0\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Object methods\n  macro.obj(publicAPI, model);\n  macro.get(publicAPI, model, ['_openGLRenderWindow', 'allocatedGPUMemoryInBytes']);\n  macro.moveToProtected(publicAPI, model, ['openGLRenderWindow']);\n  vtkOpenGLBufferObject(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkBufferObject = {\n  newInstance,\n  extend,\n  ...STATIC,\n  ...Constants\n};\n\nexport { STATIC, vtkBufferObject as default, extend, newInstance };\n", "function computeCoordShiftAndScale(points) {\n  // Find out if shift scale should be used\n  // Compute squares of diagonal size and distance from the origin\n  let diagSq = 0.0;\n  let distSq = 0.0;\n  for (let i = 0; i < 3; ++i) {\n    const range = points.getRange(i);\n    const delta = range[1] - range[0];\n    diagSq += delta * delta;\n    const distShift = 0.5 * (range[1] + range[0]);\n    distSq += distShift * distShift;\n  }\n  const useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1.0e6 ||\n  // If data is far from the origin relative to its size\n  Math.abs(Math.log10(diagSq)) > 3.0 ||\n  // If the size is huge when not far from the origin\n  diagSq === 0 && distSq > 1.0e6); // If data is a point, but far from the origin\n\n  if (useShiftAndScale) {\n    // Compute shift and scale vectors\n    const coordShift = new Float64Array(3);\n    const coordScale = new Float64Array(3);\n    for (let i = 0; i < 3; ++i) {\n      const range = points.getRange(i);\n      const delta = range[1] - range[0];\n      coordShift[i] = 0.5 * (range[1] + range[0]);\n      coordScale[i] = delta > 0 ? 1.0 / delta : 1.0;\n    }\n    return {\n      useShiftAndScale,\n      coordShift,\n      coordScale\n    };\n  }\n  return {\n    useShiftAndScale,\n    coordShift: new Float32Array([0, 0, 0]),\n    coordScale: new Float32Array([1, 1, 1])\n  };\n}\nvar helpers = {\n  computeCoordShiftAndScale\n};\n\nexport { computeCoordShiftAndScale, helpers as default };\n", "import { vec3, mat4, quat } from 'gl-matrix';\nimport { m as macro } from '../../macros2.js';\nimport vtkBufferObject from './BufferObject.js';\nimport { ObjectType } from './BufferObject/Constants.js';\nimport { Representation } from '../Core/Property/Constants.js';\nimport { computeCoordShiftAndScale } from './CellArrayBufferObject/helpers.js';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// Static functions\n// ----------------------------------------------------------------------------\n\nfunction computeInverseShiftAndScaleMatrix(coordShift, coordScale) {\n  const inverseScale = new Float64Array(3);\n  vec3.inverse(inverseScale, coordScale);\n  const matrix = new Float64Array(16);\n  mat4.fromRotationTranslationScale(matrix, quat.create(), coordShift, inverseScale);\n  return matrix;\n}\nfunction shouldApplyCoordShiftAndScale(coordShift, coordScale) {\n  if (coordShift === null || coordScale === null) {\n    return false;\n  }\n  return !(vec3.exactEquals(coordShift, [0, 0, 0]) && vec3.exactEquals(coordScale, [1, 1, 1]));\n}\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLCellArrayBufferObject methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLCellArrayBufferObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLCellArrayBufferObject');\n  publicAPI.setType(ObjectType.ARRAY_BUFFER);\n  publicAPI.createVBO = function (cellArray, inRep, outRep, options) {\n    let selectionMaps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    if (!cellArray.getData() || !cellArray.getData().length) {\n      model.elementCount = 0;\n      return 0;\n    }\n\n    // Figure out how big each block will be, currently 6 or 7 floats.\n    model.blockSize = 3;\n    model.vertexOffset = 0;\n    model.normalOffset = 0;\n    model.tCoordOffset = 0;\n    model.tCoordComponents = 0;\n    model.colorComponents = 0;\n    model.colorOffset = 0;\n    model.customData = [];\n    const pointData = options.points.getData();\n    let normalData = null;\n    let tcoordData = null;\n    let colorData = null;\n    const colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;\n    const textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0;\n\n    // the values of 4 below are because floats are 4 bytes\n\n    if (options.normals) {\n      model.normalOffset = 4 * model.blockSize;\n      model.blockSize += 3;\n      normalData = options.normals.getData();\n    }\n    if (options.customAttributes) {\n      options.customAttributes.forEach(a => {\n        if (a) {\n          model.customData.push({\n            data: a.getData(),\n            offset: 4 * model.blockSize,\n            components: a.getNumberOfComponents(),\n            name: a.getName()\n          });\n          model.blockSize += a.getNumberOfComponents();\n        }\n      });\n    }\n    if (options.tcoords) {\n      model.tCoordOffset = 4 * model.blockSize;\n      model.tCoordComponents = textureComponents;\n      model.blockSize += textureComponents;\n      tcoordData = options.tcoords.getData();\n    }\n    if (options.colors) {\n      model.colorComponents = options.colors.getNumberOfComponents();\n      model.colorOffset = 0;\n      colorData = options.colors.getData();\n      if (!model.colorBO) {\n        model.colorBO = vtkBufferObject.newInstance();\n      }\n      model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);\n    } else {\n      model.colorBO = null;\n    }\n    model.stride = 4 * model.blockSize;\n    let pointIdx = 0;\n    let normalIdx = 0;\n    let tcoordIdx = 0;\n    let colorIdx = 0;\n    let custIdx = 0;\n    let cellCount = 0;\n    let addAPoint;\n    const cellBuilders = {\n      // easy, every input point becomes an output point\n      anythingToPoints(numPoints, cellPts, offset, cellId) {\n        for (let i = 0; i < numPoints; ++i) {\n          addAPoint(cellPts[offset + i], cellId);\n        }\n      },\n      linesToWireframe(numPoints, cellPts, offset, cellIdx) {\n        // for lines we add a bunch of segments\n        for (let i = 0; i < numPoints - 1; ++i) {\n          addAPoint(cellPts[offset + i], cellIdx);\n          addAPoint(cellPts[offset + i + 1], cellIdx);\n        }\n      },\n      polysToWireframe(numPoints, cellPts, offset, cellIdx) {\n        // for polys we add a bunch of segments and close it\n        if (numPoints > 2) {\n          for (let i = 0; i < numPoints; ++i) {\n            addAPoint(cellPts[offset + i], cellIdx);\n            addAPoint(cellPts[offset + (i + 1) % numPoints], cellIdx);\n          }\n        }\n      },\n      stripsToWireframe(numPoints, cellPts, offset, cellIdx) {\n        if (numPoints > 2) {\n          // for strips we add a bunch of segments and close it\n          for (let i = 0; i < numPoints - 1; ++i) {\n            addAPoint(cellPts[offset + i], cellIdx);\n            addAPoint(cellPts[offset + i + 1], cellIdx);\n          }\n          for (let i = 0; i < numPoints - 2; i++) {\n            addAPoint(cellPts[offset + i], cellIdx);\n            addAPoint(cellPts[offset + i + 2], cellIdx);\n          }\n        }\n      },\n      polysToSurface(npts, cellPts, offset, cellIdx) {\n        for (let i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + 0], cellIdx);\n          addAPoint(cellPts[offset + i + 1], cellIdx);\n          addAPoint(cellPts[offset + i + 2], cellIdx);\n        }\n      },\n      stripsToSurface(npts, cellPts, offset, cellIdx) {\n        for (let i = 0; i < npts - 2; i++) {\n          addAPoint(cellPts[offset + i], cellIdx);\n          addAPoint(cellPts[offset + i + 1 + i % 2], cellIdx);\n          addAPoint(cellPts[offset + i + 1 + (i + 1) % 2], cellIdx);\n        }\n      }\n    };\n    const cellCounters = {\n      // easy, every input point becomes an output point\n      anythingToPoints(numPoints, cellPts) {\n        return numPoints;\n      },\n      linesToWireframe(numPoints, cellPts) {\n        if (numPoints > 1) {\n          return (numPoints - 1) * 2;\n        }\n        return 0;\n      },\n      polysToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 2;\n        }\n        return 0;\n      },\n      stripsToWireframe(numPoints, cellPts) {\n        if (numPoints > 2) {\n          return numPoints * 4 - 6;\n        }\n        return 0;\n      },\n      polysToSurface(npts, cellPts) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n        return 0;\n      },\n      stripsToSurface(npts, cellPts, offset) {\n        if (npts > 2) {\n          return (npts - 2) * 3;\n        }\n        return 0;\n      }\n    };\n    let func = null;\n    let countFunc = null;\n    if (outRep === Representation.POINTS || inRep === 'verts') {\n      func = cellBuilders.anythingToPoints;\n      countFunc = cellCounters.anythingToPoints;\n    } else if (outRep === Representation.WIREFRAME || inRep === 'lines') {\n      func = cellBuilders[`${inRep}ToWireframe`];\n      countFunc = cellCounters[`${inRep}ToWireframe`];\n    } else {\n      func = cellBuilders[`${inRep}ToSurface`];\n      countFunc = cellCounters[`${inRep}ToSurface`];\n    }\n    const array = cellArray.getData();\n    const size = array.length;\n    let caboCount = 0;\n    for (let index = 0; index < size;) {\n      caboCount += countFunc(array[index], array);\n      index += array[index] + 1;\n    }\n    let packedUCVBO = null;\n    const packedVBO = new Float32Array(caboCount * model.blockSize);\n    if (colorData) {\n      packedUCVBO = new Uint8Array(caboCount * 4);\n    }\n    let vboidx = 0;\n    let ucidx = 0;\n\n    // Find out if shift scale should be used\n    const {\n      useShiftAndScale,\n      coordShift,\n      coordScale\n    } = computeCoordShiftAndScale(options.points);\n    if (useShiftAndScale) {\n      publicAPI.setCoordShiftAndScale(coordShift, coordScale);\n    } else if (model.coordShiftAndScaleEnabled === true) {\n      // Make sure to reset\n      publicAPI.setCoordShiftAndScale(null, null);\n    }\n\n    // Initialize the structures used to keep track of point ids and cell ids for selectors\n    if (selectionMaps) {\n      if (!selectionMaps.points && !selectionMaps.cells) {\n        selectionMaps.points = new Int32Array(caboCount);\n        selectionMaps.cells = new Int32Array(caboCount);\n      } else {\n        const newPoints = new Int32Array(caboCount + selectionMaps.points.length);\n        newPoints.set(selectionMaps.points);\n        selectionMaps.points = newPoints;\n        const newCells = new Int32Array(caboCount + selectionMaps.cells.length);\n        newCells.set(selectionMaps.cells);\n        selectionMaps.cells = newCells;\n      }\n    }\n    let pointCount = options.vertexOffset;\n    addAPoint = function addAPointFunc(pointId, cellId) {\n      // Keep track of original point and cell ids, for selection\n      if (selectionMaps) {\n        selectionMaps.points[pointCount] = pointId;\n        selectionMaps.cells[pointCount] = cellCount + options.cellOffset;\n      }\n      ++pointCount;\n\n      // Vertices\n      pointIdx = pointId * 3;\n      if (!model.coordShiftAndScaleEnabled) {\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n        packedVBO[vboidx++] = pointData[pointIdx++];\n      } else {\n        // Apply shift and scale\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];\n        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];\n      }\n      if (normalData !== null) {\n        if (options.haveCellNormals) {\n          normalIdx = (cellCount + options.cellOffset) * 3;\n        } else {\n          normalIdx = pointId * 3;\n        }\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n        packedVBO[vboidx++] = normalData[normalIdx++];\n      }\n      model.customData.forEach(attr => {\n        custIdx = pointId * attr.components;\n        for (let j = 0; j < attr.components; ++j) {\n          packedVBO[vboidx++] = attr.data[custIdx++];\n        }\n      });\n      if (tcoordData !== null) {\n        if (options.useTCoordsPerCell) {\n          tcoordIdx = cellId * textureComponents;\n        } else {\n          tcoordIdx = pointId * textureComponents;\n        }\n        for (let j = 0; j < textureComponents; ++j) {\n          packedVBO[vboidx++] = tcoordData[tcoordIdx++];\n        }\n      }\n      if (colorData !== null) {\n        if (options.haveCellScalars) {\n          colorIdx = (cellCount + options.cellOffset) * colorComponents;\n        } else {\n          colorIdx = pointId * colorComponents;\n        }\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorData[colorIdx++];\n        packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;\n      }\n    };\n\n    // Browse the cell array: the index is at the beginning of a cell\n    // The value of 'array' at the position 'index' is the number of points in the cell\n    for (let index = 0; index < size; index += array[index] + 1, cellCount++) {\n      func(array[index], array, index + 1, cellCount + options.cellOffset);\n    }\n    model.elementCount = caboCount;\n    publicAPI.upload(packedVBO, ObjectType.ARRAY_BUFFER);\n    if (model.colorBO) {\n      model.colorBOStride = 4;\n      model.colorBO.upload(packedUCVBO, ObjectType.ARRAY_BUFFER);\n    }\n    return cellCount;\n  };\n  publicAPI.setCoordShiftAndScale = (coordShift, coordScale) => {\n    if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {\n      vtkErrorMacro('Wrong type for coordShift, expected vec3 or null');\n      return;\n    }\n    if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {\n      vtkErrorMacro('Wrong type for coordScale, expected vec3 or null');\n      return;\n    }\n    if (model.coordShift === null || coordShift === null || !vec3.equals(coordShift, model.coordShift)) {\n      model.coordShift = coordShift;\n    }\n    if (model.coordScale === null || coordScale === null || !vec3.equals(coordScale, model.coordScale)) {\n      model.coordScale = coordScale;\n    }\n    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);\n    if (model.coordShiftAndScaleEnabled) {\n      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);\n    } else {\n      model.inverseShiftAndScaleMatrix = null;\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  elementCount: 0,\n  stride: 0,\n  colorBOStride: 0,\n  vertexOffset: 0,\n  normalOffset: 0,\n  tCoordOffset: 0,\n  tCoordComponents: 0,\n  colorOffset: 0,\n  colorComponents: 0,\n  tcoordBO: null,\n  customData: [],\n  coordShift: null,\n  coordScale: null,\n  coordShiftAndScaleEnabled: false,\n  inverseShiftAndScaleMatrix: null\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkBufferObject.extend(publicAPI, model, initialValues);\n  macro.setGet(publicAPI, model, ['colorBO', 'elementCount', 'stride', 'colorBOStride', 'vertexOffset', 'normalOffset', 'tCoordOffset', 'tCoordComponents', 'colorOffset', 'colorComponents', 'customData']);\n  macro.get(publicAPI, model, ['coordShift', 'coordScale', 'coordShiftAndScaleEnabled', 'inverseShiftAndScaleMatrix']);\n\n  // Object specific methods\n  vtkOpenGLCellArrayBufferObject(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkCellArrayBufferObject = {\n  newInstance,\n  extend\n};\n\nexport { vtkCellArrayBufferObject as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport { ObjectType } from './BufferObject/Constants.js';\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLVertexArrayObject methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLVertexArrayObject(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLVertexArrayObject');\n\n  // Public API methods\n  publicAPI.exposedMethod = () => {\n    // This is a publicly exposed method of this object\n  };\n  publicAPI.initialize = () => {\n    model.instancingExtension = null;\n    if (!model._openGLRenderWindow.getWebgl2()) {\n      model.instancingExtension = model.context.getExtension('ANGLE_instanced_arrays');\n    }\n    if (!model.forceEmulation && model._openGLRenderWindow && model._openGLRenderWindow.getWebgl2()) {\n      model.extension = null;\n      model.supported = true;\n      model.handleVAO = model.context.createVertexArray();\n    } else {\n      model.extension = model.context.getExtension('OES_vertex_array_object');\n      // Start setting up VAO\n      if (!model.forceEmulation && model.extension) {\n        model.supported = true;\n        model.handleVAO = model.extension.createVertexArrayOES();\n      } else {\n        model.supported = false;\n      }\n    }\n  };\n  publicAPI.isReady = () =>\n  // We either probed and allocated a VAO, or are falling back as the current\n  // hardware does not support VAOs.\n  model.handleVAO !== 0 || model.supported === false;\n  publicAPI.bind = () => {\n    // Either simply bind the VAO, or emulate behavior by binding all attributes.\n    if (!publicAPI.isReady()) {\n      publicAPI.initialize();\n    }\n    if (publicAPI.isReady() && model.supported) {\n      if (model.extension) {\n        model.extension.bindVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.bindVertexArray(model.handleVAO);\n      }\n    } else if (publicAPI.isReady()) {\n      const gl = model.context;\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);\n        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          const attrIt = buff.attributes[iatt];\n          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;\n          for (let i = 0; i < matrixCount; ++i) {\n            gl.enableVertexAttribArray(attrIt.index + i);\n            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);\n            if (attrIt.divisor > 0) {\n              if (model.instancingExtension) {\n                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 1);\n              } else {\n                gl.vertexAttribDivisor(attrIt.index + i, 1);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n  publicAPI.release = () => {\n    // Either simply release the VAO, or emulate behavior by releasing all attributes.\n    if (publicAPI.isReady() && model.supported) {\n      if (model.extension) {\n        model.extension.bindVertexArrayOES(null);\n      } else {\n        model.context.bindVertexArray(null);\n      }\n    } else if (publicAPI.isReady()) {\n      const gl = model.context;\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);\n        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          const attrIt = buff.attributes[iatt];\n          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;\n          for (let i = 0; i < matrixCount; ++i) {\n            gl.enableVertexAttribArray(attrIt.index + i);\n            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);\n            if (attrIt.divisor > 0) {\n              if (model.instancingExtension) {\n                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 0);\n              } else {\n                gl.vertexAttribDivisor(attrIt.index + i, 0);\n              }\n            }\n            gl.disableVertexAttribArray(attrIt.index + i);\n          }\n        }\n      }\n    }\n  };\n  publicAPI.shaderProgramChanged = () => {\n    publicAPI.release();\n    if (model.handleVAO) {\n      if (model.extension) {\n        model.extension.deleteVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.deleteVertexArray(model.handleVAO);\n      }\n    }\n    model.handleVAO = 0;\n    model.handleProgram = 0;\n  };\n  publicAPI.releaseGraphicsResources = () => {\n    publicAPI.shaderProgramChanged();\n    if (model.handleVAO) {\n      if (model.extension) {\n        model.extension.deleteVertexArrayOES(model.handleVAO);\n      } else {\n        model.context.deleteVertexArray(model.handleVAO);\n      }\n    }\n    model.handleVAO = 0;\n    model.supported = true;\n    model.handleProgram = 0;\n  };\n  publicAPI.addAttributeArray = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize) => publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, 0, false);\n  publicAPI.addAttributeArrayWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, isMatrix) => {\n    if (!program) {\n      return false;\n    }\n\n    // Check the program is bound, and the buffer is valid.\n    if (!program.isBound() || buffer.getHandle() === 0 || buffer.getType() !== ObjectType.ARRAY_BUFFER) {\n      return false;\n    }\n\n    // Perform initialization if necessary, ensure program matches VAOs.\n    if (model.handleProgram === 0) {\n      model.handleProgram = program.getHandle();\n    }\n    if (!publicAPI.isReady()) {\n      publicAPI.initialize();\n    }\n    if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {\n      return false;\n    }\n    const gl = model.context;\n    const attribs = {};\n    attribs.name = name;\n    attribs.index = gl.getAttribLocation(model.handleProgram, name);\n    attribs.offset = offset;\n    attribs.stride = stride;\n    attribs.type = elementType;\n    attribs.size = elementTupleSize;\n    attribs.normalize = normalize;\n    attribs.isMatrix = isMatrix;\n    attribs.divisor = divisor;\n    if (attribs.Index === -1) {\n      return false;\n    }\n\n    // Always make the call as even the first use wants the attrib pointer setting\n    // up when we are emulating.\n    buffer.bind();\n    gl.enableVertexAttribArray(attribs.index);\n    gl.vertexAttribPointer(attribs.index, attribs.size, attribs.type, attribs.normalize, attribs.stride, attribs.offset);\n    if (divisor > 0) {\n      if (model.instancingExtension) {\n        model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);\n      } else {\n        gl.vertexAttribDivisor(attribs.index, 1);\n      }\n    }\n    attribs.buffer = buffer.getHandle();\n\n    // If vertex array objects are not supported then build up our list.\n    if (!model.supported) {\n      // find the buffer\n      let buffFound = false;\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        if (buff.buffer === attribs.buffer) {\n          buffFound = true;\n          let found = false;\n          for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n            const attrIt = buff.attributes[iatt];\n            if (attrIt.name === name) {\n              found = true;\n              buff.attributes[iatt] = attribs;\n            }\n          }\n          if (!found) {\n            buff.attributes.push(attribs);\n          }\n        }\n      }\n      if (!buffFound) {\n        model.buffers.push({\n          buffer: attribs.buffer,\n          attributes: [attribs]\n        });\n      }\n    }\n    return true;\n  };\n  publicAPI.addAttributeMatrixWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor) => {\n    // bind the first row of values\n    const result = publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize, divisor, true);\n    if (!result) {\n      return result;\n    }\n    const gl = model.context;\n    const index = gl.getAttribLocation(model.handleProgram, name);\n    for (let i = 1; i < elementTupleSize; i++) {\n      gl.enableVertexAttribArray(index + i);\n      gl.vertexAttribPointer(index + i, elementTupleSize, elementType, normalize, stride, offset + stride * i / elementTupleSize);\n      if (divisor > 0) {\n        if (model.instancingExtension) {\n          model.instancingExtension.vertexAttribDivisorANGLE(index + i, 1);\n        } else {\n          gl.vertexAttribDivisor(index + i, 1);\n        }\n      }\n    }\n    return true;\n  };\n  publicAPI.removeAttributeArray = name => {\n    if (!publicAPI.isReady() || model.handleProgram === 0) {\n      return false;\n    }\n\n    // If we don't have real VAOs find the entry and remove it too.\n    if (!model.supported) {\n      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {\n        const buff = model.buffers[ibuff];\n        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {\n          const attrIt = buff.attributes[iatt];\n          if (attrIt.name === name) {\n            buff.attributes.splice(iatt, 1);\n            if (!buff.attributes.length) {\n              model.buffers.splice(ibuff, 1);\n            }\n            return true;\n          }\n        }\n      }\n    }\n    return true;\n  };\n  publicAPI.setOpenGLRenderWindow = rw => {\n    if (model._openGLRenderWindow === rw) {\n      return;\n    }\n    publicAPI.releaseGraphicsResources();\n    model._openGLRenderWindow = rw;\n    model.context = null;\n    if (rw) {\n      model.context = model._openGLRenderWindow.getContext();\n    }\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  forceEmulation: false,\n  handleVAO: 0,\n  handleProgram: 0,\n  supported: true,\n  buffers: null,\n  context: null\n  // _openGLRenderWindow: null,\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Internal objects initialization\n  model.buffers = [];\n\n  // Object methods\n  macro.obj(publicAPI, model);\n\n  // Create get-only macros\n  macro.get(publicAPI, model, ['supported']);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['forceEmulation']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkOpenGLVertexArrayObject(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkOpenGLVertexArrayObject');\n\n// ----------------------------------------------------------------------------\n\nvar vtkVertexArrayObject = {\n  newInstance,\n  extend\n};\n\nexport { vtkVertexArrayObject as default, extend, newInstance };\n", "import { m as macro } from '../../macros2.js';\nimport vtkCellArrayBufferObject from './CellArrayBufferObject.js';\nimport vtkShaderProgram from './ShaderProgram.js';\nimport vtkVertexArrayObject from './VertexArrayObject.js';\nimport { Representation } from '../Core/Property/Constants.js';\n\nconst primTypes = {\n  Start: 0,\n  Points: 0,\n  Lines: 1,\n  Tris: 2,\n  TriStrips: 3,\n  TrisEdges: 4,\n  TriStripsEdges: 5,\n  End: 6\n};\n\n// ----------------------------------------------------------------------------\n// vtkOpenGLHelper methods\n// ----------------------------------------------------------------------------\n\nfunction vtkOpenGLHelper(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkOpenGLHelper');\n  publicAPI.setOpenGLRenderWindow = win => {\n    model.context = win.getContext();\n    model.program.setContext(model.context);\n    model.VAO.setOpenGLRenderWindow(win);\n    model.CABO.setOpenGLRenderWindow(win);\n  };\n  publicAPI.releaseGraphicsResources = oglwin => {\n    model.VAO.releaseGraphicsResources();\n    model.CABO.releaseGraphicsResources();\n    model.CABO.setElementCount(0);\n  };\n  publicAPI.drawArrays = (ren, actor, rep, oglMapper) => {\n    // Are there any entries\n    if (model.CABO.getElementCount()) {\n      // are we drawing edges\n      const mode = publicAPI.getOpenGLMode(rep);\n      const wideLines = publicAPI.haveWideLines(ren, actor);\n      const gl = model.context;\n      const depthMask = gl.getParameter(gl.DEPTH_WRITEMASK);\n      if (model.pointPicking) {\n        gl.depthMask(false);\n      }\n      const drawingLines = mode === gl.LINES;\n      if (drawingLines && wideLines) {\n        publicAPI.updateShaders(ren, actor, oglMapper);\n        gl.drawArraysInstanced(mode, 0, model.CABO.getElementCount(), 2 * Math.ceil(actor.getProperty().getLineWidth()));\n      } else {\n        gl.lineWidth(actor.getProperty().getLineWidth());\n        publicAPI.updateShaders(ren, actor, oglMapper);\n        gl.drawArrays(mode, 0, model.CABO.getElementCount());\n        // reset the line width\n        gl.lineWidth(1);\n      }\n      const stride = (mode === gl.POINTS ? 1 : 0) || (mode === gl.LINES ? 2 : 3);\n      if (model.pointPicking) {\n        gl.depthMask(depthMask);\n      }\n      return model.CABO.getElementCount() / stride;\n    }\n    return 0;\n  };\n  publicAPI.getOpenGLMode = rep => {\n    if (model.pointPicking) {\n      return model.context.POINTS;\n    }\n    const type = model.primitiveType;\n    if (rep === Representation.POINTS || type === primTypes.Points) {\n      return model.context.POINTS;\n    }\n    if (rep === Representation.WIREFRAME || type === primTypes.Lines || type === primTypes.TrisEdges || type === primTypes.TriStripsEdges) {\n      return model.context.LINES;\n    }\n    return model.context.TRIANGLES;\n  };\n  publicAPI.haveWideLines = (ren, actor) => {\n    if (actor.getProperty().getLineWidth() > 1.0) {\n      // we have wide lines, but the OpenGL implementation may\n      // actually support them, check the range to see if we\n      // really need have to implement our own wide lines\n      if (model.CABO.getOpenGLRenderWindow()) {\n        if (model.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth() >= actor.getProperty().getLineWidth()) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  };\n  publicAPI.getNeedToRebuildShaders = (ren, actor, oglMapper) => {\n    // has something changed that would require us to recreate the shader?\n    // candidates are\n    // property modified (representation interpolation and lighting)\n    // input modified\n    // mapper modified (lighting complexity)\n    if (oglMapper.getNeedToRebuildShaders(publicAPI, ren, actor) || publicAPI.getProgram() === 0 || publicAPI.getShaderSourceTime().getMTime() < oglMapper.getMTime() || publicAPI.getShaderSourceTime().getMTime() < actor.getMTime()) {\n      return true;\n    }\n    return false;\n  };\n  publicAPI.updateShaders = (ren, actor, oglMapper) => {\n    // has something changed that would require us to recreate the shader?\n    if (publicAPI.getNeedToRebuildShaders(ren, actor, oglMapper)) {\n      const shaders = {\n        Vertex: null,\n        Fragment: null,\n        Geometry: null\n      };\n      oglMapper.buildShaders(shaders, ren, actor);\n\n      // compile and bind the program if needed\n      const newShader = model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);\n\n      // if the shader changed reinitialize the VAO\n      if (newShader !== publicAPI.getProgram()) {\n        publicAPI.setProgram(newShader);\n        // reset the VAO as the shader has changed\n        publicAPI.getVAO().releaseGraphicsResources();\n      }\n      publicAPI.getShaderSourceTime().modified();\n    } else {\n      model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(publicAPI.getProgram());\n    }\n    publicAPI.getVAO().bind();\n    oglMapper.setMapperShaderParameters(publicAPI, ren, actor);\n    oglMapper.setPropertyShaderParameters(publicAPI, ren, actor);\n    oglMapper.setCameraShaderParameters(publicAPI, ren, actor);\n    oglMapper.setLightingShaderParameters(publicAPI, ren, actor);\n    oglMapper.invokeShaderCallbacks(publicAPI, ren, actor);\n  };\n  publicAPI.setMapperShaderParameters = (ren, actor, size) => {\n    if (publicAPI.haveWideLines(ren, actor)) {\n      publicAPI.getProgram().setUniform2f('viewportSize', size.usize, size.vsize);\n      const lineWidth = parseFloat(actor.getProperty().getLineWidth());\n      const halfLineWidth = lineWidth / 2.0;\n      publicAPI.getProgram().setUniformf('lineWidthStepSize', lineWidth / Math.ceil(lineWidth));\n      publicAPI.getProgram().setUniformf('halfLineWidth', halfLineWidth);\n    }\n    if (model.primitiveType === primTypes.Points || actor.getProperty().getRepresentation() === Representation.POINTS) {\n      publicAPI.getProgram().setUniformf('pointSize', actor.getProperty().getPointSize());\n    } else if (model.pointPicking) {\n      publicAPI.getProgram().setUniformf('pointSize', publicAPI.getPointPickingPrimitiveSize());\n    }\n  };\n  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {\n    let VSSource = shaders.Vertex;\n\n    // Always set point size in case we need picking\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', ['//VTK::PositionVC::Dec', 'uniform float pointSize;']).result;\n    VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['//VTK::PositionVC::Impl', '  gl_PointSize = pointSize;'], false).result;\n\n    // for lines, make sure we add the width code\n    if (publicAPI.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES && publicAPI.haveWideLines(ren, actor)) {\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Dec', ['//VTK::PositionVC::Dec', 'uniform vec2 viewportSize;', 'uniform float lineWidthStepSize;', 'uniform float halfLineWidth;']).result;\n      VSSource = vtkShaderProgram.substitute(VSSource, '//VTK::PositionVC::Impl', ['//VTK::PositionVC::Impl', ' if (halfLineWidth > 0.0)', '   {', '   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;', '   vec4 tmpPos = gl_Position;', '   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;', '   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];', '   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];', '   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);', '   }']).result;\n    }\n    shaders.Vertex = VSSource;\n  };\n  publicAPI.getPointPickingPrimitiveSize = () => {\n    if (model.primitiveType === primTypes.Points) {\n      return 2;\n    }\n    if (model.primitiveType === primTypes.Lines) {\n      return 4;\n    }\n    return 6;\n  };\n  publicAPI.getAllocatedGPUMemoryInBytes = () => publicAPI.getCABO().getAllocatedGPUMemoryInBytes();\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  context: null,\n  program: null,\n  shaderSourceTime: null,\n  VAO: null,\n  attributeUpdateTime: null,\n  CABO: null,\n  primitiveType: 0,\n  pointPicking: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Build VTK API\n  macro.obj(publicAPI, model);\n  model.shaderSourceTime = {};\n  macro.obj(model.shaderSourceTime);\n  model.attributeUpdateTime = {};\n  macro.obj(model.attributeUpdateTime);\n  macro.setGet(publicAPI, model, ['program', 'shaderSourceTime', 'VAO', 'attributeUpdateTime', 'CABO', 'primitiveType', 'pointPicking']);\n  model.program = vtkShaderProgram.newInstance();\n  model.VAO = vtkVertexArrayObject.newInstance();\n  model.CABO = vtkCellArrayBufferObject.newInstance();\n\n  // Object methods\n  vtkOpenGLHelper(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend);\n\n// ----------------------------------------------------------------------------\n\nvar vtkHelper = {\n  newInstance,\n  extend,\n  primTypes\n};\n\nexport { vtkHelper as default, extend, newInstance, primTypes };\n"],
  "mappings": "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",
  "names": ["newInstance", "DEFAULT_VALUES", "extend", "newInstance", "vtkViewNodeFactory", "DEFAULT_VALUES", "extend", "newInstance", "Wrap", "Filter", "vtkErrorMacro", "toHalf", "DeepEqual", "outIdx", "DEFAULT_VALUES", "extend", "newInstance", "vtkErrorMacro", "DEFAULT_VALUES", "extend", "newInstance", "vtkErrorMacro", "DEFAULT_VALUES", "extend", "newInstance", "Constants", "ObjectType", "Constants", "DEFAULT_VALUES", "extend", "newInstance", "vtkErrorMacro", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance", "DEFAULT_VALUES", "extend", "newInstance"]
}
